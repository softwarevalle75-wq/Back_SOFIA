
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model IntentoLogin
 * 
 */
export type IntentoLogin = $Result.DefaultSelection<Prisma.$IntentoLoginPayload>
/**
 * Model Sesion
 * 
 */
export type Sesion = $Result.DefaultSelection<Prisma.$SesionPayload>
/**
 * Model Estudiante
 * 
 */
export type Estudiante = $Result.DefaultSelection<Prisma.$EstudiantePayload>
/**
 * Model Cita
 * 
 */
export type Cita = $Result.DefaultSelection<Prisma.$CitaPayload>
/**
 * Model Auditoria
 * 
 */
export type Auditoria = $Result.DefaultSelection<Prisma.$AuditoriaPayload>
/**
 * Model ConfiguracionWhatsApp
 * 
 */
export type ConfiguracionWhatsApp = $Result.DefaultSelection<Prisma.$ConfiguracionWhatsAppPayload>
/**
 * Model WebhookLog
 * 
 */
export type WebhookLog = $Result.DefaultSelection<Prisma.$WebhookLogPayload>
/**
 * Model PlantillaMensaje
 * 
 */
export type PlantillaMensaje = $Result.DefaultSelection<Prisma.$PlantillaMensajePayload>
/**
 * Model Conversacion
 * 
 */
export type Conversacion = $Result.DefaultSelection<Prisma.$ConversacionPayload>
/**
 * Model Mensaje
 * 
 */
export type Mensaje = $Result.DefaultSelection<Prisma.$MensajePayload>
/**
 * Model Asesoramiento
 * 
 */
export type Asesoramiento = $Result.DefaultSelection<Prisma.$AsesoramientoPayload>
/**
 * Model EncuestaSatisfaccion
 * 
 */
export type EncuestaSatisfaccion = $Result.DefaultSelection<Prisma.$EncuestaSatisfaccionPayload>
/**
 * Model MetricaMensual
 * 
 */
export type MetricaMensual = $Result.DefaultSelection<Prisma.$MetricaMensualPayload>
/**
 * Model Notificacion
 * 
 */
export type Notificacion = $Result.DefaultSelection<Prisma.$NotificacionPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ConversationContext
 * 
 */
export type ConversationContext = $Result.DefaultSelection<Prisma.$ConversationContextPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  ADMIN_CONSULTORIO: 'ADMIN_CONSULTORIO',
  ESTUDIANTE: 'ESTUDIANTE',
  USUARIO: 'USUARIO'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const EstadoUsuario: {
  ACTIVO: 'ACTIVO',
  INACTIVO: 'INACTIVO',
  SUSPENDIDO: 'SUSPENDIDO'
};

export type EstadoUsuario = (typeof EstadoUsuario)[keyof typeof EstadoUsuario]


export const TipoIntentoLogin: {
  LOGIN: 'LOGIN',
  CAMBIO_PASSWORD: 'CAMBIO_PASSWORD'
};

export type TipoIntentoLogin = (typeof TipoIntentoLogin)[keyof typeof TipoIntentoLogin]


export const OrigenIntento: {
  API_WEB: 'API_WEB',
  API_MOVIL: 'API_MOVIL'
};

export type OrigenIntento = (typeof OrigenIntento)[keyof typeof OrigenIntento]


export const Modalidad: {
  PRESENCIAL: 'PRESENCIAL',
  VIRTUAL: 'VIRTUAL'
};

export type Modalidad = (typeof Modalidad)[keyof typeof Modalidad]


export const EstadoEstudiante: {
  ACTIVO: 'ACTIVO',
  INACTIVO: 'INACTIVO'
};

export type EstadoEstudiante = (typeof EstadoEstudiante)[keyof typeof EstadoEstudiante]


export const EstadoCita: {
  AGENDADA: 'AGENDADA',
  CANCELADA: 'CANCELADA',
  COMPLETIDA: 'COMPLETIDA'
};

export type EstadoCita = (typeof EstadoCita)[keyof typeof EstadoCita]


export const TipoAuditoria: {
  CREAR: 'CREAR',
  EDITAR: 'EDITAR',
  ELIMINAR: 'ELIMINAR',
  AGENDAR: 'AGENDAR',
  CANCELAR: 'CANCELAR',
  REPROGRAMAR: 'REPROGRAMAR',
  IMPORTAR: 'IMPORTAR',
  EXPORTAR: 'EXPORTAR',
  REPORTAR: 'REPORTAR',
  LOGIN_EXITO: 'LOGIN_EXITO',
  LOGIN_FALLO: 'LOGIN_FALLO',
  CAMBIO_PASSWORD: 'CAMBIO_PASSWORD'
};

export type TipoAuditoria = (typeof TipoAuditoria)[keyof typeof TipoAuditoria]


export const Channel: {
  WHATSAPP: 'WHATSAPP',
  WEBCHAT: 'WEBCHAT'
};

export type Channel = (typeof Channel)[keyof typeof Channel]


export const ConversationStatus: {
  OPEN: 'OPEN',
  WAITING_INPUT: 'WAITING_INPUT',
  HANDOFF: 'HANDOFF',
  CLOSED: 'CLOSED'
};

export type ConversationStatus = (typeof ConversationStatus)[keyof typeof ConversationStatus]


export const Direction: {
  IN: 'IN',
  OUT: 'OUT'
};

export type Direction = (typeof Direction)[keyof typeof Direction]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  AUDIO: 'AUDIO',
  DOCUMENT: 'DOCUMENT',
  INTERACTIVE: 'INTERACTIVE',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type EstadoUsuario = $Enums.EstadoUsuario

export const EstadoUsuario: typeof $Enums.EstadoUsuario

export type TipoIntentoLogin = $Enums.TipoIntentoLogin

export const TipoIntentoLogin: typeof $Enums.TipoIntentoLogin

export type OrigenIntento = $Enums.OrigenIntento

export const OrigenIntento: typeof $Enums.OrigenIntento

export type Modalidad = $Enums.Modalidad

export const Modalidad: typeof $Enums.Modalidad

export type EstadoEstudiante = $Enums.EstadoEstudiante

export const EstadoEstudiante: typeof $Enums.EstadoEstudiante

export type EstadoCita = $Enums.EstadoCita

export const EstadoCita: typeof $Enums.EstadoCita

export type TipoAuditoria = $Enums.TipoAuditoria

export const TipoAuditoria: typeof $Enums.TipoAuditoria

export type Channel = $Enums.Channel

export const Channel: typeof $Enums.Channel

export type ConversationStatus = $Enums.ConversationStatus

export const ConversationStatus: typeof $Enums.ConversationStatus

export type Direction = $Enums.Direction

export const Direction: typeof $Enums.Direction

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intentoLogin`: Exposes CRUD operations for the **IntentoLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntentoLogins
    * const intentoLogins = await prisma.intentoLogin.findMany()
    * ```
    */
  get intentoLogin(): Prisma.IntentoLoginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sesion`: Exposes CRUD operations for the **Sesion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sesions
    * const sesions = await prisma.sesion.findMany()
    * ```
    */
  get sesion(): Prisma.SesionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estudiante`: Exposes CRUD operations for the **Estudiante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudiantes
    * const estudiantes = await prisma.estudiante.findMany()
    * ```
    */
  get estudiante(): Prisma.EstudianteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cita`: Exposes CRUD operations for the **Cita** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Citas
    * const citas = await prisma.cita.findMany()
    * ```
    */
  get cita(): Prisma.CitaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditoria`: Exposes CRUD operations for the **Auditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditorias
    * const auditorias = await prisma.auditoria.findMany()
    * ```
    */
  get auditoria(): Prisma.AuditoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configuracionWhatsApp`: Exposes CRUD operations for the **ConfiguracionWhatsApp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfiguracionWhatsApps
    * const configuracionWhatsApps = await prisma.configuracionWhatsApp.findMany()
    * ```
    */
  get configuracionWhatsApp(): Prisma.ConfiguracionWhatsAppDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookLog`: Exposes CRUD operations for the **WebhookLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookLogs
    * const webhookLogs = await prisma.webhookLog.findMany()
    * ```
    */
  get webhookLog(): Prisma.WebhookLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plantillaMensaje`: Exposes CRUD operations for the **PlantillaMensaje** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlantillaMensajes
    * const plantillaMensajes = await prisma.plantillaMensaje.findMany()
    * ```
    */
  get plantillaMensaje(): Prisma.PlantillaMensajeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversacion`: Exposes CRUD operations for the **Conversacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversacions
    * const conversacions = await prisma.conversacion.findMany()
    * ```
    */
  get conversacion(): Prisma.ConversacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mensaje`: Exposes CRUD operations for the **Mensaje** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mensajes
    * const mensajes = await prisma.mensaje.findMany()
    * ```
    */
  get mensaje(): Prisma.MensajeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asesoramiento`: Exposes CRUD operations for the **Asesoramiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Asesoramientos
    * const asesoramientos = await prisma.asesoramiento.findMany()
    * ```
    */
  get asesoramiento(): Prisma.AsesoramientoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encuestaSatisfaccion`: Exposes CRUD operations for the **EncuestaSatisfaccion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncuestaSatisfaccions
    * const encuestaSatisfaccions = await prisma.encuestaSatisfaccion.findMany()
    * ```
    */
  get encuestaSatisfaccion(): Prisma.EncuestaSatisfaccionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metricaMensual`: Exposes CRUD operations for the **MetricaMensual** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetricaMensuals
    * const metricaMensuals = await prisma.metricaMensual.findMany()
    * ```
    */
  get metricaMensual(): Prisma.MetricaMensualDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificacion`: Exposes CRUD operations for the **Notificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacions
    * const notificacions = await prisma.notificacion.findMany()
    * ```
    */
  get notificacion(): Prisma.NotificacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationContext`: Exposes CRUD operations for the **ConversationContext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationContexts
    * const conversationContexts = await prisma.conversationContext.findMany()
    * ```
    */
  get conversationContext(): Prisma.ConversationContextDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    IntentoLogin: 'IntentoLogin',
    Sesion: 'Sesion',
    Estudiante: 'Estudiante',
    Cita: 'Cita',
    Auditoria: 'Auditoria',
    ConfiguracionWhatsApp: 'ConfiguracionWhatsApp',
    WebhookLog: 'WebhookLog',
    PlantillaMensaje: 'PlantillaMensaje',
    Conversacion: 'Conversacion',
    Mensaje: 'Mensaje',
    Asesoramiento: 'Asesoramiento',
    EncuestaSatisfaccion: 'EncuestaSatisfaccion',
    MetricaMensual: 'MetricaMensual',
    Notificacion: 'Notificacion',
    Contact: 'Contact',
    Conversation: 'Conversation',
    Message: 'Message',
    ConversationContext: 'ConversationContext'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "usuario" | "intentoLogin" | "sesion" | "estudiante" | "cita" | "auditoria" | "configuracionWhatsApp" | "webhookLog" | "plantillaMensaje" | "conversacion" | "mensaje" | "asesoramiento" | "encuestaSatisfaccion" | "metricaMensual" | "notificacion" | "contact" | "conversation" | "message" | "conversationContext"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      IntentoLogin: {
        payload: Prisma.$IntentoLoginPayload<ExtArgs>
        fields: Prisma.IntentoLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntentoLoginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntentoLoginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>
          }
          findFirst: {
            args: Prisma.IntentoLoginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntentoLoginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>
          }
          findMany: {
            args: Prisma.IntentoLoginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>[]
          }
          create: {
            args: Prisma.IntentoLoginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>
          }
          createMany: {
            args: Prisma.IntentoLoginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntentoLoginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>[]
          }
          delete: {
            args: Prisma.IntentoLoginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>
          }
          update: {
            args: Prisma.IntentoLoginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>
          }
          deleteMany: {
            args: Prisma.IntentoLoginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntentoLoginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntentoLoginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>[]
          }
          upsert: {
            args: Prisma.IntentoLoginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntentoLoginPayload>
          }
          aggregate: {
            args: Prisma.IntentoLoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntentoLogin>
          }
          groupBy: {
            args: Prisma.IntentoLoginGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntentoLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntentoLoginCountArgs<ExtArgs>
            result: $Utils.Optional<IntentoLoginCountAggregateOutputType> | number
          }
        }
      }
      Sesion: {
        payload: Prisma.$SesionPayload<ExtArgs>
        fields: Prisma.SesionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SesionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SesionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          findFirst: {
            args: Prisma.SesionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SesionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          findMany: {
            args: Prisma.SesionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>[]
          }
          create: {
            args: Prisma.SesionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          createMany: {
            args: Prisma.SesionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SesionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>[]
          }
          delete: {
            args: Prisma.SesionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          update: {
            args: Prisma.SesionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          deleteMany: {
            args: Prisma.SesionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SesionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SesionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>[]
          }
          upsert: {
            args: Prisma.SesionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          aggregate: {
            args: Prisma.SesionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSesion>
          }
          groupBy: {
            args: Prisma.SesionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SesionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SesionCountArgs<ExtArgs>
            result: $Utils.Optional<SesionCountAggregateOutputType> | number
          }
        }
      }
      Estudiante: {
        payload: Prisma.$EstudiantePayload<ExtArgs>
        fields: Prisma.EstudianteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstudianteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstudianteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          findFirst: {
            args: Prisma.EstudianteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstudianteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          findMany: {
            args: Prisma.EstudianteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          create: {
            args: Prisma.EstudianteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          createMany: {
            args: Prisma.EstudianteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EstudianteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          delete: {
            args: Prisma.EstudianteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          update: {
            args: Prisma.EstudianteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          deleteMany: {
            args: Prisma.EstudianteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstudianteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EstudianteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>[]
          }
          upsert: {
            args: Prisma.EstudianteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstudiantePayload>
          }
          aggregate: {
            args: Prisma.EstudianteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudiante>
          }
          groupBy: {
            args: Prisma.EstudianteGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudianteGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstudianteCountArgs<ExtArgs>
            result: $Utils.Optional<EstudianteCountAggregateOutputType> | number
          }
        }
      }
      Cita: {
        payload: Prisma.$CitaPayload<ExtArgs>
        fields: Prisma.CitaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CitaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CitaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>
          }
          findFirst: {
            args: Prisma.CitaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CitaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>
          }
          findMany: {
            args: Prisma.CitaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>[]
          }
          create: {
            args: Prisma.CitaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>
          }
          createMany: {
            args: Prisma.CitaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CitaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>[]
          }
          delete: {
            args: Prisma.CitaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>
          }
          update: {
            args: Prisma.CitaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>
          }
          deleteMany: {
            args: Prisma.CitaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CitaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CitaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>[]
          }
          upsert: {
            args: Prisma.CitaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CitaPayload>
          }
          aggregate: {
            args: Prisma.CitaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCita>
          }
          groupBy: {
            args: Prisma.CitaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CitaCountArgs<ExtArgs>
            result: $Utils.Optional<CitaCountAggregateOutputType> | number
          }
        }
      }
      Auditoria: {
        payload: Prisma.$AuditoriaPayload<ExtArgs>
        fields: Prisma.AuditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          findFirst: {
            args: Prisma.AuditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          findMany: {
            args: Prisma.AuditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>[]
          }
          create: {
            args: Prisma.AuditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          createMany: {
            args: Prisma.AuditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>[]
          }
          delete: {
            args: Prisma.AuditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          update: {
            args: Prisma.AuditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          deleteMany: {
            args: Prisma.AuditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>[]
          }
          upsert: {
            args: Prisma.AuditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditoriaPayload>
          }
          aggregate: {
            args: Prisma.AuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditoria>
          }
          groupBy: {
            args: Prisma.AuditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaCountAggregateOutputType> | number
          }
        }
      }
      ConfiguracionWhatsApp: {
        payload: Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>
        fields: Prisma.ConfiguracionWhatsAppFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfiguracionWhatsAppFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfiguracionWhatsAppFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>
          }
          findFirst: {
            args: Prisma.ConfiguracionWhatsAppFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfiguracionWhatsAppFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>
          }
          findMany: {
            args: Prisma.ConfiguracionWhatsAppFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>[]
          }
          create: {
            args: Prisma.ConfiguracionWhatsAppCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>
          }
          createMany: {
            args: Prisma.ConfiguracionWhatsAppCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfiguracionWhatsAppCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>[]
          }
          delete: {
            args: Prisma.ConfiguracionWhatsAppDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>
          }
          update: {
            args: Prisma.ConfiguracionWhatsAppUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>
          }
          deleteMany: {
            args: Prisma.ConfiguracionWhatsAppDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfiguracionWhatsAppUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfiguracionWhatsAppUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>[]
          }
          upsert: {
            args: Prisma.ConfiguracionWhatsAppUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionWhatsAppPayload>
          }
          aggregate: {
            args: Prisma.ConfiguracionWhatsAppAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguracionWhatsApp>
          }
          groupBy: {
            args: Prisma.ConfiguracionWhatsAppGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracionWhatsAppGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfiguracionWhatsAppCountArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracionWhatsAppCountAggregateOutputType> | number
          }
        }
      }
      WebhookLog: {
        payload: Prisma.$WebhookLogPayload<ExtArgs>
        fields: Prisma.WebhookLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findFirst: {
            args: Prisma.WebhookLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findMany: {
            args: Prisma.WebhookLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          create: {
            args: Prisma.WebhookLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          createMany: {
            args: Prisma.WebhookLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          delete: {
            args: Prisma.WebhookLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          update: {
            args: Prisma.WebhookLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          deleteMany: {
            args: Prisma.WebhookLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          upsert: {
            args: Prisma.WebhookLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          aggregate: {
            args: Prisma.WebhookLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookLog>
          }
          groupBy: {
            args: Prisma.WebhookLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookLogCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogCountAggregateOutputType> | number
          }
        }
      }
      PlantillaMensaje: {
        payload: Prisma.$PlantillaMensajePayload<ExtArgs>
        fields: Prisma.PlantillaMensajeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlantillaMensajeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlantillaMensajeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>
          }
          findFirst: {
            args: Prisma.PlantillaMensajeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlantillaMensajeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>
          }
          findMany: {
            args: Prisma.PlantillaMensajeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>[]
          }
          create: {
            args: Prisma.PlantillaMensajeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>
          }
          createMany: {
            args: Prisma.PlantillaMensajeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlantillaMensajeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>[]
          }
          delete: {
            args: Prisma.PlantillaMensajeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>
          }
          update: {
            args: Prisma.PlantillaMensajeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>
          }
          deleteMany: {
            args: Prisma.PlantillaMensajeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlantillaMensajeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlantillaMensajeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>[]
          }
          upsert: {
            args: Prisma.PlantillaMensajeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlantillaMensajePayload>
          }
          aggregate: {
            args: Prisma.PlantillaMensajeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlantillaMensaje>
          }
          groupBy: {
            args: Prisma.PlantillaMensajeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantillaMensajeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlantillaMensajeCountArgs<ExtArgs>
            result: $Utils.Optional<PlantillaMensajeCountAggregateOutputType> | number
          }
        }
      }
      Conversacion: {
        payload: Prisma.$ConversacionPayload<ExtArgs>
        fields: Prisma.ConversacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>
          }
          findFirst: {
            args: Prisma.ConversacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>
          }
          findMany: {
            args: Prisma.ConversacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>[]
          }
          create: {
            args: Prisma.ConversacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>
          }
          createMany: {
            args: Prisma.ConversacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>[]
          }
          delete: {
            args: Prisma.ConversacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>
          }
          update: {
            args: Prisma.ConversacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>
          }
          deleteMany: {
            args: Prisma.ConversacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>[]
          }
          upsert: {
            args: Prisma.ConversacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversacionPayload>
          }
          aggregate: {
            args: Prisma.ConversacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversacion>
          }
          groupBy: {
            args: Prisma.ConversacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversacionCountArgs<ExtArgs>
            result: $Utils.Optional<ConversacionCountAggregateOutputType> | number
          }
        }
      }
      Mensaje: {
        payload: Prisma.$MensajePayload<ExtArgs>
        fields: Prisma.MensajeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MensajeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MensajeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>
          }
          findFirst: {
            args: Prisma.MensajeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MensajeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>
          }
          findMany: {
            args: Prisma.MensajeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>[]
          }
          create: {
            args: Prisma.MensajeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>
          }
          createMany: {
            args: Prisma.MensajeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MensajeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>[]
          }
          delete: {
            args: Prisma.MensajeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>
          }
          update: {
            args: Prisma.MensajeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>
          }
          deleteMany: {
            args: Prisma.MensajeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MensajeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MensajeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>[]
          }
          upsert: {
            args: Prisma.MensajeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensajePayload>
          }
          aggregate: {
            args: Prisma.MensajeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMensaje>
          }
          groupBy: {
            args: Prisma.MensajeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MensajeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MensajeCountArgs<ExtArgs>
            result: $Utils.Optional<MensajeCountAggregateOutputType> | number
          }
        }
      }
      Asesoramiento: {
        payload: Prisma.$AsesoramientoPayload<ExtArgs>
        fields: Prisma.AsesoramientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AsesoramientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AsesoramientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>
          }
          findFirst: {
            args: Prisma.AsesoramientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AsesoramientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>
          }
          findMany: {
            args: Prisma.AsesoramientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>[]
          }
          create: {
            args: Prisma.AsesoramientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>
          }
          createMany: {
            args: Prisma.AsesoramientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AsesoramientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>[]
          }
          delete: {
            args: Prisma.AsesoramientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>
          }
          update: {
            args: Prisma.AsesoramientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>
          }
          deleteMany: {
            args: Prisma.AsesoramientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AsesoramientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AsesoramientoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>[]
          }
          upsert: {
            args: Prisma.AsesoramientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AsesoramientoPayload>
          }
          aggregate: {
            args: Prisma.AsesoramientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsesoramiento>
          }
          groupBy: {
            args: Prisma.AsesoramientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AsesoramientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AsesoramientoCountArgs<ExtArgs>
            result: $Utils.Optional<AsesoramientoCountAggregateOutputType> | number
          }
        }
      }
      EncuestaSatisfaccion: {
        payload: Prisma.$EncuestaSatisfaccionPayload<ExtArgs>
        fields: Prisma.EncuestaSatisfaccionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncuestaSatisfaccionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncuestaSatisfaccionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>
          }
          findFirst: {
            args: Prisma.EncuestaSatisfaccionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncuestaSatisfaccionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>
          }
          findMany: {
            args: Prisma.EncuestaSatisfaccionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>[]
          }
          create: {
            args: Prisma.EncuestaSatisfaccionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>
          }
          createMany: {
            args: Prisma.EncuestaSatisfaccionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncuestaSatisfaccionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>[]
          }
          delete: {
            args: Prisma.EncuestaSatisfaccionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>
          }
          update: {
            args: Prisma.EncuestaSatisfaccionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>
          }
          deleteMany: {
            args: Prisma.EncuestaSatisfaccionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncuestaSatisfaccionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncuestaSatisfaccionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>[]
          }
          upsert: {
            args: Prisma.EncuestaSatisfaccionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncuestaSatisfaccionPayload>
          }
          aggregate: {
            args: Prisma.EncuestaSatisfaccionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncuestaSatisfaccion>
          }
          groupBy: {
            args: Prisma.EncuestaSatisfaccionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncuestaSatisfaccionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncuestaSatisfaccionCountArgs<ExtArgs>
            result: $Utils.Optional<EncuestaSatisfaccionCountAggregateOutputType> | number
          }
        }
      }
      MetricaMensual: {
        payload: Prisma.$MetricaMensualPayload<ExtArgs>
        fields: Prisma.MetricaMensualFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetricaMensualFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetricaMensualFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>
          }
          findFirst: {
            args: Prisma.MetricaMensualFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetricaMensualFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>
          }
          findMany: {
            args: Prisma.MetricaMensualFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>[]
          }
          create: {
            args: Prisma.MetricaMensualCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>
          }
          createMany: {
            args: Prisma.MetricaMensualCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetricaMensualCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>[]
          }
          delete: {
            args: Prisma.MetricaMensualDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>
          }
          update: {
            args: Prisma.MetricaMensualUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>
          }
          deleteMany: {
            args: Prisma.MetricaMensualDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetricaMensualUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MetricaMensualUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>[]
          }
          upsert: {
            args: Prisma.MetricaMensualUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricaMensualPayload>
          }
          aggregate: {
            args: Prisma.MetricaMensualAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetricaMensual>
          }
          groupBy: {
            args: Prisma.MetricaMensualGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetricaMensualGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetricaMensualCountArgs<ExtArgs>
            result: $Utils.Optional<MetricaMensualCountAggregateOutputType> | number
          }
        }
      }
      Notificacion: {
        payload: Prisma.$NotificacionPayload<ExtArgs>
        fields: Prisma.NotificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findFirst: {
            args: Prisma.NotificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findMany: {
            args: Prisma.NotificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          create: {
            args: Prisma.NotificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          createMany: {
            args: Prisma.NotificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          delete: {
            args: Prisma.NotificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          update: {
            args: Prisma.NotificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          deleteMany: {
            args: Prisma.NotificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          upsert: {
            args: Prisma.NotificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          aggregate: {
            args: Prisma.NotificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificacion>
          }
          groupBy: {
            args: Prisma.NotificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ConversationContext: {
        payload: Prisma.$ConversationContextPayload<ExtArgs>
        fields: Prisma.ConversationContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationContextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationContextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>
          }
          findFirst: {
            args: Prisma.ConversationContextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationContextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>
          }
          findMany: {
            args: Prisma.ConversationContextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>[]
          }
          create: {
            args: Prisma.ConversationContextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>
          }
          createMany: {
            args: Prisma.ConversationContextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationContextCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>[]
          }
          delete: {
            args: Prisma.ConversationContextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>
          }
          update: {
            args: Prisma.ConversationContextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>
          }
          deleteMany: {
            args: Prisma.ConversationContextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationContextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationContextUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>[]
          }
          upsert: {
            args: Prisma.ConversationContextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationContextPayload>
          }
          aggregate: {
            args: Prisma.ConversationContextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationContext>
          }
          groupBy: {
            args: Prisma.ConversationContextGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationContextCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationContextCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    usuario?: UsuarioOmit
    intentoLogin?: IntentoLoginOmit
    sesion?: SesionOmit
    estudiante?: EstudianteOmit
    cita?: CitaOmit
    auditoria?: AuditoriaOmit
    configuracionWhatsApp?: ConfiguracionWhatsAppOmit
    webhookLog?: WebhookLogOmit
    plantillaMensaje?: PlantillaMensajeOmit
    conversacion?: ConversacionOmit
    mensaje?: MensajeOmit
    asesoramiento?: AsesoramientoOmit
    encuestaSatisfaccion?: EncuestaSatisfaccionOmit
    metricaMensual?: MetricaMensualOmit
    notificacion?: NotificacionOmit
    contact?: ContactOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    conversationContext?: ConversationContextOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    intentosLogin: number
    sesiones: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intentosLogin?: boolean | UsuarioCountOutputTypeCountIntentosLoginArgs
    sesiones?: boolean | UsuarioCountOutputTypeCountSesionesArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountIntentosLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentoLoginWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountSesionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SesionWhereInput
  }


  /**
   * Count Type EstudianteCountOutputType
   */

  export type EstudianteCountOutputType = {
    citas: number
    conversaciones: number
    encuestas: number
    asesoramiento: number
  }

  export type EstudianteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citas?: boolean | EstudianteCountOutputTypeCountCitasArgs
    conversaciones?: boolean | EstudianteCountOutputTypeCountConversacionesArgs
    encuestas?: boolean | EstudianteCountOutputTypeCountEncuestasArgs
    asesoramiento?: boolean | EstudianteCountOutputTypeCountAsesoramientoArgs
  }

  // Custom InputTypes
  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudianteCountOutputType
     */
    select?: EstudianteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitaWhereInput
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountConversacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversacionWhereInput
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountEncuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncuestaSatisfaccionWhereInput
  }

  /**
   * EstudianteCountOutputType without action
   */
  export type EstudianteCountOutputTypeCountAsesoramientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsesoramientoWhereInput
  }


  /**
   * Count Type ConversacionCountOutputType
   */

  export type ConversacionCountOutputType = {
    citas: number
    mensajes: number
  }

  export type ConversacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citas?: boolean | ConversacionCountOutputTypeCountCitasArgs
    mensajes?: boolean | ConversacionCountOutputTypeCountMensajesArgs
  }

  // Custom InputTypes
  /**
   * ConversacionCountOutputType without action
   */
  export type ConversacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversacionCountOutputType
     */
    select?: ConversacionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversacionCountOutputType without action
   */
  export type ConversacionCountOutputTypeCountCitasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitaWhereInput
  }

  /**
   * ConversacionCountOutputType without action
   */
  export type ConversacionCountOutputTypeCountMensajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensajeWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    conversations: number
    messages: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | ContactCountOutputTypeCountConversationsArgs
    messages?: boolean | ContactCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    contexts: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contexts?: boolean | ConversationCountOutputTypeCountContextsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountContextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationContextWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    nombreCompleto: string | null
    correo: string | null
    telefono: string | null
    passwordHash: string | null
    primerIngreso: boolean | null
    rol: $Enums.Rol | null
    estado: $Enums.EstadoUsuario | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    nombreCompleto: string | null
    correo: string | null
    telefono: string | null
    passwordHash: string | null
    primerIngreso: boolean | null
    rol: $Enums.Rol | null
    estado: $Enums.EstadoUsuario | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombreCompleto: number
    correo: number
    telefono: number
    passwordHash: number
    primerIngreso: number
    rol: number
    estado: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type UsuarioMinAggregateInputType = {
    id?: true
    nombreCompleto?: true
    correo?: true
    telefono?: true
    passwordHash?: true
    primerIngreso?: true
    rol?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombreCompleto?: true
    correo?: true
    telefono?: true
    passwordHash?: true
    primerIngreso?: true
    rol?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombreCompleto?: true
    correo?: true
    telefono?: true
    passwordHash?: true
    primerIngreso?: true
    rol?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    nombreCompleto: string
    correo: string
    telefono: string | null
    passwordHash: string
    primerIngreso: boolean
    rol: $Enums.Rol
    estado: $Enums.EstadoUsuario
    creadoEn: Date
    actualizadoEn: Date
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreCompleto?: boolean
    correo?: boolean
    telefono?: boolean
    passwordHash?: boolean
    primerIngreso?: boolean
    rol?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    intentosLogin?: boolean | Usuario$intentosLoginArgs<ExtArgs>
    sesiones?: boolean | Usuario$sesionesArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreCompleto?: boolean
    correo?: boolean
    telefono?: boolean
    passwordHash?: boolean
    primerIngreso?: boolean
    rol?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreCompleto?: boolean
    correo?: boolean
    telefono?: boolean
    passwordHash?: boolean
    primerIngreso?: boolean
    rol?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombreCompleto?: boolean
    correo?: boolean
    telefono?: boolean
    passwordHash?: boolean
    primerIngreso?: boolean
    rol?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombreCompleto" | "correo" | "telefono" | "passwordHash" | "primerIngreso" | "rol" | "estado" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intentosLogin?: boolean | Usuario$intentosLoginArgs<ExtArgs>
    sesiones?: boolean | Usuario$sesionesArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      intentosLogin: Prisma.$IntentoLoginPayload<ExtArgs>[]
      sesiones: Prisma.$SesionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombreCompleto: string
      correo: string
      telefono: string | null
      passwordHash: string
      primerIngreso: boolean
      rol: $Enums.Rol
      estado: $Enums.EstadoUsuario
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    intentosLogin<T extends Usuario$intentosLoginArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$intentosLoginArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sesiones<T extends Usuario$sesionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$sesionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly nombreCompleto: FieldRef<"Usuario", 'String'>
    readonly correo: FieldRef<"Usuario", 'String'>
    readonly telefono: FieldRef<"Usuario", 'String'>
    readonly passwordHash: FieldRef<"Usuario", 'String'>
    readonly primerIngreso: FieldRef<"Usuario", 'Boolean'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly estado: FieldRef<"Usuario", 'EstadoUsuario'>
    readonly creadoEn: FieldRef<"Usuario", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.intentosLogin
   */
  export type Usuario$intentosLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    where?: IntentoLoginWhereInput
    orderBy?: IntentoLoginOrderByWithRelationInput | IntentoLoginOrderByWithRelationInput[]
    cursor?: IntentoLoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntentoLoginScalarFieldEnum | IntentoLoginScalarFieldEnum[]
  }

  /**
   * Usuario.sesiones
   */
  export type Usuario$sesionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    where?: SesionWhereInput
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    cursor?: SesionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model IntentoLogin
   */

  export type AggregateIntentoLogin = {
    _count: IntentoLoginCountAggregateOutputType | null
    _min: IntentoLoginMinAggregateOutputType | null
    _max: IntentoLoginMaxAggregateOutputType | null
  }

  export type IntentoLoginMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    correo: string | null
    tipo: $Enums.TipoIntentoLogin | null
    exitoso: boolean | null
    origen: $Enums.OrigenIntento | null
    ip: string | null
    userAgent: string | null
    motivoFallo: string | null
    creadoEn: Date | null
  }

  export type IntentoLoginMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    correo: string | null
    tipo: $Enums.TipoIntentoLogin | null
    exitoso: boolean | null
    origen: $Enums.OrigenIntento | null
    ip: string | null
    userAgent: string | null
    motivoFallo: string | null
    creadoEn: Date | null
  }

  export type IntentoLoginCountAggregateOutputType = {
    id: number
    usuarioId: number
    correo: number
    tipo: number
    exitoso: number
    origen: number
    ip: number
    userAgent: number
    motivoFallo: number
    creadoEn: number
    _all: number
  }


  export type IntentoLoginMinAggregateInputType = {
    id?: true
    usuarioId?: true
    correo?: true
    tipo?: true
    exitoso?: true
    origen?: true
    ip?: true
    userAgent?: true
    motivoFallo?: true
    creadoEn?: true
  }

  export type IntentoLoginMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    correo?: true
    tipo?: true
    exitoso?: true
    origen?: true
    ip?: true
    userAgent?: true
    motivoFallo?: true
    creadoEn?: true
  }

  export type IntentoLoginCountAggregateInputType = {
    id?: true
    usuarioId?: true
    correo?: true
    tipo?: true
    exitoso?: true
    origen?: true
    ip?: true
    userAgent?: true
    motivoFallo?: true
    creadoEn?: true
    _all?: true
  }

  export type IntentoLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentoLogin to aggregate.
     */
    where?: IntentoLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentoLogins to fetch.
     */
    orderBy?: IntentoLoginOrderByWithRelationInput | IntentoLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntentoLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentoLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentoLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntentoLogins
    **/
    _count?: true | IntentoLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntentoLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntentoLoginMaxAggregateInputType
  }

  export type GetIntentoLoginAggregateType<T extends IntentoLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateIntentoLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntentoLogin[P]>
      : GetScalarType<T[P], AggregateIntentoLogin[P]>
  }




  export type IntentoLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntentoLoginWhereInput
    orderBy?: IntentoLoginOrderByWithAggregationInput | IntentoLoginOrderByWithAggregationInput[]
    by: IntentoLoginScalarFieldEnum[] | IntentoLoginScalarFieldEnum
    having?: IntentoLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntentoLoginCountAggregateInputType | true
    _min?: IntentoLoginMinAggregateInputType
    _max?: IntentoLoginMaxAggregateInputType
  }

  export type IntentoLoginGroupByOutputType = {
    id: string
    usuarioId: string | null
    correo: string
    tipo: $Enums.TipoIntentoLogin
    exitoso: boolean
    origen: $Enums.OrigenIntento
    ip: string | null
    userAgent: string | null
    motivoFallo: string | null
    creadoEn: Date
    _count: IntentoLoginCountAggregateOutputType | null
    _min: IntentoLoginMinAggregateOutputType | null
    _max: IntentoLoginMaxAggregateOutputType | null
  }

  type GetIntentoLoginGroupByPayload<T extends IntentoLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntentoLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntentoLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntentoLoginGroupByOutputType[P]>
            : GetScalarType<T[P], IntentoLoginGroupByOutputType[P]>
        }
      >
    >


  export type IntentoLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    correo?: boolean
    tipo?: boolean
    exitoso?: boolean
    origen?: boolean
    ip?: boolean
    userAgent?: boolean
    motivoFallo?: boolean
    creadoEn?: boolean
    usuario?: boolean | IntentoLogin$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["intentoLogin"]>

  export type IntentoLoginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    correo?: boolean
    tipo?: boolean
    exitoso?: boolean
    origen?: boolean
    ip?: boolean
    userAgent?: boolean
    motivoFallo?: boolean
    creadoEn?: boolean
    usuario?: boolean | IntentoLogin$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["intentoLogin"]>

  export type IntentoLoginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    correo?: boolean
    tipo?: boolean
    exitoso?: boolean
    origen?: boolean
    ip?: boolean
    userAgent?: boolean
    motivoFallo?: boolean
    creadoEn?: boolean
    usuario?: boolean | IntentoLogin$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["intentoLogin"]>

  export type IntentoLoginSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    correo?: boolean
    tipo?: boolean
    exitoso?: boolean
    origen?: boolean
    ip?: boolean
    userAgent?: boolean
    motivoFallo?: boolean
    creadoEn?: boolean
  }

  export type IntentoLoginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "correo" | "tipo" | "exitoso" | "origen" | "ip" | "userAgent" | "motivoFallo" | "creadoEn", ExtArgs["result"]["intentoLogin"]>
  export type IntentoLoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | IntentoLogin$usuarioArgs<ExtArgs>
  }
  export type IntentoLoginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | IntentoLogin$usuarioArgs<ExtArgs>
  }
  export type IntentoLoginIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | IntentoLogin$usuarioArgs<ExtArgs>
  }

  export type $IntentoLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntentoLogin"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string | null
      correo: string
      tipo: $Enums.TipoIntentoLogin
      exitoso: boolean
      origen: $Enums.OrigenIntento
      ip: string | null
      userAgent: string | null
      motivoFallo: string | null
      creadoEn: Date
    }, ExtArgs["result"]["intentoLogin"]>
    composites: {}
  }

  type IntentoLoginGetPayload<S extends boolean | null | undefined | IntentoLoginDefaultArgs> = $Result.GetResult<Prisma.$IntentoLoginPayload, S>

  type IntentoLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntentoLoginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntentoLoginCountAggregateInputType | true
    }

  export interface IntentoLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntentoLogin'], meta: { name: 'IntentoLogin' } }
    /**
     * Find zero or one IntentoLogin that matches the filter.
     * @param {IntentoLoginFindUniqueArgs} args - Arguments to find a IntentoLogin
     * @example
     * // Get one IntentoLogin
     * const intentoLogin = await prisma.intentoLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntentoLoginFindUniqueArgs>(args: SelectSubset<T, IntentoLoginFindUniqueArgs<ExtArgs>>): Prisma__IntentoLoginClient<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IntentoLogin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntentoLoginFindUniqueOrThrowArgs} args - Arguments to find a IntentoLogin
     * @example
     * // Get one IntentoLogin
     * const intentoLogin = await prisma.intentoLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntentoLoginFindUniqueOrThrowArgs>(args: SelectSubset<T, IntentoLoginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntentoLoginClient<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntentoLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentoLoginFindFirstArgs} args - Arguments to find a IntentoLogin
     * @example
     * // Get one IntentoLogin
     * const intentoLogin = await prisma.intentoLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntentoLoginFindFirstArgs>(args?: SelectSubset<T, IntentoLoginFindFirstArgs<ExtArgs>>): Prisma__IntentoLoginClient<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntentoLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentoLoginFindFirstOrThrowArgs} args - Arguments to find a IntentoLogin
     * @example
     * // Get one IntentoLogin
     * const intentoLogin = await prisma.intentoLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntentoLoginFindFirstOrThrowArgs>(args?: SelectSubset<T, IntentoLoginFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntentoLoginClient<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IntentoLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentoLoginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntentoLogins
     * const intentoLogins = await prisma.intentoLogin.findMany()
     * 
     * // Get first 10 IntentoLogins
     * const intentoLogins = await prisma.intentoLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intentoLoginWithIdOnly = await prisma.intentoLogin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntentoLoginFindManyArgs>(args?: SelectSubset<T, IntentoLoginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IntentoLogin.
     * @param {IntentoLoginCreateArgs} args - Arguments to create a IntentoLogin.
     * @example
     * // Create one IntentoLogin
     * const IntentoLogin = await prisma.intentoLogin.create({
     *   data: {
     *     // ... data to create a IntentoLogin
     *   }
     * })
     * 
     */
    create<T extends IntentoLoginCreateArgs>(args: SelectSubset<T, IntentoLoginCreateArgs<ExtArgs>>): Prisma__IntentoLoginClient<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IntentoLogins.
     * @param {IntentoLoginCreateManyArgs} args - Arguments to create many IntentoLogins.
     * @example
     * // Create many IntentoLogins
     * const intentoLogin = await prisma.intentoLogin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntentoLoginCreateManyArgs>(args?: SelectSubset<T, IntentoLoginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntentoLogins and returns the data saved in the database.
     * @param {IntentoLoginCreateManyAndReturnArgs} args - Arguments to create many IntentoLogins.
     * @example
     * // Create many IntentoLogins
     * const intentoLogin = await prisma.intentoLogin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntentoLogins and only return the `id`
     * const intentoLoginWithIdOnly = await prisma.intentoLogin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntentoLoginCreateManyAndReturnArgs>(args?: SelectSubset<T, IntentoLoginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IntentoLogin.
     * @param {IntentoLoginDeleteArgs} args - Arguments to delete one IntentoLogin.
     * @example
     * // Delete one IntentoLogin
     * const IntentoLogin = await prisma.intentoLogin.delete({
     *   where: {
     *     // ... filter to delete one IntentoLogin
     *   }
     * })
     * 
     */
    delete<T extends IntentoLoginDeleteArgs>(args: SelectSubset<T, IntentoLoginDeleteArgs<ExtArgs>>): Prisma__IntentoLoginClient<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IntentoLogin.
     * @param {IntentoLoginUpdateArgs} args - Arguments to update one IntentoLogin.
     * @example
     * // Update one IntentoLogin
     * const intentoLogin = await prisma.intentoLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntentoLoginUpdateArgs>(args: SelectSubset<T, IntentoLoginUpdateArgs<ExtArgs>>): Prisma__IntentoLoginClient<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IntentoLogins.
     * @param {IntentoLoginDeleteManyArgs} args - Arguments to filter IntentoLogins to delete.
     * @example
     * // Delete a few IntentoLogins
     * const { count } = await prisma.intentoLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntentoLoginDeleteManyArgs>(args?: SelectSubset<T, IntentoLoginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntentoLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentoLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntentoLogins
     * const intentoLogin = await prisma.intentoLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntentoLoginUpdateManyArgs>(args: SelectSubset<T, IntentoLoginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntentoLogins and returns the data updated in the database.
     * @param {IntentoLoginUpdateManyAndReturnArgs} args - Arguments to update many IntentoLogins.
     * @example
     * // Update many IntentoLogins
     * const intentoLogin = await prisma.intentoLogin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IntentoLogins and only return the `id`
     * const intentoLoginWithIdOnly = await prisma.intentoLogin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntentoLoginUpdateManyAndReturnArgs>(args: SelectSubset<T, IntentoLoginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IntentoLogin.
     * @param {IntentoLoginUpsertArgs} args - Arguments to update or create a IntentoLogin.
     * @example
     * // Update or create a IntentoLogin
     * const intentoLogin = await prisma.intentoLogin.upsert({
     *   create: {
     *     // ... data to create a IntentoLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntentoLogin we want to update
     *   }
     * })
     */
    upsert<T extends IntentoLoginUpsertArgs>(args: SelectSubset<T, IntentoLoginUpsertArgs<ExtArgs>>): Prisma__IntentoLoginClient<$Result.GetResult<Prisma.$IntentoLoginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IntentoLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentoLoginCountArgs} args - Arguments to filter IntentoLogins to count.
     * @example
     * // Count the number of IntentoLogins
     * const count = await prisma.intentoLogin.count({
     *   where: {
     *     // ... the filter for the IntentoLogins we want to count
     *   }
     * })
    **/
    count<T extends IntentoLoginCountArgs>(
      args?: Subset<T, IntentoLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntentoLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntentoLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentoLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntentoLoginAggregateArgs>(args: Subset<T, IntentoLoginAggregateArgs>): Prisma.PrismaPromise<GetIntentoLoginAggregateType<T>>

    /**
     * Group by IntentoLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentoLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntentoLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntentoLoginGroupByArgs['orderBy'] }
        : { orderBy?: IntentoLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntentoLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntentoLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntentoLogin model
   */
  readonly fields: IntentoLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntentoLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntentoLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends IntentoLogin$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, IntentoLogin$usuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntentoLogin model
   */
  interface IntentoLoginFieldRefs {
    readonly id: FieldRef<"IntentoLogin", 'String'>
    readonly usuarioId: FieldRef<"IntentoLogin", 'String'>
    readonly correo: FieldRef<"IntentoLogin", 'String'>
    readonly tipo: FieldRef<"IntentoLogin", 'TipoIntentoLogin'>
    readonly exitoso: FieldRef<"IntentoLogin", 'Boolean'>
    readonly origen: FieldRef<"IntentoLogin", 'OrigenIntento'>
    readonly ip: FieldRef<"IntentoLogin", 'String'>
    readonly userAgent: FieldRef<"IntentoLogin", 'String'>
    readonly motivoFallo: FieldRef<"IntentoLogin", 'String'>
    readonly creadoEn: FieldRef<"IntentoLogin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntentoLogin findUnique
   */
  export type IntentoLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * Filter, which IntentoLogin to fetch.
     */
    where: IntentoLoginWhereUniqueInput
  }

  /**
   * IntentoLogin findUniqueOrThrow
   */
  export type IntentoLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * Filter, which IntentoLogin to fetch.
     */
    where: IntentoLoginWhereUniqueInput
  }

  /**
   * IntentoLogin findFirst
   */
  export type IntentoLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * Filter, which IntentoLogin to fetch.
     */
    where?: IntentoLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentoLogins to fetch.
     */
    orderBy?: IntentoLoginOrderByWithRelationInput | IntentoLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentoLogins.
     */
    cursor?: IntentoLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentoLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentoLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentoLogins.
     */
    distinct?: IntentoLoginScalarFieldEnum | IntentoLoginScalarFieldEnum[]
  }

  /**
   * IntentoLogin findFirstOrThrow
   */
  export type IntentoLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * Filter, which IntentoLogin to fetch.
     */
    where?: IntentoLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentoLogins to fetch.
     */
    orderBy?: IntentoLoginOrderByWithRelationInput | IntentoLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntentoLogins.
     */
    cursor?: IntentoLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentoLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentoLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntentoLogins.
     */
    distinct?: IntentoLoginScalarFieldEnum | IntentoLoginScalarFieldEnum[]
  }

  /**
   * IntentoLogin findMany
   */
  export type IntentoLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * Filter, which IntentoLogins to fetch.
     */
    where?: IntentoLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntentoLogins to fetch.
     */
    orderBy?: IntentoLoginOrderByWithRelationInput | IntentoLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntentoLogins.
     */
    cursor?: IntentoLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntentoLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntentoLogins.
     */
    skip?: number
    distinct?: IntentoLoginScalarFieldEnum | IntentoLoginScalarFieldEnum[]
  }

  /**
   * IntentoLogin create
   */
  export type IntentoLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * The data needed to create a IntentoLogin.
     */
    data: XOR<IntentoLoginCreateInput, IntentoLoginUncheckedCreateInput>
  }

  /**
   * IntentoLogin createMany
   */
  export type IntentoLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntentoLogins.
     */
    data: IntentoLoginCreateManyInput | IntentoLoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntentoLogin createManyAndReturn
   */
  export type IntentoLoginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * The data used to create many IntentoLogins.
     */
    data: IntentoLoginCreateManyInput | IntentoLoginCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntentoLogin update
   */
  export type IntentoLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * The data needed to update a IntentoLogin.
     */
    data: XOR<IntentoLoginUpdateInput, IntentoLoginUncheckedUpdateInput>
    /**
     * Choose, which IntentoLogin to update.
     */
    where: IntentoLoginWhereUniqueInput
  }

  /**
   * IntentoLogin updateMany
   */
  export type IntentoLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntentoLogins.
     */
    data: XOR<IntentoLoginUpdateManyMutationInput, IntentoLoginUncheckedUpdateManyInput>
    /**
     * Filter which IntentoLogins to update
     */
    where?: IntentoLoginWhereInput
    /**
     * Limit how many IntentoLogins to update.
     */
    limit?: number
  }

  /**
   * IntentoLogin updateManyAndReturn
   */
  export type IntentoLoginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * The data used to update IntentoLogins.
     */
    data: XOR<IntentoLoginUpdateManyMutationInput, IntentoLoginUncheckedUpdateManyInput>
    /**
     * Filter which IntentoLogins to update
     */
    where?: IntentoLoginWhereInput
    /**
     * Limit how many IntentoLogins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntentoLogin upsert
   */
  export type IntentoLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * The filter to search for the IntentoLogin to update in case it exists.
     */
    where: IntentoLoginWhereUniqueInput
    /**
     * In case the IntentoLogin found by the `where` argument doesn't exist, create a new IntentoLogin with this data.
     */
    create: XOR<IntentoLoginCreateInput, IntentoLoginUncheckedCreateInput>
    /**
     * In case the IntentoLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntentoLoginUpdateInput, IntentoLoginUncheckedUpdateInput>
  }

  /**
   * IntentoLogin delete
   */
  export type IntentoLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
    /**
     * Filter which IntentoLogin to delete.
     */
    where: IntentoLoginWhereUniqueInput
  }

  /**
   * IntentoLogin deleteMany
   */
  export type IntentoLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntentoLogins to delete
     */
    where?: IntentoLoginWhereInput
    /**
     * Limit how many IntentoLogins to delete.
     */
    limit?: number
  }

  /**
   * IntentoLogin.usuario
   */
  export type IntentoLogin$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * IntentoLogin without action
   */
  export type IntentoLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentoLogin
     */
    select?: IntentoLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntentoLogin
     */
    omit?: IntentoLoginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntentoLoginInclude<ExtArgs> | null
  }


  /**
   * Model Sesion
   */

  export type AggregateSesion = {
    _count: SesionCountAggregateOutputType | null
    _min: SesionMinAggregateOutputType | null
    _max: SesionMaxAggregateOutputType | null
  }

  export type SesionMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    token: string | null
    ip: string | null
    userAgent: string | null
    expiresAt: Date | null
    ultimoAcceso: Date | null
    activa: boolean | null
    creadaEn: Date | null
  }

  export type SesionMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    token: string | null
    ip: string | null
    userAgent: string | null
    expiresAt: Date | null
    ultimoAcceso: Date | null
    activa: boolean | null
    creadaEn: Date | null
  }

  export type SesionCountAggregateOutputType = {
    id: number
    usuarioId: number
    token: number
    ip: number
    userAgent: number
    expiresAt: number
    ultimoAcceso: number
    activa: number
    creadaEn: number
    _all: number
  }


  export type SesionMinAggregateInputType = {
    id?: true
    usuarioId?: true
    token?: true
    ip?: true
    userAgent?: true
    expiresAt?: true
    ultimoAcceso?: true
    activa?: true
    creadaEn?: true
  }

  export type SesionMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    token?: true
    ip?: true
    userAgent?: true
    expiresAt?: true
    ultimoAcceso?: true
    activa?: true
    creadaEn?: true
  }

  export type SesionCountAggregateInputType = {
    id?: true
    usuarioId?: true
    token?: true
    ip?: true
    userAgent?: true
    expiresAt?: true
    ultimoAcceso?: true
    activa?: true
    creadaEn?: true
    _all?: true
  }

  export type SesionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sesion to aggregate.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sesions
    **/
    _count?: true | SesionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SesionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SesionMaxAggregateInputType
  }

  export type GetSesionAggregateType<T extends SesionAggregateArgs> = {
        [P in keyof T & keyof AggregateSesion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSesion[P]>
      : GetScalarType<T[P], AggregateSesion[P]>
  }




  export type SesionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SesionWhereInput
    orderBy?: SesionOrderByWithAggregationInput | SesionOrderByWithAggregationInput[]
    by: SesionScalarFieldEnum[] | SesionScalarFieldEnum
    having?: SesionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SesionCountAggregateInputType | true
    _min?: SesionMinAggregateInputType
    _max?: SesionMaxAggregateInputType
  }

  export type SesionGroupByOutputType = {
    id: string
    usuarioId: string
    token: string
    ip: string | null
    userAgent: string | null
    expiresAt: Date
    ultimoAcceso: Date
    activa: boolean
    creadaEn: Date
    _count: SesionCountAggregateOutputType | null
    _min: SesionMinAggregateOutputType | null
    _max: SesionMaxAggregateOutputType | null
  }

  type GetSesionGroupByPayload<T extends SesionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SesionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SesionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SesionGroupByOutputType[P]>
            : GetScalarType<T[P], SesionGroupByOutputType[P]>
        }
      >
    >


  export type SesionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    token?: boolean
    ip?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    ultimoAcceso?: boolean
    activa?: boolean
    creadaEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sesion"]>

  export type SesionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    token?: boolean
    ip?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    ultimoAcceso?: boolean
    activa?: boolean
    creadaEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sesion"]>

  export type SesionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    token?: boolean
    ip?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    ultimoAcceso?: boolean
    activa?: boolean
    creadaEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sesion"]>

  export type SesionSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    token?: boolean
    ip?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    ultimoAcceso?: boolean
    activa?: boolean
    creadaEn?: boolean
  }

  export type SesionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "token" | "ip" | "userAgent" | "expiresAt" | "ultimoAcceso" | "activa" | "creadaEn", ExtArgs["result"]["sesion"]>
  export type SesionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type SesionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type SesionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $SesionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sesion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      token: string
      ip: string | null
      userAgent: string | null
      expiresAt: Date
      ultimoAcceso: Date
      activa: boolean
      creadaEn: Date
    }, ExtArgs["result"]["sesion"]>
    composites: {}
  }

  type SesionGetPayload<S extends boolean | null | undefined | SesionDefaultArgs> = $Result.GetResult<Prisma.$SesionPayload, S>

  type SesionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SesionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SesionCountAggregateInputType | true
    }

  export interface SesionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sesion'], meta: { name: 'Sesion' } }
    /**
     * Find zero or one Sesion that matches the filter.
     * @param {SesionFindUniqueArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SesionFindUniqueArgs>(args: SelectSubset<T, SesionFindUniqueArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sesion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SesionFindUniqueOrThrowArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SesionFindUniqueOrThrowArgs>(args: SelectSubset<T, SesionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sesion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindFirstArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SesionFindFirstArgs>(args?: SelectSubset<T, SesionFindFirstArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sesion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindFirstOrThrowArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SesionFindFirstOrThrowArgs>(args?: SelectSubset<T, SesionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sesions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sesions
     * const sesions = await prisma.sesion.findMany()
     * 
     * // Get first 10 Sesions
     * const sesions = await prisma.sesion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sesionWithIdOnly = await prisma.sesion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SesionFindManyArgs>(args?: SelectSubset<T, SesionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sesion.
     * @param {SesionCreateArgs} args - Arguments to create a Sesion.
     * @example
     * // Create one Sesion
     * const Sesion = await prisma.sesion.create({
     *   data: {
     *     // ... data to create a Sesion
     *   }
     * })
     * 
     */
    create<T extends SesionCreateArgs>(args: SelectSubset<T, SesionCreateArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sesions.
     * @param {SesionCreateManyArgs} args - Arguments to create many Sesions.
     * @example
     * // Create many Sesions
     * const sesion = await prisma.sesion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SesionCreateManyArgs>(args?: SelectSubset<T, SesionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sesions and returns the data saved in the database.
     * @param {SesionCreateManyAndReturnArgs} args - Arguments to create many Sesions.
     * @example
     * // Create many Sesions
     * const sesion = await prisma.sesion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sesions and only return the `id`
     * const sesionWithIdOnly = await prisma.sesion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SesionCreateManyAndReturnArgs>(args?: SelectSubset<T, SesionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sesion.
     * @param {SesionDeleteArgs} args - Arguments to delete one Sesion.
     * @example
     * // Delete one Sesion
     * const Sesion = await prisma.sesion.delete({
     *   where: {
     *     // ... filter to delete one Sesion
     *   }
     * })
     * 
     */
    delete<T extends SesionDeleteArgs>(args: SelectSubset<T, SesionDeleteArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sesion.
     * @param {SesionUpdateArgs} args - Arguments to update one Sesion.
     * @example
     * // Update one Sesion
     * const sesion = await prisma.sesion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SesionUpdateArgs>(args: SelectSubset<T, SesionUpdateArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sesions.
     * @param {SesionDeleteManyArgs} args - Arguments to filter Sesions to delete.
     * @example
     * // Delete a few Sesions
     * const { count } = await prisma.sesion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SesionDeleteManyArgs>(args?: SelectSubset<T, SesionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sesions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sesions
     * const sesion = await prisma.sesion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SesionUpdateManyArgs>(args: SelectSubset<T, SesionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sesions and returns the data updated in the database.
     * @param {SesionUpdateManyAndReturnArgs} args - Arguments to update many Sesions.
     * @example
     * // Update many Sesions
     * const sesion = await prisma.sesion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sesions and only return the `id`
     * const sesionWithIdOnly = await prisma.sesion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SesionUpdateManyAndReturnArgs>(args: SelectSubset<T, SesionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sesion.
     * @param {SesionUpsertArgs} args - Arguments to update or create a Sesion.
     * @example
     * // Update or create a Sesion
     * const sesion = await prisma.sesion.upsert({
     *   create: {
     *     // ... data to create a Sesion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sesion we want to update
     *   }
     * })
     */
    upsert<T extends SesionUpsertArgs>(args: SelectSubset<T, SesionUpsertArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sesions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionCountArgs} args - Arguments to filter Sesions to count.
     * @example
     * // Count the number of Sesions
     * const count = await prisma.sesion.count({
     *   where: {
     *     // ... the filter for the Sesions we want to count
     *   }
     * })
    **/
    count<T extends SesionCountArgs>(
      args?: Subset<T, SesionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SesionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sesion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SesionAggregateArgs>(args: Subset<T, SesionAggregateArgs>): Prisma.PrismaPromise<GetSesionAggregateType<T>>

    /**
     * Group by Sesion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SesionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SesionGroupByArgs['orderBy'] }
        : { orderBy?: SesionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SesionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSesionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sesion model
   */
  readonly fields: SesionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sesion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SesionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sesion model
   */
  interface SesionFieldRefs {
    readonly id: FieldRef<"Sesion", 'String'>
    readonly usuarioId: FieldRef<"Sesion", 'String'>
    readonly token: FieldRef<"Sesion", 'String'>
    readonly ip: FieldRef<"Sesion", 'String'>
    readonly userAgent: FieldRef<"Sesion", 'String'>
    readonly expiresAt: FieldRef<"Sesion", 'DateTime'>
    readonly ultimoAcceso: FieldRef<"Sesion", 'DateTime'>
    readonly activa: FieldRef<"Sesion", 'Boolean'>
    readonly creadaEn: FieldRef<"Sesion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sesion findUnique
   */
  export type SesionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where: SesionWhereUniqueInput
  }

  /**
   * Sesion findUniqueOrThrow
   */
  export type SesionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where: SesionWhereUniqueInput
  }

  /**
   * Sesion findFirst
   */
  export type SesionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sesions.
     */
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }

  /**
   * Sesion findFirstOrThrow
   */
  export type SesionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sesions.
     */
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }

  /**
   * Sesion findMany
   */
  export type SesionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesions to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }

  /**
   * Sesion create
   */
  export type SesionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * The data needed to create a Sesion.
     */
    data: XOR<SesionCreateInput, SesionUncheckedCreateInput>
  }

  /**
   * Sesion createMany
   */
  export type SesionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sesions.
     */
    data: SesionCreateManyInput | SesionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sesion createManyAndReturn
   */
  export type SesionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * The data used to create many Sesions.
     */
    data: SesionCreateManyInput | SesionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sesion update
   */
  export type SesionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * The data needed to update a Sesion.
     */
    data: XOR<SesionUpdateInput, SesionUncheckedUpdateInput>
    /**
     * Choose, which Sesion to update.
     */
    where: SesionWhereUniqueInput
  }

  /**
   * Sesion updateMany
   */
  export type SesionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sesions.
     */
    data: XOR<SesionUpdateManyMutationInput, SesionUncheckedUpdateManyInput>
    /**
     * Filter which Sesions to update
     */
    where?: SesionWhereInput
    /**
     * Limit how many Sesions to update.
     */
    limit?: number
  }

  /**
   * Sesion updateManyAndReturn
   */
  export type SesionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * The data used to update Sesions.
     */
    data: XOR<SesionUpdateManyMutationInput, SesionUncheckedUpdateManyInput>
    /**
     * Filter which Sesions to update
     */
    where?: SesionWhereInput
    /**
     * Limit how many Sesions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sesion upsert
   */
  export type SesionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * The filter to search for the Sesion to update in case it exists.
     */
    where: SesionWhereUniqueInput
    /**
     * In case the Sesion found by the `where` argument doesn't exist, create a new Sesion with this data.
     */
    create: XOR<SesionCreateInput, SesionUncheckedCreateInput>
    /**
     * In case the Sesion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SesionUpdateInput, SesionUncheckedUpdateInput>
  }

  /**
   * Sesion delete
   */
  export type SesionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter which Sesion to delete.
     */
    where: SesionWhereUniqueInput
  }

  /**
   * Sesion deleteMany
   */
  export type SesionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sesions to delete
     */
    where?: SesionWhereInput
    /**
     * Limit how many Sesions to delete.
     */
    limit?: number
  }

  /**
   * Sesion without action
   */
  export type SesionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sesion
     */
    omit?: SesionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
  }


  /**
   * Model Estudiante
   */

  export type AggregateEstudiante = {
    _count: EstudianteCountAggregateOutputType | null
    _avg: EstudianteAvgAggregateOutputType | null
    _sum: EstudianteSumAggregateOutputType | null
    _min: EstudianteMinAggregateOutputType | null
    _max: EstudianteMaxAggregateOutputType | null
  }

  export type EstudianteAvgAggregateOutputType = {
    semestre: number | null
  }

  export type EstudianteSumAggregateOutputType = {
    semestre: number | null
  }

  export type EstudianteMinAggregateOutputType = {
    id: string | null
    documento: string | null
    nombre: string | null
    correo: string | null
    telefono: string | null
    programa: string | null
    semestre: number | null
    modalidad: $Enums.Modalidad | null
    estado: $Enums.EstadoEstudiante | null
    estadoCuenta: string | null
    accesoCitas: boolean | null
    acudimientos: boolean | null
    fechaInicio: Date | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type EstudianteMaxAggregateOutputType = {
    id: string | null
    documento: string | null
    nombre: string | null
    correo: string | null
    telefono: string | null
    programa: string | null
    semestre: number | null
    modalidad: $Enums.Modalidad | null
    estado: $Enums.EstadoEstudiante | null
    estadoCuenta: string | null
    accesoCitas: boolean | null
    acudimientos: boolean | null
    fechaInicio: Date | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type EstudianteCountAggregateOutputType = {
    id: number
    documento: number
    nombre: number
    correo: number
    telefono: number
    programa: number
    semestre: number
    modalidad: number
    estado: number
    estadoCuenta: number
    accesoCitas: number
    acudimientos: number
    fechaInicio: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type EstudianteAvgAggregateInputType = {
    semestre?: true
  }

  export type EstudianteSumAggregateInputType = {
    semestre?: true
  }

  export type EstudianteMinAggregateInputType = {
    id?: true
    documento?: true
    nombre?: true
    correo?: true
    telefono?: true
    programa?: true
    semestre?: true
    modalidad?: true
    estado?: true
    estadoCuenta?: true
    accesoCitas?: true
    acudimientos?: true
    fechaInicio?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type EstudianteMaxAggregateInputType = {
    id?: true
    documento?: true
    nombre?: true
    correo?: true
    telefono?: true
    programa?: true
    semestre?: true
    modalidad?: true
    estado?: true
    estadoCuenta?: true
    accesoCitas?: true
    acudimientos?: true
    fechaInicio?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type EstudianteCountAggregateInputType = {
    id?: true
    documento?: true
    nombre?: true
    correo?: true
    telefono?: true
    programa?: true
    semestre?: true
    modalidad?: true
    estado?: true
    estadoCuenta?: true
    accesoCitas?: true
    acudimientos?: true
    fechaInicio?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type EstudianteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudiante to aggregate.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estudiantes
    **/
    _count?: true | EstudianteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudianteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudianteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudianteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudianteMaxAggregateInputType
  }

  export type GetEstudianteAggregateType<T extends EstudianteAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiante[P]>
      : GetScalarType<T[P], AggregateEstudiante[P]>
  }




  export type EstudianteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstudianteWhereInput
    orderBy?: EstudianteOrderByWithAggregationInput | EstudianteOrderByWithAggregationInput[]
    by: EstudianteScalarFieldEnum[] | EstudianteScalarFieldEnum
    having?: EstudianteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudianteCountAggregateInputType | true
    _avg?: EstudianteAvgAggregateInputType
    _sum?: EstudianteSumAggregateInputType
    _min?: EstudianteMinAggregateInputType
    _max?: EstudianteMaxAggregateInputType
  }

  export type EstudianteGroupByOutputType = {
    id: string
    documento: string
    nombre: string
    correo: string | null
    telefono: string | null
    programa: string | null
    semestre: number | null
    modalidad: $Enums.Modalidad
    estado: $Enums.EstadoEstudiante
    estadoCuenta: string
    accesoCitas: boolean
    acudimientos: boolean
    fechaInicio: Date | null
    creadoEn: Date
    actualizadoEn: Date
    _count: EstudianteCountAggregateOutputType | null
    _avg: EstudianteAvgAggregateOutputType | null
    _sum: EstudianteSumAggregateOutputType | null
    _min: EstudianteMinAggregateOutputType | null
    _max: EstudianteMaxAggregateOutputType | null
  }

  type GetEstudianteGroupByPayload<T extends EstudianteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudianteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudianteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudianteGroupByOutputType[P]>
            : GetScalarType<T[P], EstudianteGroupByOutputType[P]>
        }
      >
    >


  export type EstudianteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documento?: boolean
    nombre?: boolean
    correo?: boolean
    telefono?: boolean
    programa?: boolean
    semestre?: boolean
    modalidad?: boolean
    estado?: boolean
    estadoCuenta?: boolean
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    citas?: boolean | Estudiante$citasArgs<ExtArgs>
    conversaciones?: boolean | Estudiante$conversacionesArgs<ExtArgs>
    encuestas?: boolean | Estudiante$encuestasArgs<ExtArgs>
    asesoramiento?: boolean | Estudiante$asesoramientoArgs<ExtArgs>
    _count?: boolean | EstudianteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documento?: boolean
    nombre?: boolean
    correo?: boolean
    telefono?: boolean
    programa?: boolean
    semestre?: boolean
    modalidad?: boolean
    estado?: boolean
    estadoCuenta?: boolean
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documento?: boolean
    nombre?: boolean
    correo?: boolean
    telefono?: boolean
    programa?: boolean
    semestre?: boolean
    modalidad?: boolean
    estado?: boolean
    estadoCuenta?: boolean
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["estudiante"]>

  export type EstudianteSelectScalar = {
    id?: boolean
    documento?: boolean
    nombre?: boolean
    correo?: boolean
    telefono?: boolean
    programa?: boolean
    semestre?: boolean
    modalidad?: boolean
    estado?: boolean
    estadoCuenta?: boolean
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type EstudianteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documento" | "nombre" | "correo" | "telefono" | "programa" | "semestre" | "modalidad" | "estado" | "estadoCuenta" | "accesoCitas" | "acudimientos" | "fechaInicio" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["estudiante"]>
  export type EstudianteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    citas?: boolean | Estudiante$citasArgs<ExtArgs>
    conversaciones?: boolean | Estudiante$conversacionesArgs<ExtArgs>
    encuestas?: boolean | Estudiante$encuestasArgs<ExtArgs>
    asesoramiento?: boolean | Estudiante$asesoramientoArgs<ExtArgs>
    _count?: boolean | EstudianteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EstudianteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EstudianteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EstudiantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estudiante"
    objects: {
      citas: Prisma.$CitaPayload<ExtArgs>[]
      conversaciones: Prisma.$ConversacionPayload<ExtArgs>[]
      encuestas: Prisma.$EncuestaSatisfaccionPayload<ExtArgs>[]
      asesoramiento: Prisma.$AsesoramientoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documento: string
      nombre: string
      correo: string | null
      telefono: string | null
      programa: string | null
      semestre: number | null
      modalidad: $Enums.Modalidad
      estado: $Enums.EstadoEstudiante
      estadoCuenta: string
      accesoCitas: boolean
      acudimientos: boolean
      fechaInicio: Date | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["estudiante"]>
    composites: {}
  }

  type EstudianteGetPayload<S extends boolean | null | undefined | EstudianteDefaultArgs> = $Result.GetResult<Prisma.$EstudiantePayload, S>

  type EstudianteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EstudianteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstudianteCountAggregateInputType | true
    }

  export interface EstudianteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estudiante'], meta: { name: 'Estudiante' } }
    /**
     * Find zero or one Estudiante that matches the filter.
     * @param {EstudianteFindUniqueArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstudianteFindUniqueArgs>(args: SelectSubset<T, EstudianteFindUniqueArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estudiante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EstudianteFindUniqueOrThrowArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstudianteFindUniqueOrThrowArgs>(args: SelectSubset<T, EstudianteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindFirstArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstudianteFindFirstArgs>(args?: SelectSubset<T, EstudianteFindFirstArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindFirstOrThrowArgs} args - Arguments to find a Estudiante
     * @example
     * // Get one Estudiante
     * const estudiante = await prisma.estudiante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstudianteFindFirstOrThrowArgs>(args?: SelectSubset<T, EstudianteFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudiantes
     * const estudiantes = await prisma.estudiante.findMany()
     * 
     * // Get first 10 Estudiantes
     * const estudiantes = await prisma.estudiante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstudianteFindManyArgs>(args?: SelectSubset<T, EstudianteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estudiante.
     * @param {EstudianteCreateArgs} args - Arguments to create a Estudiante.
     * @example
     * // Create one Estudiante
     * const Estudiante = await prisma.estudiante.create({
     *   data: {
     *     // ... data to create a Estudiante
     *   }
     * })
     * 
     */
    create<T extends EstudianteCreateArgs>(args: SelectSubset<T, EstudianteCreateArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estudiantes.
     * @param {EstudianteCreateManyArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiante = await prisma.estudiante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstudianteCreateManyArgs>(args?: SelectSubset<T, EstudianteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estudiantes and returns the data saved in the database.
     * @param {EstudianteCreateManyAndReturnArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiante = await prisma.estudiante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estudiantes and only return the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EstudianteCreateManyAndReturnArgs>(args?: SelectSubset<T, EstudianteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estudiante.
     * @param {EstudianteDeleteArgs} args - Arguments to delete one Estudiante.
     * @example
     * // Delete one Estudiante
     * const Estudiante = await prisma.estudiante.delete({
     *   where: {
     *     // ... filter to delete one Estudiante
     *   }
     * })
     * 
     */
    delete<T extends EstudianteDeleteArgs>(args: SelectSubset<T, EstudianteDeleteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estudiante.
     * @param {EstudianteUpdateArgs} args - Arguments to update one Estudiante.
     * @example
     * // Update one Estudiante
     * const estudiante = await prisma.estudiante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstudianteUpdateArgs>(args: SelectSubset<T, EstudianteUpdateArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estudiantes.
     * @param {EstudianteDeleteManyArgs} args - Arguments to filter Estudiantes to delete.
     * @example
     * // Delete a few Estudiantes
     * const { count } = await prisma.estudiante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstudianteDeleteManyArgs>(args?: SelectSubset<T, EstudianteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudiantes
     * const estudiante = await prisma.estudiante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstudianteUpdateManyArgs>(args: SelectSubset<T, EstudianteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes and returns the data updated in the database.
     * @param {EstudianteUpdateManyAndReturnArgs} args - Arguments to update many Estudiantes.
     * @example
     * // Update many Estudiantes
     * const estudiante = await prisma.estudiante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estudiantes and only return the `id`
     * const estudianteWithIdOnly = await prisma.estudiante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EstudianteUpdateManyAndReturnArgs>(args: SelectSubset<T, EstudianteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estudiante.
     * @param {EstudianteUpsertArgs} args - Arguments to update or create a Estudiante.
     * @example
     * // Update or create a Estudiante
     * const estudiante = await prisma.estudiante.upsert({
     *   create: {
     *     // ... data to create a Estudiante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudiante we want to update
     *   }
     * })
     */
    upsert<T extends EstudianteUpsertArgs>(args: SelectSubset<T, EstudianteUpsertArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteCountArgs} args - Arguments to filter Estudiantes to count.
     * @example
     * // Count the number of Estudiantes
     * const count = await prisma.estudiante.count({
     *   where: {
     *     // ... the filter for the Estudiantes we want to count
     *   }
     * })
    **/
    count<T extends EstudianteCountArgs>(
      args?: Subset<T, EstudianteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudianteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudianteAggregateArgs>(args: Subset<T, EstudianteAggregateArgs>): Prisma.PrismaPromise<GetEstudianteAggregateType<T>>

    /**
     * Group by Estudiante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudianteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstudianteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstudianteGroupByArgs['orderBy'] }
        : { orderBy?: EstudianteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstudianteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudianteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estudiante model
   */
  readonly fields: EstudianteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estudiante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstudianteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    citas<T extends Estudiante$citasArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$citasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversaciones<T extends Estudiante$conversacionesArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$conversacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encuestas<T extends Estudiante$encuestasArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$encuestasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asesoramiento<T extends Estudiante$asesoramientoArgs<ExtArgs> = {}>(args?: Subset<T, Estudiante$asesoramientoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estudiante model
   */
  interface EstudianteFieldRefs {
    readonly id: FieldRef<"Estudiante", 'String'>
    readonly documento: FieldRef<"Estudiante", 'String'>
    readonly nombre: FieldRef<"Estudiante", 'String'>
    readonly correo: FieldRef<"Estudiante", 'String'>
    readonly telefono: FieldRef<"Estudiante", 'String'>
    readonly programa: FieldRef<"Estudiante", 'String'>
    readonly semestre: FieldRef<"Estudiante", 'Int'>
    readonly modalidad: FieldRef<"Estudiante", 'Modalidad'>
    readonly estado: FieldRef<"Estudiante", 'EstadoEstudiante'>
    readonly estadoCuenta: FieldRef<"Estudiante", 'String'>
    readonly accesoCitas: FieldRef<"Estudiante", 'Boolean'>
    readonly acudimientos: FieldRef<"Estudiante", 'Boolean'>
    readonly fechaInicio: FieldRef<"Estudiante", 'DateTime'>
    readonly creadoEn: FieldRef<"Estudiante", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Estudiante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Estudiante findUnique
   */
  export type EstudianteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante findUniqueOrThrow
   */
  export type EstudianteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante findFirst
   */
  export type EstudianteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudiantes.
     */
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante findFirstOrThrow
   */
  export type EstudianteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiante to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estudiantes.
     */
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante findMany
   */
  export type EstudianteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter, which Estudiantes to fetch.
     */
    where?: EstudianteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estudiantes to fetch.
     */
    orderBy?: EstudianteOrderByWithRelationInput | EstudianteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estudiantes.
     */
    cursor?: EstudianteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estudiantes.
     */
    skip?: number
    distinct?: EstudianteScalarFieldEnum | EstudianteScalarFieldEnum[]
  }

  /**
   * Estudiante create
   */
  export type EstudianteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The data needed to create a Estudiante.
     */
    data: XOR<EstudianteCreateInput, EstudianteUncheckedCreateInput>
  }

  /**
   * Estudiante createMany
   */
  export type EstudianteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estudiantes.
     */
    data: EstudianteCreateManyInput | EstudianteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estudiante createManyAndReturn
   */
  export type EstudianteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * The data used to create many Estudiantes.
     */
    data: EstudianteCreateManyInput | EstudianteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estudiante update
   */
  export type EstudianteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The data needed to update a Estudiante.
     */
    data: XOR<EstudianteUpdateInput, EstudianteUncheckedUpdateInput>
    /**
     * Choose, which Estudiante to update.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante updateMany
   */
  export type EstudianteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estudiantes.
     */
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyInput>
    /**
     * Filter which Estudiantes to update
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to update.
     */
    limit?: number
  }

  /**
   * Estudiante updateManyAndReturn
   */
  export type EstudianteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * The data used to update Estudiantes.
     */
    data: XOR<EstudianteUpdateManyMutationInput, EstudianteUncheckedUpdateManyInput>
    /**
     * Filter which Estudiantes to update
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to update.
     */
    limit?: number
  }

  /**
   * Estudiante upsert
   */
  export type EstudianteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * The filter to search for the Estudiante to update in case it exists.
     */
    where: EstudianteWhereUniqueInput
    /**
     * In case the Estudiante found by the `where` argument doesn't exist, create a new Estudiante with this data.
     */
    create: XOR<EstudianteCreateInput, EstudianteUncheckedCreateInput>
    /**
     * In case the Estudiante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstudianteUpdateInput, EstudianteUncheckedUpdateInput>
  }

  /**
   * Estudiante delete
   */
  export type EstudianteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    /**
     * Filter which Estudiante to delete.
     */
    where: EstudianteWhereUniqueInput
  }

  /**
   * Estudiante deleteMany
   */
  export type EstudianteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estudiantes to delete
     */
    where?: EstudianteWhereInput
    /**
     * Limit how many Estudiantes to delete.
     */
    limit?: number
  }

  /**
   * Estudiante.citas
   */
  export type Estudiante$citasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    where?: CitaWhereInput
    orderBy?: CitaOrderByWithRelationInput | CitaOrderByWithRelationInput[]
    cursor?: CitaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * Estudiante.conversaciones
   */
  export type Estudiante$conversacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    where?: ConversacionWhereInput
    orderBy?: ConversacionOrderByWithRelationInput | ConversacionOrderByWithRelationInput[]
    cursor?: ConversacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversacionScalarFieldEnum | ConversacionScalarFieldEnum[]
  }

  /**
   * Estudiante.encuestas
   */
  export type Estudiante$encuestasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    where?: EncuestaSatisfaccionWhereInput
    orderBy?: EncuestaSatisfaccionOrderByWithRelationInput | EncuestaSatisfaccionOrderByWithRelationInput[]
    cursor?: EncuestaSatisfaccionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncuestaSatisfaccionScalarFieldEnum | EncuestaSatisfaccionScalarFieldEnum[]
  }

  /**
   * Estudiante.asesoramiento
   */
  export type Estudiante$asesoramientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    where?: AsesoramientoWhereInput
    orderBy?: AsesoramientoOrderByWithRelationInput | AsesoramientoOrderByWithRelationInput[]
    cursor?: AsesoramientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AsesoramientoScalarFieldEnum | AsesoramientoScalarFieldEnum[]
  }

  /**
   * Estudiante without action
   */
  export type EstudianteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
  }


  /**
   * Model Cita
   */

  export type AggregateCita = {
    _count: CitaCountAggregateOutputType | null
    _min: CitaMinAggregateOutputType | null
    _max: CitaMaxAggregateOutputType | null
  }

  export type CitaMinAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    fecha: Date | null
    hora: string | null
    modalidad: $Enums.Modalidad | null
    motivo: string | null
    estado: $Enums.EstadoCita | null
    usuarioNombre: string | null
    usuarioTipoDocumento: string | null
    usuarioNumeroDocumento: string | null
    usuarioCorreo: string | null
    usuarioTelefono: string | null
    enlaceReunion: string | null
    conversacionId: string | null
    notifEnviada24h: boolean | null
    notifEnviada15m: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CitaMaxAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    fecha: Date | null
    hora: string | null
    modalidad: $Enums.Modalidad | null
    motivo: string | null
    estado: $Enums.EstadoCita | null
    usuarioNombre: string | null
    usuarioTipoDocumento: string | null
    usuarioNumeroDocumento: string | null
    usuarioCorreo: string | null
    usuarioTelefono: string | null
    enlaceReunion: string | null
    conversacionId: string | null
    notifEnviada24h: boolean | null
    notifEnviada15m: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CitaCountAggregateOutputType = {
    id: number
    estudianteId: number
    fecha: number
    hora: number
    modalidad: number
    motivo: number
    estado: number
    usuarioNombre: number
    usuarioTipoDocumento: number
    usuarioNumeroDocumento: number
    usuarioCorreo: number
    usuarioTelefono: number
    enlaceReunion: number
    conversacionId: number
    notifEnviada24h: number
    notifEnviada15m: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type CitaMinAggregateInputType = {
    id?: true
    estudianteId?: true
    fecha?: true
    hora?: true
    modalidad?: true
    motivo?: true
    estado?: true
    usuarioNombre?: true
    usuarioTipoDocumento?: true
    usuarioNumeroDocumento?: true
    usuarioCorreo?: true
    usuarioTelefono?: true
    enlaceReunion?: true
    conversacionId?: true
    notifEnviada24h?: true
    notifEnviada15m?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CitaMaxAggregateInputType = {
    id?: true
    estudianteId?: true
    fecha?: true
    hora?: true
    modalidad?: true
    motivo?: true
    estado?: true
    usuarioNombre?: true
    usuarioTipoDocumento?: true
    usuarioNumeroDocumento?: true
    usuarioCorreo?: true
    usuarioTelefono?: true
    enlaceReunion?: true
    conversacionId?: true
    notifEnviada24h?: true
    notifEnviada15m?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CitaCountAggregateInputType = {
    id?: true
    estudianteId?: true
    fecha?: true
    hora?: true
    modalidad?: true
    motivo?: true
    estado?: true
    usuarioNombre?: true
    usuarioTipoDocumento?: true
    usuarioNumeroDocumento?: true
    usuarioCorreo?: true
    usuarioTelefono?: true
    enlaceReunion?: true
    conversacionId?: true
    notifEnviada24h?: true
    notifEnviada15m?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type CitaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cita to aggregate.
     */
    where?: CitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citas to fetch.
     */
    orderBy?: CitaOrderByWithRelationInput | CitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Citas
    **/
    _count?: true | CitaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitaMaxAggregateInputType
  }

  export type GetCitaAggregateType<T extends CitaAggregateArgs> = {
        [P in keyof T & keyof AggregateCita]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCita[P]>
      : GetScalarType<T[P], AggregateCita[P]>
  }




  export type CitaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CitaWhereInput
    orderBy?: CitaOrderByWithAggregationInput | CitaOrderByWithAggregationInput[]
    by: CitaScalarFieldEnum[] | CitaScalarFieldEnum
    having?: CitaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitaCountAggregateInputType | true
    _min?: CitaMinAggregateInputType
    _max?: CitaMaxAggregateInputType
  }

  export type CitaGroupByOutputType = {
    id: string
    estudianteId: string
    fecha: Date
    hora: string
    modalidad: $Enums.Modalidad
    motivo: string | null
    estado: $Enums.EstadoCita
    usuarioNombre: string | null
    usuarioTipoDocumento: string | null
    usuarioNumeroDocumento: string | null
    usuarioCorreo: string | null
    usuarioTelefono: string | null
    enlaceReunion: string | null
    conversacionId: string | null
    notifEnviada24h: boolean
    notifEnviada15m: boolean
    creadoEn: Date
    actualizadoEn: Date
    _count: CitaCountAggregateOutputType | null
    _min: CitaMinAggregateOutputType | null
    _max: CitaMaxAggregateOutputType | null
  }

  type GetCitaGroupByPayload<T extends CitaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitaGroupByOutputType[P]>
            : GetScalarType<T[P], CitaGroupByOutputType[P]>
        }
      >
    >


  export type CitaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    fecha?: boolean
    hora?: boolean
    modalidad?: boolean
    motivo?: boolean
    estado?: boolean
    usuarioNombre?: boolean
    usuarioTipoDocumento?: boolean
    usuarioNumeroDocumento?: boolean
    usuarioCorreo?: boolean
    usuarioTelefono?: boolean
    enlaceReunion?: boolean
    conversacionId?: boolean
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    conversacion?: boolean | Cita$conversacionArgs<ExtArgs>
  }, ExtArgs["result"]["cita"]>

  export type CitaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    fecha?: boolean
    hora?: boolean
    modalidad?: boolean
    motivo?: boolean
    estado?: boolean
    usuarioNombre?: boolean
    usuarioTipoDocumento?: boolean
    usuarioNumeroDocumento?: boolean
    usuarioCorreo?: boolean
    usuarioTelefono?: boolean
    enlaceReunion?: boolean
    conversacionId?: boolean
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    conversacion?: boolean | Cita$conversacionArgs<ExtArgs>
  }, ExtArgs["result"]["cita"]>

  export type CitaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    fecha?: boolean
    hora?: boolean
    modalidad?: boolean
    motivo?: boolean
    estado?: boolean
    usuarioNombre?: boolean
    usuarioTipoDocumento?: boolean
    usuarioNumeroDocumento?: boolean
    usuarioCorreo?: boolean
    usuarioTelefono?: boolean
    enlaceReunion?: boolean
    conversacionId?: boolean
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    conversacion?: boolean | Cita$conversacionArgs<ExtArgs>
  }, ExtArgs["result"]["cita"]>

  export type CitaSelectScalar = {
    id?: boolean
    estudianteId?: boolean
    fecha?: boolean
    hora?: boolean
    modalidad?: boolean
    motivo?: boolean
    estado?: boolean
    usuarioNombre?: boolean
    usuarioTipoDocumento?: boolean
    usuarioNumeroDocumento?: boolean
    usuarioCorreo?: boolean
    usuarioTelefono?: boolean
    enlaceReunion?: boolean
    conversacionId?: boolean
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type CitaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estudianteId" | "fecha" | "hora" | "modalidad" | "motivo" | "estado" | "usuarioNombre" | "usuarioTipoDocumento" | "usuarioNumeroDocumento" | "usuarioCorreo" | "usuarioTelefono" | "enlaceReunion" | "conversacionId" | "notifEnviada24h" | "notifEnviada15m" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["cita"]>
  export type CitaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    conversacion?: boolean | Cita$conversacionArgs<ExtArgs>
  }
  export type CitaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    conversacion?: boolean | Cita$conversacionArgs<ExtArgs>
  }
  export type CitaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | EstudianteDefaultArgs<ExtArgs>
    conversacion?: boolean | Cita$conversacionArgs<ExtArgs>
  }

  export type $CitaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cita"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs>
      conversacion: Prisma.$ConversacionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      estudianteId: string
      fecha: Date
      hora: string
      modalidad: $Enums.Modalidad
      motivo: string | null
      estado: $Enums.EstadoCita
      usuarioNombre: string | null
      usuarioTipoDocumento: string | null
      usuarioNumeroDocumento: string | null
      usuarioCorreo: string | null
      usuarioTelefono: string | null
      enlaceReunion: string | null
      conversacionId: string | null
      notifEnviada24h: boolean
      notifEnviada15m: boolean
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["cita"]>
    composites: {}
  }

  type CitaGetPayload<S extends boolean | null | undefined | CitaDefaultArgs> = $Result.GetResult<Prisma.$CitaPayload, S>

  type CitaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CitaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CitaCountAggregateInputType | true
    }

  export interface CitaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cita'], meta: { name: 'Cita' } }
    /**
     * Find zero or one Cita that matches the filter.
     * @param {CitaFindUniqueArgs} args - Arguments to find a Cita
     * @example
     * // Get one Cita
     * const cita = await prisma.cita.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CitaFindUniqueArgs>(args: SelectSubset<T, CitaFindUniqueArgs<ExtArgs>>): Prisma__CitaClient<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cita that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CitaFindUniqueOrThrowArgs} args - Arguments to find a Cita
     * @example
     * // Get one Cita
     * const cita = await prisma.cita.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CitaFindUniqueOrThrowArgs>(args: SelectSubset<T, CitaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CitaClient<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cita that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitaFindFirstArgs} args - Arguments to find a Cita
     * @example
     * // Get one Cita
     * const cita = await prisma.cita.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CitaFindFirstArgs>(args?: SelectSubset<T, CitaFindFirstArgs<ExtArgs>>): Prisma__CitaClient<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cita that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitaFindFirstOrThrowArgs} args - Arguments to find a Cita
     * @example
     * // Get one Cita
     * const cita = await prisma.cita.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CitaFindFirstOrThrowArgs>(args?: SelectSubset<T, CitaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CitaClient<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Citas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Citas
     * const citas = await prisma.cita.findMany()
     * 
     * // Get first 10 Citas
     * const citas = await prisma.cita.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const citaWithIdOnly = await prisma.cita.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CitaFindManyArgs>(args?: SelectSubset<T, CitaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cita.
     * @param {CitaCreateArgs} args - Arguments to create a Cita.
     * @example
     * // Create one Cita
     * const Cita = await prisma.cita.create({
     *   data: {
     *     // ... data to create a Cita
     *   }
     * })
     * 
     */
    create<T extends CitaCreateArgs>(args: SelectSubset<T, CitaCreateArgs<ExtArgs>>): Prisma__CitaClient<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Citas.
     * @param {CitaCreateManyArgs} args - Arguments to create many Citas.
     * @example
     * // Create many Citas
     * const cita = await prisma.cita.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CitaCreateManyArgs>(args?: SelectSubset<T, CitaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Citas and returns the data saved in the database.
     * @param {CitaCreateManyAndReturnArgs} args - Arguments to create many Citas.
     * @example
     * // Create many Citas
     * const cita = await prisma.cita.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Citas and only return the `id`
     * const citaWithIdOnly = await prisma.cita.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CitaCreateManyAndReturnArgs>(args?: SelectSubset<T, CitaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cita.
     * @param {CitaDeleteArgs} args - Arguments to delete one Cita.
     * @example
     * // Delete one Cita
     * const Cita = await prisma.cita.delete({
     *   where: {
     *     // ... filter to delete one Cita
     *   }
     * })
     * 
     */
    delete<T extends CitaDeleteArgs>(args: SelectSubset<T, CitaDeleteArgs<ExtArgs>>): Prisma__CitaClient<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cita.
     * @param {CitaUpdateArgs} args - Arguments to update one Cita.
     * @example
     * // Update one Cita
     * const cita = await prisma.cita.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CitaUpdateArgs>(args: SelectSubset<T, CitaUpdateArgs<ExtArgs>>): Prisma__CitaClient<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Citas.
     * @param {CitaDeleteManyArgs} args - Arguments to filter Citas to delete.
     * @example
     * // Delete a few Citas
     * const { count } = await prisma.cita.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CitaDeleteManyArgs>(args?: SelectSubset<T, CitaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Citas
     * const cita = await prisma.cita.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CitaUpdateManyArgs>(args: SelectSubset<T, CitaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Citas and returns the data updated in the database.
     * @param {CitaUpdateManyAndReturnArgs} args - Arguments to update many Citas.
     * @example
     * // Update many Citas
     * const cita = await prisma.cita.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Citas and only return the `id`
     * const citaWithIdOnly = await prisma.cita.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CitaUpdateManyAndReturnArgs>(args: SelectSubset<T, CitaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cita.
     * @param {CitaUpsertArgs} args - Arguments to update or create a Cita.
     * @example
     * // Update or create a Cita
     * const cita = await prisma.cita.upsert({
     *   create: {
     *     // ... data to create a Cita
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cita we want to update
     *   }
     * })
     */
    upsert<T extends CitaUpsertArgs>(args: SelectSubset<T, CitaUpsertArgs<ExtArgs>>): Prisma__CitaClient<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Citas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitaCountArgs} args - Arguments to filter Citas to count.
     * @example
     * // Count the number of Citas
     * const count = await prisma.cita.count({
     *   where: {
     *     // ... the filter for the Citas we want to count
     *   }
     * })
    **/
    count<T extends CitaCountArgs>(
      args?: Subset<T, CitaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitaAggregateArgs>(args: Subset<T, CitaAggregateArgs>): Prisma.PrismaPromise<GetCitaAggregateType<T>>

    /**
     * Group by Cita.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CitaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CitaGroupByArgs['orderBy'] }
        : { orderBy?: CitaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CitaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cita model
   */
  readonly fields: CitaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cita.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CitaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends EstudianteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EstudianteDefaultArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversacion<T extends Cita$conversacionArgs<ExtArgs> = {}>(args?: Subset<T, Cita$conversacionArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cita model
   */
  interface CitaFieldRefs {
    readonly id: FieldRef<"Cita", 'String'>
    readonly estudianteId: FieldRef<"Cita", 'String'>
    readonly fecha: FieldRef<"Cita", 'DateTime'>
    readonly hora: FieldRef<"Cita", 'String'>
    readonly modalidad: FieldRef<"Cita", 'Modalidad'>
    readonly motivo: FieldRef<"Cita", 'String'>
    readonly estado: FieldRef<"Cita", 'EstadoCita'>
    readonly usuarioNombre: FieldRef<"Cita", 'String'>
    readonly usuarioTipoDocumento: FieldRef<"Cita", 'String'>
    readonly usuarioNumeroDocumento: FieldRef<"Cita", 'String'>
    readonly usuarioCorreo: FieldRef<"Cita", 'String'>
    readonly usuarioTelefono: FieldRef<"Cita", 'String'>
    readonly enlaceReunion: FieldRef<"Cita", 'String'>
    readonly conversacionId: FieldRef<"Cita", 'String'>
    readonly notifEnviada24h: FieldRef<"Cita", 'Boolean'>
    readonly notifEnviada15m: FieldRef<"Cita", 'Boolean'>
    readonly creadoEn: FieldRef<"Cita", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Cita", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cita findUnique
   */
  export type CitaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * Filter, which Cita to fetch.
     */
    where: CitaWhereUniqueInput
  }

  /**
   * Cita findUniqueOrThrow
   */
  export type CitaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * Filter, which Cita to fetch.
     */
    where: CitaWhereUniqueInput
  }

  /**
   * Cita findFirst
   */
  export type CitaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * Filter, which Cita to fetch.
     */
    where?: CitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citas to fetch.
     */
    orderBy?: CitaOrderByWithRelationInput | CitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Citas.
     */
    cursor?: CitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Citas.
     */
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * Cita findFirstOrThrow
   */
  export type CitaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * Filter, which Cita to fetch.
     */
    where?: CitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citas to fetch.
     */
    orderBy?: CitaOrderByWithRelationInput | CitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Citas.
     */
    cursor?: CitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Citas.
     */
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * Cita findMany
   */
  export type CitaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * Filter, which Citas to fetch.
     */
    where?: CitaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Citas to fetch.
     */
    orderBy?: CitaOrderByWithRelationInput | CitaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Citas.
     */
    cursor?: CitaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Citas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Citas.
     */
    skip?: number
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * Cita create
   */
  export type CitaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * The data needed to create a Cita.
     */
    data: XOR<CitaCreateInput, CitaUncheckedCreateInput>
  }

  /**
   * Cita createMany
   */
  export type CitaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Citas.
     */
    data: CitaCreateManyInput | CitaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cita createManyAndReturn
   */
  export type CitaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * The data used to create many Citas.
     */
    data: CitaCreateManyInput | CitaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cita update
   */
  export type CitaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * The data needed to update a Cita.
     */
    data: XOR<CitaUpdateInput, CitaUncheckedUpdateInput>
    /**
     * Choose, which Cita to update.
     */
    where: CitaWhereUniqueInput
  }

  /**
   * Cita updateMany
   */
  export type CitaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Citas.
     */
    data: XOR<CitaUpdateManyMutationInput, CitaUncheckedUpdateManyInput>
    /**
     * Filter which Citas to update
     */
    where?: CitaWhereInput
    /**
     * Limit how many Citas to update.
     */
    limit?: number
  }

  /**
   * Cita updateManyAndReturn
   */
  export type CitaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * The data used to update Citas.
     */
    data: XOR<CitaUpdateManyMutationInput, CitaUncheckedUpdateManyInput>
    /**
     * Filter which Citas to update
     */
    where?: CitaWhereInput
    /**
     * Limit how many Citas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cita upsert
   */
  export type CitaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * The filter to search for the Cita to update in case it exists.
     */
    where: CitaWhereUniqueInput
    /**
     * In case the Cita found by the `where` argument doesn't exist, create a new Cita with this data.
     */
    create: XOR<CitaCreateInput, CitaUncheckedCreateInput>
    /**
     * In case the Cita was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CitaUpdateInput, CitaUncheckedUpdateInput>
  }

  /**
   * Cita delete
   */
  export type CitaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    /**
     * Filter which Cita to delete.
     */
    where: CitaWhereUniqueInput
  }

  /**
   * Cita deleteMany
   */
  export type CitaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Citas to delete
     */
    where?: CitaWhereInput
    /**
     * Limit how many Citas to delete.
     */
    limit?: number
  }

  /**
   * Cita.conversacion
   */
  export type Cita$conversacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    where?: ConversacionWhereInput
  }

  /**
   * Cita without action
   */
  export type CitaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
  }


  /**
   * Model Auditoria
   */

  export type AggregateAuditoria = {
    _count: AuditoriaCountAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  export type AuditoriaMinAggregateOutputType = {
    id: string | null
    accion: $Enums.TipoAuditoria | null
    entidad: string | null
    entidadId: string | null
    detalles: string | null
    adminId: string | null
    adminNombre: string | null
    ip: string | null
    userAgent: string | null
    creadoEn: Date | null
  }

  export type AuditoriaMaxAggregateOutputType = {
    id: string | null
    accion: $Enums.TipoAuditoria | null
    entidad: string | null
    entidadId: string | null
    detalles: string | null
    adminId: string | null
    adminNombre: string | null
    ip: string | null
    userAgent: string | null
    creadoEn: Date | null
  }

  export type AuditoriaCountAggregateOutputType = {
    id: number
    accion: number
    entidad: number
    entidadId: number
    detalles: number
    adminId: number
    adminNombre: number
    ip: number
    userAgent: number
    creadoEn: number
    _all: number
  }


  export type AuditoriaMinAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    detalles?: true
    adminId?: true
    adminNombre?: true
    ip?: true
    userAgent?: true
    creadoEn?: true
  }

  export type AuditoriaMaxAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    detalles?: true
    adminId?: true
    adminNombre?: true
    ip?: true
    userAgent?: true
    creadoEn?: true
  }

  export type AuditoriaCountAggregateInputType = {
    id?: true
    accion?: true
    entidad?: true
    entidadId?: true
    detalles?: true
    adminId?: true
    adminNombre?: true
    ip?: true
    userAgent?: true
    creadoEn?: true
    _all?: true
  }

  export type AuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auditoria to aggregate.
     */
    where?: AuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditorias to fetch.
     */
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auditorias
    **/
    _count?: true | AuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditoriaMaxAggregateInputType
  }

  export type GetAuditoriaAggregateType<T extends AuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditoria[P]>
      : GetScalarType<T[P], AggregateAuditoria[P]>
  }




  export type AuditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditoriaWhereInput
    orderBy?: AuditoriaOrderByWithAggregationInput | AuditoriaOrderByWithAggregationInput[]
    by: AuditoriaScalarFieldEnum[] | AuditoriaScalarFieldEnum
    having?: AuditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditoriaCountAggregateInputType | true
    _min?: AuditoriaMinAggregateInputType
    _max?: AuditoriaMaxAggregateInputType
  }

  export type AuditoriaGroupByOutputType = {
    id: string
    accion: $Enums.TipoAuditoria
    entidad: string
    entidadId: string | null
    detalles: string
    adminId: string | null
    adminNombre: string | null
    ip: string | null
    userAgent: string | null
    creadoEn: Date
    _count: AuditoriaCountAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  type GetAuditoriaGroupByPayload<T extends AuditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type AuditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    detalles?: boolean
    adminId?: boolean
    adminNombre?: boolean
    ip?: boolean
    userAgent?: boolean
    creadoEn?: boolean
  }, ExtArgs["result"]["auditoria"]>

  export type AuditoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    detalles?: boolean
    adminId?: boolean
    adminNombre?: boolean
    ip?: boolean
    userAgent?: boolean
    creadoEn?: boolean
  }, ExtArgs["result"]["auditoria"]>

  export type AuditoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    detalles?: boolean
    adminId?: boolean
    adminNombre?: boolean
    ip?: boolean
    userAgent?: boolean
    creadoEn?: boolean
  }, ExtArgs["result"]["auditoria"]>

  export type AuditoriaSelectScalar = {
    id?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    detalles?: boolean
    adminId?: boolean
    adminNombre?: boolean
    ip?: boolean
    userAgent?: boolean
    creadoEn?: boolean
  }

  export type AuditoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accion" | "entidad" | "entidadId" | "detalles" | "adminId" | "adminNombre" | "ip" | "userAgent" | "creadoEn", ExtArgs["result"]["auditoria"]>

  export type $AuditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auditoria"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accion: $Enums.TipoAuditoria
      entidad: string
      entidadId: string | null
      detalles: string
      adminId: string | null
      adminNombre: string | null
      ip: string | null
      userAgent: string | null
      creadoEn: Date
    }, ExtArgs["result"]["auditoria"]>
    composites: {}
  }

  type AuditoriaGetPayload<S extends boolean | null | undefined | AuditoriaDefaultArgs> = $Result.GetResult<Prisma.$AuditoriaPayload, S>

  type AuditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditoriaCountAggregateInputType | true
    }

  export interface AuditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auditoria'], meta: { name: 'Auditoria' } }
    /**
     * Find zero or one Auditoria that matches the filter.
     * @param {AuditoriaFindUniqueArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditoriaFindUniqueArgs>(args: SelectSubset<T, AuditoriaFindUniqueArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auditoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditoriaFindUniqueOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaFindFirstArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditoriaFindFirstArgs>(args?: SelectSubset<T, AuditoriaFindFirstArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaFindFirstOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditorias
     * const auditorias = await prisma.auditoria.findMany()
     * 
     * // Get first 10 Auditorias
     * const auditorias = await prisma.auditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditoriaFindManyArgs>(args?: SelectSubset<T, AuditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auditoria.
     * @param {AuditoriaCreateArgs} args - Arguments to create a Auditoria.
     * @example
     * // Create one Auditoria
     * const Auditoria = await prisma.auditoria.create({
     *   data: {
     *     // ... data to create a Auditoria
     *   }
     * })
     * 
     */
    create<T extends AuditoriaCreateArgs>(args: SelectSubset<T, AuditoriaCreateArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auditorias.
     * @param {AuditoriaCreateManyArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditoriaCreateManyArgs>(args?: SelectSubset<T, AuditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auditorias and returns the data saved in the database.
     * @param {AuditoriaCreateManyAndReturnArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auditorias and only return the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auditoria.
     * @param {AuditoriaDeleteArgs} args - Arguments to delete one Auditoria.
     * @example
     * // Delete one Auditoria
     * const Auditoria = await prisma.auditoria.delete({
     *   where: {
     *     // ... filter to delete one Auditoria
     *   }
     * })
     * 
     */
    delete<T extends AuditoriaDeleteArgs>(args: SelectSubset<T, AuditoriaDeleteArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auditoria.
     * @param {AuditoriaUpdateArgs} args - Arguments to update one Auditoria.
     * @example
     * // Update one Auditoria
     * const auditoria = await prisma.auditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditoriaUpdateArgs>(args: SelectSubset<T, AuditoriaUpdateArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auditorias.
     * @param {AuditoriaDeleteManyArgs} args - Arguments to filter Auditorias to delete.
     * @example
     * // Delete a few Auditorias
     * const { count } = await prisma.auditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditoriaDeleteManyArgs>(args?: SelectSubset<T, AuditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditoriaUpdateManyArgs>(args: SelectSubset<T, AuditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias and returns the data updated in the database.
     * @param {AuditoriaUpdateManyAndReturnArgs} args - Arguments to update many Auditorias.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auditorias and only return the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auditoria.
     * @param {AuditoriaUpsertArgs} args - Arguments to update or create a Auditoria.
     * @example
     * // Update or create a Auditoria
     * const auditoria = await prisma.auditoria.upsert({
     *   create: {
     *     // ... data to create a Auditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditoria we want to update
     *   }
     * })
     */
    upsert<T extends AuditoriaUpsertArgs>(args: SelectSubset<T, AuditoriaUpsertArgs<ExtArgs>>): Prisma__AuditoriaClient<$Result.GetResult<Prisma.$AuditoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaCountArgs} args - Arguments to filter Auditorias to count.
     * @example
     * // Count the number of Auditorias
     * const count = await prisma.auditoria.count({
     *   where: {
     *     // ... the filter for the Auditorias we want to count
     *   }
     * })
    **/
    count<T extends AuditoriaCountArgs>(
      args?: Subset<T, AuditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditoriaAggregateArgs>(args: Subset<T, AuditoriaAggregateArgs>): Prisma.PrismaPromise<GetAuditoriaAggregateType<T>>

    /**
     * Group by Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditoriaGroupByArgs['orderBy'] }
        : { orderBy?: AuditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auditoria model
   */
  readonly fields: AuditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auditoria model
   */
  interface AuditoriaFieldRefs {
    readonly id: FieldRef<"Auditoria", 'String'>
    readonly accion: FieldRef<"Auditoria", 'TipoAuditoria'>
    readonly entidad: FieldRef<"Auditoria", 'String'>
    readonly entidadId: FieldRef<"Auditoria", 'String'>
    readonly detalles: FieldRef<"Auditoria", 'String'>
    readonly adminId: FieldRef<"Auditoria", 'String'>
    readonly adminNombre: FieldRef<"Auditoria", 'String'>
    readonly ip: FieldRef<"Auditoria", 'String'>
    readonly userAgent: FieldRef<"Auditoria", 'String'>
    readonly creadoEn: FieldRef<"Auditoria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Auditoria findUnique
   */
  export type AuditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Filter, which Auditoria to fetch.
     */
    where: AuditoriaWhereUniqueInput
  }

  /**
   * Auditoria findUniqueOrThrow
   */
  export type AuditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Filter, which Auditoria to fetch.
     */
    where: AuditoriaWhereUniqueInput
  }

  /**
   * Auditoria findFirst
   */
  export type AuditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Filter, which Auditoria to fetch.
     */
    where?: AuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditorias to fetch.
     */
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auditorias.
     */
    cursor?: AuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * Auditoria findFirstOrThrow
   */
  export type AuditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Filter, which Auditoria to fetch.
     */
    where?: AuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditorias to fetch.
     */
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auditorias.
     */
    cursor?: AuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * Auditoria findMany
   */
  export type AuditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Filter, which Auditorias to fetch.
     */
    where?: AuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auditorias to fetch.
     */
    orderBy?: AuditoriaOrderByWithRelationInput | AuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auditorias.
     */
    cursor?: AuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auditorias.
     */
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * Auditoria create
   */
  export type AuditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * The data needed to create a Auditoria.
     */
    data: XOR<AuditoriaCreateInput, AuditoriaUncheckedCreateInput>
  }

  /**
   * Auditoria createMany
   */
  export type AuditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auditorias.
     */
    data: AuditoriaCreateManyInput | AuditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auditoria createManyAndReturn
   */
  export type AuditoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * The data used to create many Auditorias.
     */
    data: AuditoriaCreateManyInput | AuditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auditoria update
   */
  export type AuditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * The data needed to update a Auditoria.
     */
    data: XOR<AuditoriaUpdateInput, AuditoriaUncheckedUpdateInput>
    /**
     * Choose, which Auditoria to update.
     */
    where: AuditoriaWhereUniqueInput
  }

  /**
   * Auditoria updateMany
   */
  export type AuditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auditorias.
     */
    data: XOR<AuditoriaUpdateManyMutationInput, AuditoriaUncheckedUpdateManyInput>
    /**
     * Filter which Auditorias to update
     */
    where?: AuditoriaWhereInput
    /**
     * Limit how many Auditorias to update.
     */
    limit?: number
  }

  /**
   * Auditoria updateManyAndReturn
   */
  export type AuditoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * The data used to update Auditorias.
     */
    data: XOR<AuditoriaUpdateManyMutationInput, AuditoriaUncheckedUpdateManyInput>
    /**
     * Filter which Auditorias to update
     */
    where?: AuditoriaWhereInput
    /**
     * Limit how many Auditorias to update.
     */
    limit?: number
  }

  /**
   * Auditoria upsert
   */
  export type AuditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * The filter to search for the Auditoria to update in case it exists.
     */
    where: AuditoriaWhereUniqueInput
    /**
     * In case the Auditoria found by the `where` argument doesn't exist, create a new Auditoria with this data.
     */
    create: XOR<AuditoriaCreateInput, AuditoriaUncheckedCreateInput>
    /**
     * In case the Auditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditoriaUpdateInput, AuditoriaUncheckedUpdateInput>
  }

  /**
   * Auditoria delete
   */
  export type AuditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
    /**
     * Filter which Auditoria to delete.
     */
    where: AuditoriaWhereUniqueInput
  }

  /**
   * Auditoria deleteMany
   */
  export type AuditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auditorias to delete
     */
    where?: AuditoriaWhereInput
    /**
     * Limit how many Auditorias to delete.
     */
    limit?: number
  }

  /**
   * Auditoria without action
   */
  export type AuditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auditoria
     */
    select?: AuditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auditoria
     */
    omit?: AuditoriaOmit<ExtArgs> | null
  }


  /**
   * Model ConfiguracionWhatsApp
   */

  export type AggregateConfiguracionWhatsApp = {
    _count: ConfiguracionWhatsAppCountAggregateOutputType | null
    _min: ConfiguracionWhatsAppMinAggregateOutputType | null
    _max: ConfiguracionWhatsAppMaxAggregateOutputType | null
  }

  export type ConfiguracionWhatsAppMinAggregateOutputType = {
    id: string | null
    nombreBot: string | null
    phoneNumberId: string | null
    businessAccountId: string | null
    webhookVerifyToken: string | null
    webhookUrl: string | null
    tokenAcceso: string | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracionWhatsAppMaxAggregateOutputType = {
    id: string | null
    nombreBot: string | null
    phoneNumberId: string | null
    businessAccountId: string | null
    webhookVerifyToken: string | null
    webhookUrl: string | null
    tokenAcceso: string | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracionWhatsAppCountAggregateOutputType = {
    id: number
    nombreBot: number
    phoneNumberId: number
    businessAccountId: number
    webhookVerifyToken: number
    webhookUrl: number
    tokenAcceso: number
    activo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfiguracionWhatsAppMinAggregateInputType = {
    id?: true
    nombreBot?: true
    phoneNumberId?: true
    businessAccountId?: true
    webhookVerifyToken?: true
    webhookUrl?: true
    tokenAcceso?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracionWhatsAppMaxAggregateInputType = {
    id?: true
    nombreBot?: true
    phoneNumberId?: true
    businessAccountId?: true
    webhookVerifyToken?: true
    webhookUrl?: true
    tokenAcceso?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracionWhatsAppCountAggregateInputType = {
    id?: true
    nombreBot?: true
    phoneNumberId?: true
    businessAccountId?: true
    webhookVerifyToken?: true
    webhookUrl?: true
    tokenAcceso?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfiguracionWhatsAppAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracionWhatsApp to aggregate.
     */
    where?: ConfiguracionWhatsAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionWhatsApps to fetch.
     */
    orderBy?: ConfiguracionWhatsAppOrderByWithRelationInput | ConfiguracionWhatsAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfiguracionWhatsAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionWhatsApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionWhatsApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfiguracionWhatsApps
    **/
    _count?: true | ConfiguracionWhatsAppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfiguracionWhatsAppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfiguracionWhatsAppMaxAggregateInputType
  }

  export type GetConfiguracionWhatsAppAggregateType<T extends ConfiguracionWhatsAppAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguracionWhatsApp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguracionWhatsApp[P]>
      : GetScalarType<T[P], AggregateConfiguracionWhatsApp[P]>
  }




  export type ConfiguracionWhatsAppGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfiguracionWhatsAppWhereInput
    orderBy?: ConfiguracionWhatsAppOrderByWithAggregationInput | ConfiguracionWhatsAppOrderByWithAggregationInput[]
    by: ConfiguracionWhatsAppScalarFieldEnum[] | ConfiguracionWhatsAppScalarFieldEnum
    having?: ConfiguracionWhatsAppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfiguracionWhatsAppCountAggregateInputType | true
    _min?: ConfiguracionWhatsAppMinAggregateInputType
    _max?: ConfiguracionWhatsAppMaxAggregateInputType
  }

  export type ConfiguracionWhatsAppGroupByOutputType = {
    id: string
    nombreBot: string
    phoneNumberId: string | null
    businessAccountId: string | null
    webhookVerifyToken: string | null
    webhookUrl: string | null
    tokenAcceso: string | null
    activo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ConfiguracionWhatsAppCountAggregateOutputType | null
    _min: ConfiguracionWhatsAppMinAggregateOutputType | null
    _max: ConfiguracionWhatsAppMaxAggregateOutputType | null
  }

  type GetConfiguracionWhatsAppGroupByPayload<T extends ConfiguracionWhatsAppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfiguracionWhatsAppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfiguracionWhatsAppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfiguracionWhatsAppGroupByOutputType[P]>
            : GetScalarType<T[P], ConfiguracionWhatsAppGroupByOutputType[P]>
        }
      >
    >


  export type ConfiguracionWhatsAppSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreBot?: boolean
    phoneNumberId?: boolean
    businessAccountId?: boolean
    webhookVerifyToken?: boolean
    webhookUrl?: boolean
    tokenAcceso?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuracionWhatsApp"]>

  export type ConfiguracionWhatsAppSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreBot?: boolean
    phoneNumberId?: boolean
    businessAccountId?: boolean
    webhookVerifyToken?: boolean
    webhookUrl?: boolean
    tokenAcceso?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuracionWhatsApp"]>

  export type ConfiguracionWhatsAppSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombreBot?: boolean
    phoneNumberId?: boolean
    businessAccountId?: boolean
    webhookVerifyToken?: boolean
    webhookUrl?: boolean
    tokenAcceso?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuracionWhatsApp"]>

  export type ConfiguracionWhatsAppSelectScalar = {
    id?: boolean
    nombreBot?: boolean
    phoneNumberId?: boolean
    businessAccountId?: boolean
    webhookVerifyToken?: boolean
    webhookUrl?: boolean
    tokenAcceso?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfiguracionWhatsAppOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombreBot" | "phoneNumberId" | "businessAccountId" | "webhookVerifyToken" | "webhookUrl" | "tokenAcceso" | "activo" | "createdAt" | "updatedAt", ExtArgs["result"]["configuracionWhatsApp"]>

  export type $ConfiguracionWhatsAppPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfiguracionWhatsApp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombreBot: string
      phoneNumberId: string | null
      businessAccountId: string | null
      webhookVerifyToken: string | null
      webhookUrl: string | null
      tokenAcceso: string | null
      activo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configuracionWhatsApp"]>
    composites: {}
  }

  type ConfiguracionWhatsAppGetPayload<S extends boolean | null | undefined | ConfiguracionWhatsAppDefaultArgs> = $Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload, S>

  type ConfiguracionWhatsAppCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfiguracionWhatsAppFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfiguracionWhatsAppCountAggregateInputType | true
    }

  export interface ConfiguracionWhatsAppDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfiguracionWhatsApp'], meta: { name: 'ConfiguracionWhatsApp' } }
    /**
     * Find zero or one ConfiguracionWhatsApp that matches the filter.
     * @param {ConfiguracionWhatsAppFindUniqueArgs} args - Arguments to find a ConfiguracionWhatsApp
     * @example
     * // Get one ConfiguracionWhatsApp
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfiguracionWhatsAppFindUniqueArgs>(args: SelectSubset<T, ConfiguracionWhatsAppFindUniqueArgs<ExtArgs>>): Prisma__ConfiguracionWhatsAppClient<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConfiguracionWhatsApp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfiguracionWhatsAppFindUniqueOrThrowArgs} args - Arguments to find a ConfiguracionWhatsApp
     * @example
     * // Get one ConfiguracionWhatsApp
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfiguracionWhatsAppFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfiguracionWhatsAppFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfiguracionWhatsAppClient<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfiguracionWhatsApp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionWhatsAppFindFirstArgs} args - Arguments to find a ConfiguracionWhatsApp
     * @example
     * // Get one ConfiguracionWhatsApp
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfiguracionWhatsAppFindFirstArgs>(args?: SelectSubset<T, ConfiguracionWhatsAppFindFirstArgs<ExtArgs>>): Prisma__ConfiguracionWhatsAppClient<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfiguracionWhatsApp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionWhatsAppFindFirstOrThrowArgs} args - Arguments to find a ConfiguracionWhatsApp
     * @example
     * // Get one ConfiguracionWhatsApp
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfiguracionWhatsAppFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfiguracionWhatsAppFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfiguracionWhatsAppClient<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConfiguracionWhatsApps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionWhatsAppFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfiguracionWhatsApps
     * const configuracionWhatsApps = await prisma.configuracionWhatsApp.findMany()
     * 
     * // Get first 10 ConfiguracionWhatsApps
     * const configuracionWhatsApps = await prisma.configuracionWhatsApp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configuracionWhatsAppWithIdOnly = await prisma.configuracionWhatsApp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfiguracionWhatsAppFindManyArgs>(args?: SelectSubset<T, ConfiguracionWhatsAppFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConfiguracionWhatsApp.
     * @param {ConfiguracionWhatsAppCreateArgs} args - Arguments to create a ConfiguracionWhatsApp.
     * @example
     * // Create one ConfiguracionWhatsApp
     * const ConfiguracionWhatsApp = await prisma.configuracionWhatsApp.create({
     *   data: {
     *     // ... data to create a ConfiguracionWhatsApp
     *   }
     * })
     * 
     */
    create<T extends ConfiguracionWhatsAppCreateArgs>(args: SelectSubset<T, ConfiguracionWhatsAppCreateArgs<ExtArgs>>): Prisma__ConfiguracionWhatsAppClient<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConfiguracionWhatsApps.
     * @param {ConfiguracionWhatsAppCreateManyArgs} args - Arguments to create many ConfiguracionWhatsApps.
     * @example
     * // Create many ConfiguracionWhatsApps
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfiguracionWhatsAppCreateManyArgs>(args?: SelectSubset<T, ConfiguracionWhatsAppCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfiguracionWhatsApps and returns the data saved in the database.
     * @param {ConfiguracionWhatsAppCreateManyAndReturnArgs} args - Arguments to create many ConfiguracionWhatsApps.
     * @example
     * // Create many ConfiguracionWhatsApps
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfiguracionWhatsApps and only return the `id`
     * const configuracionWhatsAppWithIdOnly = await prisma.configuracionWhatsApp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfiguracionWhatsAppCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfiguracionWhatsAppCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConfiguracionWhatsApp.
     * @param {ConfiguracionWhatsAppDeleteArgs} args - Arguments to delete one ConfiguracionWhatsApp.
     * @example
     * // Delete one ConfiguracionWhatsApp
     * const ConfiguracionWhatsApp = await prisma.configuracionWhatsApp.delete({
     *   where: {
     *     // ... filter to delete one ConfiguracionWhatsApp
     *   }
     * })
     * 
     */
    delete<T extends ConfiguracionWhatsAppDeleteArgs>(args: SelectSubset<T, ConfiguracionWhatsAppDeleteArgs<ExtArgs>>): Prisma__ConfiguracionWhatsAppClient<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConfiguracionWhatsApp.
     * @param {ConfiguracionWhatsAppUpdateArgs} args - Arguments to update one ConfiguracionWhatsApp.
     * @example
     * // Update one ConfiguracionWhatsApp
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfiguracionWhatsAppUpdateArgs>(args: SelectSubset<T, ConfiguracionWhatsAppUpdateArgs<ExtArgs>>): Prisma__ConfiguracionWhatsAppClient<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConfiguracionWhatsApps.
     * @param {ConfiguracionWhatsAppDeleteManyArgs} args - Arguments to filter ConfiguracionWhatsApps to delete.
     * @example
     * // Delete a few ConfiguracionWhatsApps
     * const { count } = await prisma.configuracionWhatsApp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfiguracionWhatsAppDeleteManyArgs>(args?: SelectSubset<T, ConfiguracionWhatsAppDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfiguracionWhatsApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionWhatsAppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfiguracionWhatsApps
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfiguracionWhatsAppUpdateManyArgs>(args: SelectSubset<T, ConfiguracionWhatsAppUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfiguracionWhatsApps and returns the data updated in the database.
     * @param {ConfiguracionWhatsAppUpdateManyAndReturnArgs} args - Arguments to update many ConfiguracionWhatsApps.
     * @example
     * // Update many ConfiguracionWhatsApps
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConfiguracionWhatsApps and only return the `id`
     * const configuracionWhatsAppWithIdOnly = await prisma.configuracionWhatsApp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfiguracionWhatsAppUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfiguracionWhatsAppUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConfiguracionWhatsApp.
     * @param {ConfiguracionWhatsAppUpsertArgs} args - Arguments to update or create a ConfiguracionWhatsApp.
     * @example
     * // Update or create a ConfiguracionWhatsApp
     * const configuracionWhatsApp = await prisma.configuracionWhatsApp.upsert({
     *   create: {
     *     // ... data to create a ConfiguracionWhatsApp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfiguracionWhatsApp we want to update
     *   }
     * })
     */
    upsert<T extends ConfiguracionWhatsAppUpsertArgs>(args: SelectSubset<T, ConfiguracionWhatsAppUpsertArgs<ExtArgs>>): Prisma__ConfiguracionWhatsAppClient<$Result.GetResult<Prisma.$ConfiguracionWhatsAppPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConfiguracionWhatsApps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionWhatsAppCountArgs} args - Arguments to filter ConfiguracionWhatsApps to count.
     * @example
     * // Count the number of ConfiguracionWhatsApps
     * const count = await prisma.configuracionWhatsApp.count({
     *   where: {
     *     // ... the filter for the ConfiguracionWhatsApps we want to count
     *   }
     * })
    **/
    count<T extends ConfiguracionWhatsAppCountArgs>(
      args?: Subset<T, ConfiguracionWhatsAppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfiguracionWhatsAppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfiguracionWhatsApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionWhatsAppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfiguracionWhatsAppAggregateArgs>(args: Subset<T, ConfiguracionWhatsAppAggregateArgs>): Prisma.PrismaPromise<GetConfiguracionWhatsAppAggregateType<T>>

    /**
     * Group by ConfiguracionWhatsApp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionWhatsAppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfiguracionWhatsAppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfiguracionWhatsAppGroupByArgs['orderBy'] }
        : { orderBy?: ConfiguracionWhatsAppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfiguracionWhatsAppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfiguracionWhatsAppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfiguracionWhatsApp model
   */
  readonly fields: ConfiguracionWhatsAppFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfiguracionWhatsApp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfiguracionWhatsAppClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfiguracionWhatsApp model
   */
  interface ConfiguracionWhatsAppFieldRefs {
    readonly id: FieldRef<"ConfiguracionWhatsApp", 'String'>
    readonly nombreBot: FieldRef<"ConfiguracionWhatsApp", 'String'>
    readonly phoneNumberId: FieldRef<"ConfiguracionWhatsApp", 'String'>
    readonly businessAccountId: FieldRef<"ConfiguracionWhatsApp", 'String'>
    readonly webhookVerifyToken: FieldRef<"ConfiguracionWhatsApp", 'String'>
    readonly webhookUrl: FieldRef<"ConfiguracionWhatsApp", 'String'>
    readonly tokenAcceso: FieldRef<"ConfiguracionWhatsApp", 'String'>
    readonly activo: FieldRef<"ConfiguracionWhatsApp", 'Boolean'>
    readonly createdAt: FieldRef<"ConfiguracionWhatsApp", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfiguracionWhatsApp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfiguracionWhatsApp findUnique
   */
  export type ConfiguracionWhatsAppFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * Filter, which ConfiguracionWhatsApp to fetch.
     */
    where: ConfiguracionWhatsAppWhereUniqueInput
  }

  /**
   * ConfiguracionWhatsApp findUniqueOrThrow
   */
  export type ConfiguracionWhatsAppFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * Filter, which ConfiguracionWhatsApp to fetch.
     */
    where: ConfiguracionWhatsAppWhereUniqueInput
  }

  /**
   * ConfiguracionWhatsApp findFirst
   */
  export type ConfiguracionWhatsAppFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * Filter, which ConfiguracionWhatsApp to fetch.
     */
    where?: ConfiguracionWhatsAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionWhatsApps to fetch.
     */
    orderBy?: ConfiguracionWhatsAppOrderByWithRelationInput | ConfiguracionWhatsAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracionWhatsApps.
     */
    cursor?: ConfiguracionWhatsAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionWhatsApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionWhatsApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracionWhatsApps.
     */
    distinct?: ConfiguracionWhatsAppScalarFieldEnum | ConfiguracionWhatsAppScalarFieldEnum[]
  }

  /**
   * ConfiguracionWhatsApp findFirstOrThrow
   */
  export type ConfiguracionWhatsAppFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * Filter, which ConfiguracionWhatsApp to fetch.
     */
    where?: ConfiguracionWhatsAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionWhatsApps to fetch.
     */
    orderBy?: ConfiguracionWhatsAppOrderByWithRelationInput | ConfiguracionWhatsAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracionWhatsApps.
     */
    cursor?: ConfiguracionWhatsAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionWhatsApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionWhatsApps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracionWhatsApps.
     */
    distinct?: ConfiguracionWhatsAppScalarFieldEnum | ConfiguracionWhatsAppScalarFieldEnum[]
  }

  /**
   * ConfiguracionWhatsApp findMany
   */
  export type ConfiguracionWhatsAppFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * Filter, which ConfiguracionWhatsApps to fetch.
     */
    where?: ConfiguracionWhatsAppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracionWhatsApps to fetch.
     */
    orderBy?: ConfiguracionWhatsAppOrderByWithRelationInput | ConfiguracionWhatsAppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfiguracionWhatsApps.
     */
    cursor?: ConfiguracionWhatsAppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracionWhatsApps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracionWhatsApps.
     */
    skip?: number
    distinct?: ConfiguracionWhatsAppScalarFieldEnum | ConfiguracionWhatsAppScalarFieldEnum[]
  }

  /**
   * ConfiguracionWhatsApp create
   */
  export type ConfiguracionWhatsAppCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * The data needed to create a ConfiguracionWhatsApp.
     */
    data: XOR<ConfiguracionWhatsAppCreateInput, ConfiguracionWhatsAppUncheckedCreateInput>
  }

  /**
   * ConfiguracionWhatsApp createMany
   */
  export type ConfiguracionWhatsAppCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfiguracionWhatsApps.
     */
    data: ConfiguracionWhatsAppCreateManyInput | ConfiguracionWhatsAppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfiguracionWhatsApp createManyAndReturn
   */
  export type ConfiguracionWhatsAppCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * The data used to create many ConfiguracionWhatsApps.
     */
    data: ConfiguracionWhatsAppCreateManyInput | ConfiguracionWhatsAppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfiguracionWhatsApp update
   */
  export type ConfiguracionWhatsAppUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * The data needed to update a ConfiguracionWhatsApp.
     */
    data: XOR<ConfiguracionWhatsAppUpdateInput, ConfiguracionWhatsAppUncheckedUpdateInput>
    /**
     * Choose, which ConfiguracionWhatsApp to update.
     */
    where: ConfiguracionWhatsAppWhereUniqueInput
  }

  /**
   * ConfiguracionWhatsApp updateMany
   */
  export type ConfiguracionWhatsAppUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfiguracionWhatsApps.
     */
    data: XOR<ConfiguracionWhatsAppUpdateManyMutationInput, ConfiguracionWhatsAppUncheckedUpdateManyInput>
    /**
     * Filter which ConfiguracionWhatsApps to update
     */
    where?: ConfiguracionWhatsAppWhereInput
    /**
     * Limit how many ConfiguracionWhatsApps to update.
     */
    limit?: number
  }

  /**
   * ConfiguracionWhatsApp updateManyAndReturn
   */
  export type ConfiguracionWhatsAppUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * The data used to update ConfiguracionWhatsApps.
     */
    data: XOR<ConfiguracionWhatsAppUpdateManyMutationInput, ConfiguracionWhatsAppUncheckedUpdateManyInput>
    /**
     * Filter which ConfiguracionWhatsApps to update
     */
    where?: ConfiguracionWhatsAppWhereInput
    /**
     * Limit how many ConfiguracionWhatsApps to update.
     */
    limit?: number
  }

  /**
   * ConfiguracionWhatsApp upsert
   */
  export type ConfiguracionWhatsAppUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * The filter to search for the ConfiguracionWhatsApp to update in case it exists.
     */
    where: ConfiguracionWhatsAppWhereUniqueInput
    /**
     * In case the ConfiguracionWhatsApp found by the `where` argument doesn't exist, create a new ConfiguracionWhatsApp with this data.
     */
    create: XOR<ConfiguracionWhatsAppCreateInput, ConfiguracionWhatsAppUncheckedCreateInput>
    /**
     * In case the ConfiguracionWhatsApp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfiguracionWhatsAppUpdateInput, ConfiguracionWhatsAppUncheckedUpdateInput>
  }

  /**
   * ConfiguracionWhatsApp delete
   */
  export type ConfiguracionWhatsAppDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
    /**
     * Filter which ConfiguracionWhatsApp to delete.
     */
    where: ConfiguracionWhatsAppWhereUniqueInput
  }

  /**
   * ConfiguracionWhatsApp deleteMany
   */
  export type ConfiguracionWhatsAppDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracionWhatsApps to delete
     */
    where?: ConfiguracionWhatsAppWhereInput
    /**
     * Limit how many ConfiguracionWhatsApps to delete.
     */
    limit?: number
  }

  /**
   * ConfiguracionWhatsApp without action
   */
  export type ConfiguracionWhatsAppDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracionWhatsApp
     */
    select?: ConfiguracionWhatsAppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfiguracionWhatsApp
     */
    omit?: ConfiguracionWhatsAppOmit<ExtArgs> | null
  }


  /**
   * Model WebhookLog
   */

  export type AggregateWebhookLog = {
    _count: WebhookLogCountAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  export type WebhookLogMinAggregateOutputType = {
    id: string | null
    tipo: string | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type WebhookLogMaxAggregateOutputType = {
    id: string | null
    tipo: string | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type WebhookLogCountAggregateOutputType = {
    id: number
    tipo: number
    payload: number
    processed: number
    createdAt: number
    _all: number
  }


  export type WebhookLogMinAggregateInputType = {
    id?: true
    tipo?: true
    processed?: true
    createdAt?: true
  }

  export type WebhookLogMaxAggregateInputType = {
    id?: true
    tipo?: true
    processed?: true
    createdAt?: true
  }

  export type WebhookLogCountAggregateInputType = {
    id?: true
    tipo?: true
    payload?: true
    processed?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLog to aggregate.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookLogs
    **/
    _count?: true | WebhookLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookLogMaxAggregateInputType
  }

  export type GetWebhookLogAggregateType<T extends WebhookLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookLog[P]>
      : GetScalarType<T[P], AggregateWebhookLog[P]>
  }




  export type WebhookLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookLogWhereInput
    orderBy?: WebhookLogOrderByWithAggregationInput | WebhookLogOrderByWithAggregationInput[]
    by: WebhookLogScalarFieldEnum[] | WebhookLogScalarFieldEnum
    having?: WebhookLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookLogCountAggregateInputType | true
    _min?: WebhookLogMinAggregateInputType
    _max?: WebhookLogMaxAggregateInputType
  }

  export type WebhookLogGroupByOutputType = {
    id: string
    tipo: string
    payload: JsonValue
    processed: boolean
    createdAt: Date
    _count: WebhookLogCountAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  type GetWebhookLogGroupByPayload<T extends WebhookLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
        }
      >
    >


  export type WebhookLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectScalar = {
    id?: boolean
    tipo?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }

  export type WebhookLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "payload" | "processed" | "createdAt", ExtArgs["result"]["webhookLog"]>

  export type $WebhookLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: string
      payload: Prisma.JsonValue
      processed: boolean
      createdAt: Date
    }, ExtArgs["result"]["webhookLog"]>
    composites: {}
  }

  type WebhookLogGetPayload<S extends boolean | null | undefined | WebhookLogDefaultArgs> = $Result.GetResult<Prisma.$WebhookLogPayload, S>

  type WebhookLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookLogCountAggregateInputType | true
    }

  export interface WebhookLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookLog'], meta: { name: 'WebhookLog' } }
    /**
     * Find zero or one WebhookLog that matches the filter.
     * @param {WebhookLogFindUniqueArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookLogFindUniqueArgs>(args: SelectSubset<T, WebhookLogFindUniqueArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookLogFindUniqueOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookLogFindFirstArgs>(args?: SelectSubset<T, WebhookLogFindFirstArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany()
     * 
     * // Get first 10 WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookLogFindManyArgs>(args?: SelectSubset<T, WebhookLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookLog.
     * @param {WebhookLogCreateArgs} args - Arguments to create a WebhookLog.
     * @example
     * // Create one WebhookLog
     * const WebhookLog = await prisma.webhookLog.create({
     *   data: {
     *     // ... data to create a WebhookLog
     *   }
     * })
     * 
     */
    create<T extends WebhookLogCreateArgs>(args: SelectSubset<T, WebhookLogCreateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookLogs.
     * @param {WebhookLogCreateManyArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookLogCreateManyArgs>(args?: SelectSubset<T, WebhookLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookLogs and returns the data saved in the database.
     * @param {WebhookLogCreateManyAndReturnArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookLogs and only return the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookLog.
     * @param {WebhookLogDeleteArgs} args - Arguments to delete one WebhookLog.
     * @example
     * // Delete one WebhookLog
     * const WebhookLog = await prisma.webhookLog.delete({
     *   where: {
     *     // ... filter to delete one WebhookLog
     *   }
     * })
     * 
     */
    delete<T extends WebhookLogDeleteArgs>(args: SelectSubset<T, WebhookLogDeleteArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookLog.
     * @param {WebhookLogUpdateArgs} args - Arguments to update one WebhookLog.
     * @example
     * // Update one WebhookLog
     * const webhookLog = await prisma.webhookLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookLogUpdateArgs>(args: SelectSubset<T, WebhookLogUpdateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookLogs.
     * @param {WebhookLogDeleteManyArgs} args - Arguments to filter WebhookLogs to delete.
     * @example
     * // Delete a few WebhookLogs
     * const { count } = await prisma.webhookLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookLogDeleteManyArgs>(args?: SelectSubset<T, WebhookLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookLogUpdateManyArgs>(args: SelectSubset<T, WebhookLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs and returns the data updated in the database.
     * @param {WebhookLogUpdateManyAndReturnArgs} args - Arguments to update many WebhookLogs.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookLogs and only return the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookLogUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookLog.
     * @param {WebhookLogUpsertArgs} args - Arguments to update or create a WebhookLog.
     * @example
     * // Update or create a WebhookLog
     * const webhookLog = await prisma.webhookLog.upsert({
     *   create: {
     *     // ... data to create a WebhookLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookLog we want to update
     *   }
     * })
     */
    upsert<T extends WebhookLogUpsertArgs>(args: SelectSubset<T, WebhookLogUpsertArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogCountArgs} args - Arguments to filter WebhookLogs to count.
     * @example
     * // Count the number of WebhookLogs
     * const count = await prisma.webhookLog.count({
     *   where: {
     *     // ... the filter for the WebhookLogs we want to count
     *   }
     * })
    **/
    count<T extends WebhookLogCountArgs>(
      args?: Subset<T, WebhookLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookLogAggregateArgs>(args: Subset<T, WebhookLogAggregateArgs>): Prisma.PrismaPromise<GetWebhookLogAggregateType<T>>

    /**
     * Group by WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookLogGroupByArgs['orderBy'] }
        : { orderBy?: WebhookLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookLog model
   */
  readonly fields: WebhookLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookLog model
   */
  interface WebhookLogFieldRefs {
    readonly id: FieldRef<"WebhookLog", 'String'>
    readonly tipo: FieldRef<"WebhookLog", 'String'>
    readonly payload: FieldRef<"WebhookLog", 'Json'>
    readonly processed: FieldRef<"WebhookLog", 'Boolean'>
    readonly createdAt: FieldRef<"WebhookLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookLog findUnique
   */
  export type WebhookLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findUniqueOrThrow
   */
  export type WebhookLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findFirst
   */
  export type WebhookLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findFirstOrThrow
   */
  export type WebhookLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findMany
   */
  export type WebhookLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLogs to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog create
   */
  export type WebhookLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data needed to create a WebhookLog.
     */
    data: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
  }

  /**
   * WebhookLog createMany
   */
  export type WebhookLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog createManyAndReturn
   */
  export type WebhookLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog update
   */
  export type WebhookLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data needed to update a WebhookLog.
     */
    data: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
    /**
     * Choose, which WebhookLog to update.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog updateMany
   */
  export type WebhookLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookLogs.
     */
    data: XOR<WebhookLogUpdateManyMutationInput, WebhookLogUncheckedUpdateManyInput>
    /**
     * Filter which WebhookLogs to update
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to update.
     */
    limit?: number
  }

  /**
   * WebhookLog updateManyAndReturn
   */
  export type WebhookLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data used to update WebhookLogs.
     */
    data: XOR<WebhookLogUpdateManyMutationInput, WebhookLogUncheckedUpdateManyInput>
    /**
     * Filter which WebhookLogs to update
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to update.
     */
    limit?: number
  }

  /**
   * WebhookLog upsert
   */
  export type WebhookLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The filter to search for the WebhookLog to update in case it exists.
     */
    where: WebhookLogWhereUniqueInput
    /**
     * In case the WebhookLog found by the `where` argument doesn't exist, create a new WebhookLog with this data.
     */
    create: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
    /**
     * In case the WebhookLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
  }

  /**
   * WebhookLog delete
   */
  export type WebhookLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter which WebhookLog to delete.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog deleteMany
   */
  export type WebhookLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLogs to delete
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to delete.
     */
    limit?: number
  }

  /**
   * WebhookLog without action
   */
  export type WebhookLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
  }


  /**
   * Model PlantillaMensaje
   */

  export type AggregatePlantillaMensaje = {
    _count: PlantillaMensajeCountAggregateOutputType | null
    _min: PlantillaMensajeMinAggregateOutputType | null
    _max: PlantillaMensajeMaxAggregateOutputType | null
  }

  export type PlantillaMensajeMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    contenido: string | null
    tipo: string | null
    idioma: string | null
    activa: boolean | null
    createdAt: Date | null
  }

  export type PlantillaMensajeMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    contenido: string | null
    tipo: string | null
    idioma: string | null
    activa: boolean | null
    createdAt: Date | null
  }

  export type PlantillaMensajeCountAggregateOutputType = {
    id: number
    nombre: number
    contenido: number
    tipo: number
    idioma: number
    activa: number
    createdAt: number
    _all: number
  }


  export type PlantillaMensajeMinAggregateInputType = {
    id?: true
    nombre?: true
    contenido?: true
    tipo?: true
    idioma?: true
    activa?: true
    createdAt?: true
  }

  export type PlantillaMensajeMaxAggregateInputType = {
    id?: true
    nombre?: true
    contenido?: true
    tipo?: true
    idioma?: true
    activa?: true
    createdAt?: true
  }

  export type PlantillaMensajeCountAggregateInputType = {
    id?: true
    nombre?: true
    contenido?: true
    tipo?: true
    idioma?: true
    activa?: true
    createdAt?: true
    _all?: true
  }

  export type PlantillaMensajeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantillaMensaje to aggregate.
     */
    where?: PlantillaMensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantillaMensajes to fetch.
     */
    orderBy?: PlantillaMensajeOrderByWithRelationInput | PlantillaMensajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlantillaMensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantillaMensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantillaMensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlantillaMensajes
    **/
    _count?: true | PlantillaMensajeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantillaMensajeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantillaMensajeMaxAggregateInputType
  }

  export type GetPlantillaMensajeAggregateType<T extends PlantillaMensajeAggregateArgs> = {
        [P in keyof T & keyof AggregatePlantillaMensaje]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlantillaMensaje[P]>
      : GetScalarType<T[P], AggregatePlantillaMensaje[P]>
  }




  export type PlantillaMensajeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlantillaMensajeWhereInput
    orderBy?: PlantillaMensajeOrderByWithAggregationInput | PlantillaMensajeOrderByWithAggregationInput[]
    by: PlantillaMensajeScalarFieldEnum[] | PlantillaMensajeScalarFieldEnum
    having?: PlantillaMensajeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantillaMensajeCountAggregateInputType | true
    _min?: PlantillaMensajeMinAggregateInputType
    _max?: PlantillaMensajeMaxAggregateInputType
  }

  export type PlantillaMensajeGroupByOutputType = {
    id: string
    nombre: string
    contenido: string
    tipo: string
    idioma: string
    activa: boolean
    createdAt: Date
    _count: PlantillaMensajeCountAggregateOutputType | null
    _min: PlantillaMensajeMinAggregateOutputType | null
    _max: PlantillaMensajeMaxAggregateOutputType | null
  }

  type GetPlantillaMensajeGroupByPayload<T extends PlantillaMensajeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantillaMensajeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantillaMensajeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantillaMensajeGroupByOutputType[P]>
            : GetScalarType<T[P], PlantillaMensajeGroupByOutputType[P]>
        }
      >
    >


  export type PlantillaMensajeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    contenido?: boolean
    tipo?: boolean
    idioma?: boolean
    activa?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["plantillaMensaje"]>

  export type PlantillaMensajeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    contenido?: boolean
    tipo?: boolean
    idioma?: boolean
    activa?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["plantillaMensaje"]>

  export type PlantillaMensajeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    contenido?: boolean
    tipo?: boolean
    idioma?: boolean
    activa?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["plantillaMensaje"]>

  export type PlantillaMensajeSelectScalar = {
    id?: boolean
    nombre?: boolean
    contenido?: boolean
    tipo?: boolean
    idioma?: boolean
    activa?: boolean
    createdAt?: boolean
  }

  export type PlantillaMensajeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "contenido" | "tipo" | "idioma" | "activa" | "createdAt", ExtArgs["result"]["plantillaMensaje"]>

  export type $PlantillaMensajePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlantillaMensaje"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      contenido: string
      tipo: string
      idioma: string
      activa: boolean
      createdAt: Date
    }, ExtArgs["result"]["plantillaMensaje"]>
    composites: {}
  }

  type PlantillaMensajeGetPayload<S extends boolean | null | undefined | PlantillaMensajeDefaultArgs> = $Result.GetResult<Prisma.$PlantillaMensajePayload, S>

  type PlantillaMensajeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlantillaMensajeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantillaMensajeCountAggregateInputType | true
    }

  export interface PlantillaMensajeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlantillaMensaje'], meta: { name: 'PlantillaMensaje' } }
    /**
     * Find zero or one PlantillaMensaje that matches the filter.
     * @param {PlantillaMensajeFindUniqueArgs} args - Arguments to find a PlantillaMensaje
     * @example
     * // Get one PlantillaMensaje
     * const plantillaMensaje = await prisma.plantillaMensaje.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlantillaMensajeFindUniqueArgs>(args: SelectSubset<T, PlantillaMensajeFindUniqueArgs<ExtArgs>>): Prisma__PlantillaMensajeClient<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlantillaMensaje that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlantillaMensajeFindUniqueOrThrowArgs} args - Arguments to find a PlantillaMensaje
     * @example
     * // Get one PlantillaMensaje
     * const plantillaMensaje = await prisma.plantillaMensaje.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlantillaMensajeFindUniqueOrThrowArgs>(args: SelectSubset<T, PlantillaMensajeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlantillaMensajeClient<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantillaMensaje that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaMensajeFindFirstArgs} args - Arguments to find a PlantillaMensaje
     * @example
     * // Get one PlantillaMensaje
     * const plantillaMensaje = await prisma.plantillaMensaje.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlantillaMensajeFindFirstArgs>(args?: SelectSubset<T, PlantillaMensajeFindFirstArgs<ExtArgs>>): Prisma__PlantillaMensajeClient<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlantillaMensaje that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaMensajeFindFirstOrThrowArgs} args - Arguments to find a PlantillaMensaje
     * @example
     * // Get one PlantillaMensaje
     * const plantillaMensaje = await prisma.plantillaMensaje.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlantillaMensajeFindFirstOrThrowArgs>(args?: SelectSubset<T, PlantillaMensajeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlantillaMensajeClient<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlantillaMensajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaMensajeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlantillaMensajes
     * const plantillaMensajes = await prisma.plantillaMensaje.findMany()
     * 
     * // Get first 10 PlantillaMensajes
     * const plantillaMensajes = await prisma.plantillaMensaje.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantillaMensajeWithIdOnly = await prisma.plantillaMensaje.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlantillaMensajeFindManyArgs>(args?: SelectSubset<T, PlantillaMensajeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlantillaMensaje.
     * @param {PlantillaMensajeCreateArgs} args - Arguments to create a PlantillaMensaje.
     * @example
     * // Create one PlantillaMensaje
     * const PlantillaMensaje = await prisma.plantillaMensaje.create({
     *   data: {
     *     // ... data to create a PlantillaMensaje
     *   }
     * })
     * 
     */
    create<T extends PlantillaMensajeCreateArgs>(args: SelectSubset<T, PlantillaMensajeCreateArgs<ExtArgs>>): Prisma__PlantillaMensajeClient<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlantillaMensajes.
     * @param {PlantillaMensajeCreateManyArgs} args - Arguments to create many PlantillaMensajes.
     * @example
     * // Create many PlantillaMensajes
     * const plantillaMensaje = await prisma.plantillaMensaje.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlantillaMensajeCreateManyArgs>(args?: SelectSubset<T, PlantillaMensajeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlantillaMensajes and returns the data saved in the database.
     * @param {PlantillaMensajeCreateManyAndReturnArgs} args - Arguments to create many PlantillaMensajes.
     * @example
     * // Create many PlantillaMensajes
     * const plantillaMensaje = await prisma.plantillaMensaje.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlantillaMensajes and only return the `id`
     * const plantillaMensajeWithIdOnly = await prisma.plantillaMensaje.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlantillaMensajeCreateManyAndReturnArgs>(args?: SelectSubset<T, PlantillaMensajeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlantillaMensaje.
     * @param {PlantillaMensajeDeleteArgs} args - Arguments to delete one PlantillaMensaje.
     * @example
     * // Delete one PlantillaMensaje
     * const PlantillaMensaje = await prisma.plantillaMensaje.delete({
     *   where: {
     *     // ... filter to delete one PlantillaMensaje
     *   }
     * })
     * 
     */
    delete<T extends PlantillaMensajeDeleteArgs>(args: SelectSubset<T, PlantillaMensajeDeleteArgs<ExtArgs>>): Prisma__PlantillaMensajeClient<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlantillaMensaje.
     * @param {PlantillaMensajeUpdateArgs} args - Arguments to update one PlantillaMensaje.
     * @example
     * // Update one PlantillaMensaje
     * const plantillaMensaje = await prisma.plantillaMensaje.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlantillaMensajeUpdateArgs>(args: SelectSubset<T, PlantillaMensajeUpdateArgs<ExtArgs>>): Prisma__PlantillaMensajeClient<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlantillaMensajes.
     * @param {PlantillaMensajeDeleteManyArgs} args - Arguments to filter PlantillaMensajes to delete.
     * @example
     * // Delete a few PlantillaMensajes
     * const { count } = await prisma.plantillaMensaje.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlantillaMensajeDeleteManyArgs>(args?: SelectSubset<T, PlantillaMensajeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantillaMensajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaMensajeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlantillaMensajes
     * const plantillaMensaje = await prisma.plantillaMensaje.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlantillaMensajeUpdateManyArgs>(args: SelectSubset<T, PlantillaMensajeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlantillaMensajes and returns the data updated in the database.
     * @param {PlantillaMensajeUpdateManyAndReturnArgs} args - Arguments to update many PlantillaMensajes.
     * @example
     * // Update many PlantillaMensajes
     * const plantillaMensaje = await prisma.plantillaMensaje.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlantillaMensajes and only return the `id`
     * const plantillaMensajeWithIdOnly = await prisma.plantillaMensaje.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlantillaMensajeUpdateManyAndReturnArgs>(args: SelectSubset<T, PlantillaMensajeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlantillaMensaje.
     * @param {PlantillaMensajeUpsertArgs} args - Arguments to update or create a PlantillaMensaje.
     * @example
     * // Update or create a PlantillaMensaje
     * const plantillaMensaje = await prisma.plantillaMensaje.upsert({
     *   create: {
     *     // ... data to create a PlantillaMensaje
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlantillaMensaje we want to update
     *   }
     * })
     */
    upsert<T extends PlantillaMensajeUpsertArgs>(args: SelectSubset<T, PlantillaMensajeUpsertArgs<ExtArgs>>): Prisma__PlantillaMensajeClient<$Result.GetResult<Prisma.$PlantillaMensajePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlantillaMensajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaMensajeCountArgs} args - Arguments to filter PlantillaMensajes to count.
     * @example
     * // Count the number of PlantillaMensajes
     * const count = await prisma.plantillaMensaje.count({
     *   where: {
     *     // ... the filter for the PlantillaMensajes we want to count
     *   }
     * })
    **/
    count<T extends PlantillaMensajeCountArgs>(
      args?: Subset<T, PlantillaMensajeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantillaMensajeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlantillaMensaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaMensajeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantillaMensajeAggregateArgs>(args: Subset<T, PlantillaMensajeAggregateArgs>): Prisma.PrismaPromise<GetPlantillaMensajeAggregateType<T>>

    /**
     * Group by PlantillaMensaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantillaMensajeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlantillaMensajeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlantillaMensajeGroupByArgs['orderBy'] }
        : { orderBy?: PlantillaMensajeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlantillaMensajeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantillaMensajeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlantillaMensaje model
   */
  readonly fields: PlantillaMensajeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlantillaMensaje.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlantillaMensajeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlantillaMensaje model
   */
  interface PlantillaMensajeFieldRefs {
    readonly id: FieldRef<"PlantillaMensaje", 'String'>
    readonly nombre: FieldRef<"PlantillaMensaje", 'String'>
    readonly contenido: FieldRef<"PlantillaMensaje", 'String'>
    readonly tipo: FieldRef<"PlantillaMensaje", 'String'>
    readonly idioma: FieldRef<"PlantillaMensaje", 'String'>
    readonly activa: FieldRef<"PlantillaMensaje", 'Boolean'>
    readonly createdAt: FieldRef<"PlantillaMensaje", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlantillaMensaje findUnique
   */
  export type PlantillaMensajeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * Filter, which PlantillaMensaje to fetch.
     */
    where: PlantillaMensajeWhereUniqueInput
  }

  /**
   * PlantillaMensaje findUniqueOrThrow
   */
  export type PlantillaMensajeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * Filter, which PlantillaMensaje to fetch.
     */
    where: PlantillaMensajeWhereUniqueInput
  }

  /**
   * PlantillaMensaje findFirst
   */
  export type PlantillaMensajeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * Filter, which PlantillaMensaje to fetch.
     */
    where?: PlantillaMensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantillaMensajes to fetch.
     */
    orderBy?: PlantillaMensajeOrderByWithRelationInput | PlantillaMensajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantillaMensajes.
     */
    cursor?: PlantillaMensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantillaMensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantillaMensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantillaMensajes.
     */
    distinct?: PlantillaMensajeScalarFieldEnum | PlantillaMensajeScalarFieldEnum[]
  }

  /**
   * PlantillaMensaje findFirstOrThrow
   */
  export type PlantillaMensajeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * Filter, which PlantillaMensaje to fetch.
     */
    where?: PlantillaMensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantillaMensajes to fetch.
     */
    orderBy?: PlantillaMensajeOrderByWithRelationInput | PlantillaMensajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlantillaMensajes.
     */
    cursor?: PlantillaMensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantillaMensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantillaMensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlantillaMensajes.
     */
    distinct?: PlantillaMensajeScalarFieldEnum | PlantillaMensajeScalarFieldEnum[]
  }

  /**
   * PlantillaMensaje findMany
   */
  export type PlantillaMensajeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * Filter, which PlantillaMensajes to fetch.
     */
    where?: PlantillaMensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlantillaMensajes to fetch.
     */
    orderBy?: PlantillaMensajeOrderByWithRelationInput | PlantillaMensajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlantillaMensajes.
     */
    cursor?: PlantillaMensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlantillaMensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlantillaMensajes.
     */
    skip?: number
    distinct?: PlantillaMensajeScalarFieldEnum | PlantillaMensajeScalarFieldEnum[]
  }

  /**
   * PlantillaMensaje create
   */
  export type PlantillaMensajeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * The data needed to create a PlantillaMensaje.
     */
    data: XOR<PlantillaMensajeCreateInput, PlantillaMensajeUncheckedCreateInput>
  }

  /**
   * PlantillaMensaje createMany
   */
  export type PlantillaMensajeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlantillaMensajes.
     */
    data: PlantillaMensajeCreateManyInput | PlantillaMensajeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantillaMensaje createManyAndReturn
   */
  export type PlantillaMensajeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * The data used to create many PlantillaMensajes.
     */
    data: PlantillaMensajeCreateManyInput | PlantillaMensajeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlantillaMensaje update
   */
  export type PlantillaMensajeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * The data needed to update a PlantillaMensaje.
     */
    data: XOR<PlantillaMensajeUpdateInput, PlantillaMensajeUncheckedUpdateInput>
    /**
     * Choose, which PlantillaMensaje to update.
     */
    where: PlantillaMensajeWhereUniqueInput
  }

  /**
   * PlantillaMensaje updateMany
   */
  export type PlantillaMensajeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlantillaMensajes.
     */
    data: XOR<PlantillaMensajeUpdateManyMutationInput, PlantillaMensajeUncheckedUpdateManyInput>
    /**
     * Filter which PlantillaMensajes to update
     */
    where?: PlantillaMensajeWhereInput
    /**
     * Limit how many PlantillaMensajes to update.
     */
    limit?: number
  }

  /**
   * PlantillaMensaje updateManyAndReturn
   */
  export type PlantillaMensajeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * The data used to update PlantillaMensajes.
     */
    data: XOR<PlantillaMensajeUpdateManyMutationInput, PlantillaMensajeUncheckedUpdateManyInput>
    /**
     * Filter which PlantillaMensajes to update
     */
    where?: PlantillaMensajeWhereInput
    /**
     * Limit how many PlantillaMensajes to update.
     */
    limit?: number
  }

  /**
   * PlantillaMensaje upsert
   */
  export type PlantillaMensajeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * The filter to search for the PlantillaMensaje to update in case it exists.
     */
    where: PlantillaMensajeWhereUniqueInput
    /**
     * In case the PlantillaMensaje found by the `where` argument doesn't exist, create a new PlantillaMensaje with this data.
     */
    create: XOR<PlantillaMensajeCreateInput, PlantillaMensajeUncheckedCreateInput>
    /**
     * In case the PlantillaMensaje was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlantillaMensajeUpdateInput, PlantillaMensajeUncheckedUpdateInput>
  }

  /**
   * PlantillaMensaje delete
   */
  export type PlantillaMensajeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
    /**
     * Filter which PlantillaMensaje to delete.
     */
    where: PlantillaMensajeWhereUniqueInput
  }

  /**
   * PlantillaMensaje deleteMany
   */
  export type PlantillaMensajeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlantillaMensajes to delete
     */
    where?: PlantillaMensajeWhereInput
    /**
     * Limit how many PlantillaMensajes to delete.
     */
    limit?: number
  }

  /**
   * PlantillaMensaje without action
   */
  export type PlantillaMensajeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantillaMensaje
     */
    select?: PlantillaMensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlantillaMensaje
     */
    omit?: PlantillaMensajeOmit<ExtArgs> | null
  }


  /**
   * Model Conversacion
   */

  export type AggregateConversacion = {
    _count: ConversacionCountAggregateOutputType | null
    _min: ConversacionMinAggregateOutputType | null
    _max: ConversacionMaxAggregateOutputType | null
  }

  export type ConversacionMinAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    temaLegal: string | null
    consultorio: string | null
    estado: string | null
    canal: string | null
    primerMensaje: string | null
    resumen: string | null
    createdAt: Date | null
  }

  export type ConversacionMaxAggregateOutputType = {
    id: string | null
    estudianteId: string | null
    temaLegal: string | null
    consultorio: string | null
    estado: string | null
    canal: string | null
    primerMensaje: string | null
    resumen: string | null
    createdAt: Date | null
  }

  export type ConversacionCountAggregateOutputType = {
    id: number
    estudianteId: number
    temaLegal: number
    consultorio: number
    estado: number
    canal: number
    primerMensaje: number
    resumen: number
    createdAt: number
    _all: number
  }


  export type ConversacionMinAggregateInputType = {
    id?: true
    estudianteId?: true
    temaLegal?: true
    consultorio?: true
    estado?: true
    canal?: true
    primerMensaje?: true
    resumen?: true
    createdAt?: true
  }

  export type ConversacionMaxAggregateInputType = {
    id?: true
    estudianteId?: true
    temaLegal?: true
    consultorio?: true
    estado?: true
    canal?: true
    primerMensaje?: true
    resumen?: true
    createdAt?: true
  }

  export type ConversacionCountAggregateInputType = {
    id?: true
    estudianteId?: true
    temaLegal?: true
    consultorio?: true
    estado?: true
    canal?: true
    primerMensaje?: true
    resumen?: true
    createdAt?: true
    _all?: true
  }

  export type ConversacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversacion to aggregate.
     */
    where?: ConversacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversacions to fetch.
     */
    orderBy?: ConversacionOrderByWithRelationInput | ConversacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversacions
    **/
    _count?: true | ConversacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversacionMaxAggregateInputType
  }

  export type GetConversacionAggregateType<T extends ConversacionAggregateArgs> = {
        [P in keyof T & keyof AggregateConversacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversacion[P]>
      : GetScalarType<T[P], AggregateConversacion[P]>
  }




  export type ConversacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversacionWhereInput
    orderBy?: ConversacionOrderByWithAggregationInput | ConversacionOrderByWithAggregationInput[]
    by: ConversacionScalarFieldEnum[] | ConversacionScalarFieldEnum
    having?: ConversacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversacionCountAggregateInputType | true
    _min?: ConversacionMinAggregateInputType
    _max?: ConversacionMaxAggregateInputType
  }

  export type ConversacionGroupByOutputType = {
    id: string
    estudianteId: string | null
    temaLegal: string
    consultorio: string | null
    estado: string
    canal: string
    primerMensaje: string | null
    resumen: string | null
    createdAt: Date
    _count: ConversacionCountAggregateOutputType | null
    _min: ConversacionMinAggregateOutputType | null
    _max: ConversacionMaxAggregateOutputType | null
  }

  type GetConversacionGroupByPayload<T extends ConversacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversacionGroupByOutputType[P]>
            : GetScalarType<T[P], ConversacionGroupByOutputType[P]>
        }
      >
    >


  export type ConversacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    temaLegal?: boolean
    consultorio?: boolean
    estado?: boolean
    canal?: boolean
    primerMensaje?: boolean
    resumen?: boolean
    createdAt?: boolean
    estudiante?: boolean | Conversacion$estudianteArgs<ExtArgs>
    citas?: boolean | Conversacion$citasArgs<ExtArgs>
    mensajes?: boolean | Conversacion$mensajesArgs<ExtArgs>
    asesoramiento?: boolean | Conversacion$asesoramientoArgs<ExtArgs>
    encuesta?: boolean | Conversacion$encuestaArgs<ExtArgs>
    _count?: boolean | ConversacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversacion"]>

  export type ConversacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    temaLegal?: boolean
    consultorio?: boolean
    estado?: boolean
    canal?: boolean
    primerMensaje?: boolean
    resumen?: boolean
    createdAt?: boolean
    estudiante?: boolean | Conversacion$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["conversacion"]>

  export type ConversacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estudianteId?: boolean
    temaLegal?: boolean
    consultorio?: boolean
    estado?: boolean
    canal?: boolean
    primerMensaje?: boolean
    resumen?: boolean
    createdAt?: boolean
    estudiante?: boolean | Conversacion$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["conversacion"]>

  export type ConversacionSelectScalar = {
    id?: boolean
    estudianteId?: boolean
    temaLegal?: boolean
    consultorio?: boolean
    estado?: boolean
    canal?: boolean
    primerMensaje?: boolean
    resumen?: boolean
    createdAt?: boolean
  }

  export type ConversacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estudianteId" | "temaLegal" | "consultorio" | "estado" | "canal" | "primerMensaje" | "resumen" | "createdAt", ExtArgs["result"]["conversacion"]>
  export type ConversacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | Conversacion$estudianteArgs<ExtArgs>
    citas?: boolean | Conversacion$citasArgs<ExtArgs>
    mensajes?: boolean | Conversacion$mensajesArgs<ExtArgs>
    asesoramiento?: boolean | Conversacion$asesoramientoArgs<ExtArgs>
    encuesta?: boolean | Conversacion$encuestaArgs<ExtArgs>
    _count?: boolean | ConversacionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | Conversacion$estudianteArgs<ExtArgs>
  }
  export type ConversacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiante?: boolean | Conversacion$estudianteArgs<ExtArgs>
  }

  export type $ConversacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversacion"
    objects: {
      estudiante: Prisma.$EstudiantePayload<ExtArgs> | null
      citas: Prisma.$CitaPayload<ExtArgs>[]
      mensajes: Prisma.$MensajePayload<ExtArgs>[]
      asesoramiento: Prisma.$AsesoramientoPayload<ExtArgs> | null
      encuesta: Prisma.$EncuestaSatisfaccionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      estudianteId: string | null
      temaLegal: string
      consultorio: string | null
      estado: string
      canal: string
      primerMensaje: string | null
      resumen: string | null
      createdAt: Date
    }, ExtArgs["result"]["conversacion"]>
    composites: {}
  }

  type ConversacionGetPayload<S extends boolean | null | undefined | ConversacionDefaultArgs> = $Result.GetResult<Prisma.$ConversacionPayload, S>

  type ConversacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversacionCountAggregateInputType | true
    }

  export interface ConversacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversacion'], meta: { name: 'Conversacion' } }
    /**
     * Find zero or one Conversacion that matches the filter.
     * @param {ConversacionFindUniqueArgs} args - Arguments to find a Conversacion
     * @example
     * // Get one Conversacion
     * const conversacion = await prisma.conversacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversacionFindUniqueArgs>(args: SelectSubset<T, ConversacionFindUniqueArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversacionFindUniqueOrThrowArgs} args - Arguments to find a Conversacion
     * @example
     * // Get one Conversacion
     * const conversacion = await prisma.conversacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversacionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversacionFindFirstArgs} args - Arguments to find a Conversacion
     * @example
     * // Get one Conversacion
     * const conversacion = await prisma.conversacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversacionFindFirstArgs>(args?: SelectSubset<T, ConversacionFindFirstArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversacionFindFirstOrThrowArgs} args - Arguments to find a Conversacion
     * @example
     * // Get one Conversacion
     * const conversacion = await prisma.conversacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversacionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversacions
     * const conversacions = await prisma.conversacion.findMany()
     * 
     * // Get first 10 Conversacions
     * const conversacions = await prisma.conversacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversacionWithIdOnly = await prisma.conversacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversacionFindManyArgs>(args?: SelectSubset<T, ConversacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversacion.
     * @param {ConversacionCreateArgs} args - Arguments to create a Conversacion.
     * @example
     * // Create one Conversacion
     * const Conversacion = await prisma.conversacion.create({
     *   data: {
     *     // ... data to create a Conversacion
     *   }
     * })
     * 
     */
    create<T extends ConversacionCreateArgs>(args: SelectSubset<T, ConversacionCreateArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversacions.
     * @param {ConversacionCreateManyArgs} args - Arguments to create many Conversacions.
     * @example
     * // Create many Conversacions
     * const conversacion = await prisma.conversacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversacionCreateManyArgs>(args?: SelectSubset<T, ConversacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversacions and returns the data saved in the database.
     * @param {ConversacionCreateManyAndReturnArgs} args - Arguments to create many Conversacions.
     * @example
     * // Create many Conversacions
     * const conversacion = await prisma.conversacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversacions and only return the `id`
     * const conversacionWithIdOnly = await prisma.conversacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversacionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversacion.
     * @param {ConversacionDeleteArgs} args - Arguments to delete one Conversacion.
     * @example
     * // Delete one Conversacion
     * const Conversacion = await prisma.conversacion.delete({
     *   where: {
     *     // ... filter to delete one Conversacion
     *   }
     * })
     * 
     */
    delete<T extends ConversacionDeleteArgs>(args: SelectSubset<T, ConversacionDeleteArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversacion.
     * @param {ConversacionUpdateArgs} args - Arguments to update one Conversacion.
     * @example
     * // Update one Conversacion
     * const conversacion = await prisma.conversacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversacionUpdateArgs>(args: SelectSubset<T, ConversacionUpdateArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversacions.
     * @param {ConversacionDeleteManyArgs} args - Arguments to filter Conversacions to delete.
     * @example
     * // Delete a few Conversacions
     * const { count } = await prisma.conversacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversacionDeleteManyArgs>(args?: SelectSubset<T, ConversacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversacions
     * const conversacion = await prisma.conversacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversacionUpdateManyArgs>(args: SelectSubset<T, ConversacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversacions and returns the data updated in the database.
     * @param {ConversacionUpdateManyAndReturnArgs} args - Arguments to update many Conversacions.
     * @example
     * // Update many Conversacions
     * const conversacion = await prisma.conversacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversacions and only return the `id`
     * const conversacionWithIdOnly = await prisma.conversacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversacionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversacion.
     * @param {ConversacionUpsertArgs} args - Arguments to update or create a Conversacion.
     * @example
     * // Update or create a Conversacion
     * const conversacion = await prisma.conversacion.upsert({
     *   create: {
     *     // ... data to create a Conversacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversacion we want to update
     *   }
     * })
     */
    upsert<T extends ConversacionUpsertArgs>(args: SelectSubset<T, ConversacionUpsertArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversacionCountArgs} args - Arguments to filter Conversacions to count.
     * @example
     * // Count the number of Conversacions
     * const count = await prisma.conversacion.count({
     *   where: {
     *     // ... the filter for the Conversacions we want to count
     *   }
     * })
    **/
    count<T extends ConversacionCountArgs>(
      args?: Subset<T, ConversacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversacionAggregateArgs>(args: Subset<T, ConversacionAggregateArgs>): Prisma.PrismaPromise<GetConversacionAggregateType<T>>

    /**
     * Group by Conversacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversacionGroupByArgs['orderBy'] }
        : { orderBy?: ConversacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversacion model
   */
  readonly fields: ConversacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiante<T extends Conversacion$estudianteArgs<ExtArgs> = {}>(args?: Subset<T, Conversacion$estudianteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    citas<T extends Conversacion$citasArgs<ExtArgs> = {}>(args?: Subset<T, Conversacion$citasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CitaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mensajes<T extends Conversacion$mensajesArgs<ExtArgs> = {}>(args?: Subset<T, Conversacion$mensajesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    asesoramiento<T extends Conversacion$asesoramientoArgs<ExtArgs> = {}>(args?: Subset<T, Conversacion$asesoramientoArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    encuesta<T extends Conversacion$encuestaArgs<ExtArgs> = {}>(args?: Subset<T, Conversacion$encuestaArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversacion model
   */
  interface ConversacionFieldRefs {
    readonly id: FieldRef<"Conversacion", 'String'>
    readonly estudianteId: FieldRef<"Conversacion", 'String'>
    readonly temaLegal: FieldRef<"Conversacion", 'String'>
    readonly consultorio: FieldRef<"Conversacion", 'String'>
    readonly estado: FieldRef<"Conversacion", 'String'>
    readonly canal: FieldRef<"Conversacion", 'String'>
    readonly primerMensaje: FieldRef<"Conversacion", 'String'>
    readonly resumen: FieldRef<"Conversacion", 'String'>
    readonly createdAt: FieldRef<"Conversacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversacion findUnique
   */
  export type ConversacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * Filter, which Conversacion to fetch.
     */
    where: ConversacionWhereUniqueInput
  }

  /**
   * Conversacion findUniqueOrThrow
   */
  export type ConversacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * Filter, which Conversacion to fetch.
     */
    where: ConversacionWhereUniqueInput
  }

  /**
   * Conversacion findFirst
   */
  export type ConversacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * Filter, which Conversacion to fetch.
     */
    where?: ConversacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversacions to fetch.
     */
    orderBy?: ConversacionOrderByWithRelationInput | ConversacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversacions.
     */
    cursor?: ConversacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversacions.
     */
    distinct?: ConversacionScalarFieldEnum | ConversacionScalarFieldEnum[]
  }

  /**
   * Conversacion findFirstOrThrow
   */
  export type ConversacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * Filter, which Conversacion to fetch.
     */
    where?: ConversacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversacions to fetch.
     */
    orderBy?: ConversacionOrderByWithRelationInput | ConversacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversacions.
     */
    cursor?: ConversacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversacions.
     */
    distinct?: ConversacionScalarFieldEnum | ConversacionScalarFieldEnum[]
  }

  /**
   * Conversacion findMany
   */
  export type ConversacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * Filter, which Conversacions to fetch.
     */
    where?: ConversacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversacions to fetch.
     */
    orderBy?: ConversacionOrderByWithRelationInput | ConversacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversacions.
     */
    cursor?: ConversacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversacions.
     */
    skip?: number
    distinct?: ConversacionScalarFieldEnum | ConversacionScalarFieldEnum[]
  }

  /**
   * Conversacion create
   */
  export type ConversacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversacion.
     */
    data: XOR<ConversacionCreateInput, ConversacionUncheckedCreateInput>
  }

  /**
   * Conversacion createMany
   */
  export type ConversacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversacions.
     */
    data: ConversacionCreateManyInput | ConversacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversacion createManyAndReturn
   */
  export type ConversacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * The data used to create many Conversacions.
     */
    data: ConversacionCreateManyInput | ConversacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversacion update
   */
  export type ConversacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversacion.
     */
    data: XOR<ConversacionUpdateInput, ConversacionUncheckedUpdateInput>
    /**
     * Choose, which Conversacion to update.
     */
    where: ConversacionWhereUniqueInput
  }

  /**
   * Conversacion updateMany
   */
  export type ConversacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversacions.
     */
    data: XOR<ConversacionUpdateManyMutationInput, ConversacionUncheckedUpdateManyInput>
    /**
     * Filter which Conversacions to update
     */
    where?: ConversacionWhereInput
    /**
     * Limit how many Conversacions to update.
     */
    limit?: number
  }

  /**
   * Conversacion updateManyAndReturn
   */
  export type ConversacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * The data used to update Conversacions.
     */
    data: XOR<ConversacionUpdateManyMutationInput, ConversacionUncheckedUpdateManyInput>
    /**
     * Filter which Conversacions to update
     */
    where?: ConversacionWhereInput
    /**
     * Limit how many Conversacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversacion upsert
   */
  export type ConversacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversacion to update in case it exists.
     */
    where: ConversacionWhereUniqueInput
    /**
     * In case the Conversacion found by the `where` argument doesn't exist, create a new Conversacion with this data.
     */
    create: XOR<ConversacionCreateInput, ConversacionUncheckedCreateInput>
    /**
     * In case the Conversacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversacionUpdateInput, ConversacionUncheckedUpdateInput>
  }

  /**
   * Conversacion delete
   */
  export type ConversacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    /**
     * Filter which Conversacion to delete.
     */
    where: ConversacionWhereUniqueInput
  }

  /**
   * Conversacion deleteMany
   */
  export type ConversacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversacions to delete
     */
    where?: ConversacionWhereInput
    /**
     * Limit how many Conversacions to delete.
     */
    limit?: number
  }

  /**
   * Conversacion.estudiante
   */
  export type Conversacion$estudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
  }

  /**
   * Conversacion.citas
   */
  export type Conversacion$citasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cita
     */
    select?: CitaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cita
     */
    omit?: CitaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CitaInclude<ExtArgs> | null
    where?: CitaWhereInput
    orderBy?: CitaOrderByWithRelationInput | CitaOrderByWithRelationInput[]
    cursor?: CitaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitaScalarFieldEnum | CitaScalarFieldEnum[]
  }

  /**
   * Conversacion.mensajes
   */
  export type Conversacion$mensajesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    where?: MensajeWhereInput
    orderBy?: MensajeOrderByWithRelationInput | MensajeOrderByWithRelationInput[]
    cursor?: MensajeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MensajeScalarFieldEnum | MensajeScalarFieldEnum[]
  }

  /**
   * Conversacion.asesoramiento
   */
  export type Conversacion$asesoramientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    where?: AsesoramientoWhereInput
  }

  /**
   * Conversacion.encuesta
   */
  export type Conversacion$encuestaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    where?: EncuestaSatisfaccionWhereInput
  }

  /**
   * Conversacion without action
   */
  export type ConversacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
  }


  /**
   * Model Mensaje
   */

  export type AggregateMensaje = {
    _count: MensajeCountAggregateOutputType | null
    _min: MensajeMinAggregateOutputType | null
    _max: MensajeMaxAggregateOutputType | null
  }

  export type MensajeMinAggregateOutputType = {
    id: string | null
    conversacionId: string | null
    tipo: string | null
    contenido: string | null
    createdAt: Date | null
  }

  export type MensajeMaxAggregateOutputType = {
    id: string | null
    conversacionId: string | null
    tipo: string | null
    contenido: string | null
    createdAt: Date | null
  }

  export type MensajeCountAggregateOutputType = {
    id: number
    conversacionId: number
    tipo: number
    contenido: number
    createdAt: number
    _all: number
  }


  export type MensajeMinAggregateInputType = {
    id?: true
    conversacionId?: true
    tipo?: true
    contenido?: true
    createdAt?: true
  }

  export type MensajeMaxAggregateInputType = {
    id?: true
    conversacionId?: true
    tipo?: true
    contenido?: true
    createdAt?: true
  }

  export type MensajeCountAggregateInputType = {
    id?: true
    conversacionId?: true
    tipo?: true
    contenido?: true
    createdAt?: true
    _all?: true
  }

  export type MensajeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mensaje to aggregate.
     */
    where?: MensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensajes to fetch.
     */
    orderBy?: MensajeOrderByWithRelationInput | MensajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mensajes
    **/
    _count?: true | MensajeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MensajeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MensajeMaxAggregateInputType
  }

  export type GetMensajeAggregateType<T extends MensajeAggregateArgs> = {
        [P in keyof T & keyof AggregateMensaje]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensaje[P]>
      : GetScalarType<T[P], AggregateMensaje[P]>
  }




  export type MensajeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensajeWhereInput
    orderBy?: MensajeOrderByWithAggregationInput | MensajeOrderByWithAggregationInput[]
    by: MensajeScalarFieldEnum[] | MensajeScalarFieldEnum
    having?: MensajeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MensajeCountAggregateInputType | true
    _min?: MensajeMinAggregateInputType
    _max?: MensajeMaxAggregateInputType
  }

  export type MensajeGroupByOutputType = {
    id: string
    conversacionId: string
    tipo: string
    contenido: string
    createdAt: Date
    _count: MensajeCountAggregateOutputType | null
    _min: MensajeMinAggregateOutputType | null
    _max: MensajeMaxAggregateOutputType | null
  }

  type GetMensajeGroupByPayload<T extends MensajeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MensajeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MensajeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MensajeGroupByOutputType[P]>
            : GetScalarType<T[P], MensajeGroupByOutputType[P]>
        }
      >
    >


  export type MensajeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    tipo?: boolean
    contenido?: boolean
    createdAt?: boolean
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensaje"]>

  export type MensajeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    tipo?: boolean
    contenido?: boolean
    createdAt?: boolean
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensaje"]>

  export type MensajeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    tipo?: boolean
    contenido?: boolean
    createdAt?: boolean
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensaje"]>

  export type MensajeSelectScalar = {
    id?: boolean
    conversacionId?: boolean
    tipo?: boolean
    contenido?: boolean
    createdAt?: boolean
  }

  export type MensajeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversacionId" | "tipo" | "contenido" | "createdAt", ExtArgs["result"]["mensaje"]>
  export type MensajeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
  }
  export type MensajeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
  }
  export type MensajeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
  }

  export type $MensajePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mensaje"
    objects: {
      conversacion: Prisma.$ConversacionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversacionId: string
      tipo: string
      contenido: string
      createdAt: Date
    }, ExtArgs["result"]["mensaje"]>
    composites: {}
  }

  type MensajeGetPayload<S extends boolean | null | undefined | MensajeDefaultArgs> = $Result.GetResult<Prisma.$MensajePayload, S>

  type MensajeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MensajeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MensajeCountAggregateInputType | true
    }

  export interface MensajeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mensaje'], meta: { name: 'Mensaje' } }
    /**
     * Find zero or one Mensaje that matches the filter.
     * @param {MensajeFindUniqueArgs} args - Arguments to find a Mensaje
     * @example
     * // Get one Mensaje
     * const mensaje = await prisma.mensaje.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MensajeFindUniqueArgs>(args: SelectSubset<T, MensajeFindUniqueArgs<ExtArgs>>): Prisma__MensajeClient<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mensaje that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MensajeFindUniqueOrThrowArgs} args - Arguments to find a Mensaje
     * @example
     * // Get one Mensaje
     * const mensaje = await prisma.mensaje.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MensajeFindUniqueOrThrowArgs>(args: SelectSubset<T, MensajeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MensajeClient<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mensaje that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeFindFirstArgs} args - Arguments to find a Mensaje
     * @example
     * // Get one Mensaje
     * const mensaje = await prisma.mensaje.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MensajeFindFirstArgs>(args?: SelectSubset<T, MensajeFindFirstArgs<ExtArgs>>): Prisma__MensajeClient<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mensaje that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeFindFirstOrThrowArgs} args - Arguments to find a Mensaje
     * @example
     * // Get one Mensaje
     * const mensaje = await prisma.mensaje.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MensajeFindFirstOrThrowArgs>(args?: SelectSubset<T, MensajeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MensajeClient<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mensajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mensajes
     * const mensajes = await prisma.mensaje.findMany()
     * 
     * // Get first 10 Mensajes
     * const mensajes = await prisma.mensaje.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensajeWithIdOnly = await prisma.mensaje.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MensajeFindManyArgs>(args?: SelectSubset<T, MensajeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mensaje.
     * @param {MensajeCreateArgs} args - Arguments to create a Mensaje.
     * @example
     * // Create one Mensaje
     * const Mensaje = await prisma.mensaje.create({
     *   data: {
     *     // ... data to create a Mensaje
     *   }
     * })
     * 
     */
    create<T extends MensajeCreateArgs>(args: SelectSubset<T, MensajeCreateArgs<ExtArgs>>): Prisma__MensajeClient<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mensajes.
     * @param {MensajeCreateManyArgs} args - Arguments to create many Mensajes.
     * @example
     * // Create many Mensajes
     * const mensaje = await prisma.mensaje.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MensajeCreateManyArgs>(args?: SelectSubset<T, MensajeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mensajes and returns the data saved in the database.
     * @param {MensajeCreateManyAndReturnArgs} args - Arguments to create many Mensajes.
     * @example
     * // Create many Mensajes
     * const mensaje = await prisma.mensaje.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mensajes and only return the `id`
     * const mensajeWithIdOnly = await prisma.mensaje.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MensajeCreateManyAndReturnArgs>(args?: SelectSubset<T, MensajeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mensaje.
     * @param {MensajeDeleteArgs} args - Arguments to delete one Mensaje.
     * @example
     * // Delete one Mensaje
     * const Mensaje = await prisma.mensaje.delete({
     *   where: {
     *     // ... filter to delete one Mensaje
     *   }
     * })
     * 
     */
    delete<T extends MensajeDeleteArgs>(args: SelectSubset<T, MensajeDeleteArgs<ExtArgs>>): Prisma__MensajeClient<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mensaje.
     * @param {MensajeUpdateArgs} args - Arguments to update one Mensaje.
     * @example
     * // Update one Mensaje
     * const mensaje = await prisma.mensaje.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MensajeUpdateArgs>(args: SelectSubset<T, MensajeUpdateArgs<ExtArgs>>): Prisma__MensajeClient<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mensajes.
     * @param {MensajeDeleteManyArgs} args - Arguments to filter Mensajes to delete.
     * @example
     * // Delete a few Mensajes
     * const { count } = await prisma.mensaje.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MensajeDeleteManyArgs>(args?: SelectSubset<T, MensajeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mensajes
     * const mensaje = await prisma.mensaje.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MensajeUpdateManyArgs>(args: SelectSubset<T, MensajeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensajes and returns the data updated in the database.
     * @param {MensajeUpdateManyAndReturnArgs} args - Arguments to update many Mensajes.
     * @example
     * // Update many Mensajes
     * const mensaje = await prisma.mensaje.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mensajes and only return the `id`
     * const mensajeWithIdOnly = await prisma.mensaje.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MensajeUpdateManyAndReturnArgs>(args: SelectSubset<T, MensajeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mensaje.
     * @param {MensajeUpsertArgs} args - Arguments to update or create a Mensaje.
     * @example
     * // Update or create a Mensaje
     * const mensaje = await prisma.mensaje.upsert({
     *   create: {
     *     // ... data to create a Mensaje
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mensaje we want to update
     *   }
     * })
     */
    upsert<T extends MensajeUpsertArgs>(args: SelectSubset<T, MensajeUpsertArgs<ExtArgs>>): Prisma__MensajeClient<$Result.GetResult<Prisma.$MensajePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mensajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeCountArgs} args - Arguments to filter Mensajes to count.
     * @example
     * // Count the number of Mensajes
     * const count = await prisma.mensaje.count({
     *   where: {
     *     // ... the filter for the Mensajes we want to count
     *   }
     * })
    **/
    count<T extends MensajeCountArgs>(
      args?: Subset<T, MensajeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MensajeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mensaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MensajeAggregateArgs>(args: Subset<T, MensajeAggregateArgs>): Prisma.PrismaPromise<GetMensajeAggregateType<T>>

    /**
     * Group by Mensaje.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensajeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MensajeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MensajeGroupByArgs['orderBy'] }
        : { orderBy?: MensajeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MensajeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensajeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mensaje model
   */
  readonly fields: MensajeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mensaje.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MensajeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversacion<T extends ConversacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversacionDefaultArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mensaje model
   */
  interface MensajeFieldRefs {
    readonly id: FieldRef<"Mensaje", 'String'>
    readonly conversacionId: FieldRef<"Mensaje", 'String'>
    readonly tipo: FieldRef<"Mensaje", 'String'>
    readonly contenido: FieldRef<"Mensaje", 'String'>
    readonly createdAt: FieldRef<"Mensaje", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mensaje findUnique
   */
  export type MensajeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensaje to fetch.
     */
    where: MensajeWhereUniqueInput
  }

  /**
   * Mensaje findUniqueOrThrow
   */
  export type MensajeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensaje to fetch.
     */
    where: MensajeWhereUniqueInput
  }

  /**
   * Mensaje findFirst
   */
  export type MensajeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensaje to fetch.
     */
    where?: MensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensajes to fetch.
     */
    orderBy?: MensajeOrderByWithRelationInput | MensajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mensajes.
     */
    cursor?: MensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mensajes.
     */
    distinct?: MensajeScalarFieldEnum | MensajeScalarFieldEnum[]
  }

  /**
   * Mensaje findFirstOrThrow
   */
  export type MensajeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensaje to fetch.
     */
    where?: MensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensajes to fetch.
     */
    orderBy?: MensajeOrderByWithRelationInput | MensajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mensajes.
     */
    cursor?: MensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mensajes.
     */
    distinct?: MensajeScalarFieldEnum | MensajeScalarFieldEnum[]
  }

  /**
   * Mensaje findMany
   */
  export type MensajeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter, which Mensajes to fetch.
     */
    where?: MensajeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensajes to fetch.
     */
    orderBy?: MensajeOrderByWithRelationInput | MensajeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mensajes.
     */
    cursor?: MensajeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensajes.
     */
    skip?: number
    distinct?: MensajeScalarFieldEnum | MensajeScalarFieldEnum[]
  }

  /**
   * Mensaje create
   */
  export type MensajeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * The data needed to create a Mensaje.
     */
    data: XOR<MensajeCreateInput, MensajeUncheckedCreateInput>
  }

  /**
   * Mensaje createMany
   */
  export type MensajeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mensajes.
     */
    data: MensajeCreateManyInput | MensajeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mensaje createManyAndReturn
   */
  export type MensajeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * The data used to create many Mensajes.
     */
    data: MensajeCreateManyInput | MensajeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mensaje update
   */
  export type MensajeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * The data needed to update a Mensaje.
     */
    data: XOR<MensajeUpdateInput, MensajeUncheckedUpdateInput>
    /**
     * Choose, which Mensaje to update.
     */
    where: MensajeWhereUniqueInput
  }

  /**
   * Mensaje updateMany
   */
  export type MensajeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mensajes.
     */
    data: XOR<MensajeUpdateManyMutationInput, MensajeUncheckedUpdateManyInput>
    /**
     * Filter which Mensajes to update
     */
    where?: MensajeWhereInput
    /**
     * Limit how many Mensajes to update.
     */
    limit?: number
  }

  /**
   * Mensaje updateManyAndReturn
   */
  export type MensajeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * The data used to update Mensajes.
     */
    data: XOR<MensajeUpdateManyMutationInput, MensajeUncheckedUpdateManyInput>
    /**
     * Filter which Mensajes to update
     */
    where?: MensajeWhereInput
    /**
     * Limit how many Mensajes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mensaje upsert
   */
  export type MensajeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * The filter to search for the Mensaje to update in case it exists.
     */
    where: MensajeWhereUniqueInput
    /**
     * In case the Mensaje found by the `where` argument doesn't exist, create a new Mensaje with this data.
     */
    create: XOR<MensajeCreateInput, MensajeUncheckedCreateInput>
    /**
     * In case the Mensaje was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MensajeUpdateInput, MensajeUncheckedUpdateInput>
  }

  /**
   * Mensaje delete
   */
  export type MensajeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
    /**
     * Filter which Mensaje to delete.
     */
    where: MensajeWhereUniqueInput
  }

  /**
   * Mensaje deleteMany
   */
  export type MensajeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mensajes to delete
     */
    where?: MensajeWhereInput
    /**
     * Limit how many Mensajes to delete.
     */
    limit?: number
  }

  /**
   * Mensaje without action
   */
  export type MensajeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensaje
     */
    select?: MensajeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensaje
     */
    omit?: MensajeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensajeInclude<ExtArgs> | null
  }


  /**
   * Model Asesoramiento
   */

  export type AggregateAsesoramiento = {
    _count: AsesoramientoCountAggregateOutputType | null
    _avg: AsesoramientoAvgAggregateOutputType | null
    _sum: AsesoramientoSumAggregateOutputType | null
    _min: AsesoramientoMinAggregateOutputType | null
    _max: AsesoramientoMaxAggregateOutputType | null
  }

  export type AsesoramientoAvgAggregateOutputType = {
    duracionMinutos: number | null
  }

  export type AsesoramientoSumAggregateOutputType = {
    duracionMinutos: number | null
  }

  export type AsesoramientoMinAggregateOutputType = {
    id: string | null
    conversacionId: string | null
    estudianteId: string | null
    temaLegal: string | null
    resumen: string | null
    duracionMinutos: number | null
    createdAt: Date | null
  }

  export type AsesoramientoMaxAggregateOutputType = {
    id: string | null
    conversacionId: string | null
    estudianteId: string | null
    temaLegal: string | null
    resumen: string | null
    duracionMinutos: number | null
    createdAt: Date | null
  }

  export type AsesoramientoCountAggregateOutputType = {
    id: number
    conversacionId: number
    estudianteId: number
    temaLegal: number
    resumen: number
    duracionMinutos: number
    createdAt: number
    _all: number
  }


  export type AsesoramientoAvgAggregateInputType = {
    duracionMinutos?: true
  }

  export type AsesoramientoSumAggregateInputType = {
    duracionMinutos?: true
  }

  export type AsesoramientoMinAggregateInputType = {
    id?: true
    conversacionId?: true
    estudianteId?: true
    temaLegal?: true
    resumen?: true
    duracionMinutos?: true
    createdAt?: true
  }

  export type AsesoramientoMaxAggregateInputType = {
    id?: true
    conversacionId?: true
    estudianteId?: true
    temaLegal?: true
    resumen?: true
    duracionMinutos?: true
    createdAt?: true
  }

  export type AsesoramientoCountAggregateInputType = {
    id?: true
    conversacionId?: true
    estudianteId?: true
    temaLegal?: true
    resumen?: true
    duracionMinutos?: true
    createdAt?: true
    _all?: true
  }

  export type AsesoramientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asesoramiento to aggregate.
     */
    where?: AsesoramientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Asesoramientos to fetch.
     */
    orderBy?: AsesoramientoOrderByWithRelationInput | AsesoramientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AsesoramientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Asesoramientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Asesoramientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Asesoramientos
    **/
    _count?: true | AsesoramientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AsesoramientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AsesoramientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AsesoramientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AsesoramientoMaxAggregateInputType
  }

  export type GetAsesoramientoAggregateType<T extends AsesoramientoAggregateArgs> = {
        [P in keyof T & keyof AggregateAsesoramiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsesoramiento[P]>
      : GetScalarType<T[P], AggregateAsesoramiento[P]>
  }




  export type AsesoramientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AsesoramientoWhereInput
    orderBy?: AsesoramientoOrderByWithAggregationInput | AsesoramientoOrderByWithAggregationInput[]
    by: AsesoramientoScalarFieldEnum[] | AsesoramientoScalarFieldEnum
    having?: AsesoramientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AsesoramientoCountAggregateInputType | true
    _avg?: AsesoramientoAvgAggregateInputType
    _sum?: AsesoramientoSumAggregateInputType
    _min?: AsesoramientoMinAggregateInputType
    _max?: AsesoramientoMaxAggregateInputType
  }

  export type AsesoramientoGroupByOutputType = {
    id: string
    conversacionId: string
    estudianteId: string | null
    temaLegal: string
    resumen: string | null
    duracionMinutos: number | null
    createdAt: Date
    _count: AsesoramientoCountAggregateOutputType | null
    _avg: AsesoramientoAvgAggregateOutputType | null
    _sum: AsesoramientoSumAggregateOutputType | null
    _min: AsesoramientoMinAggregateOutputType | null
    _max: AsesoramientoMaxAggregateOutputType | null
  }

  type GetAsesoramientoGroupByPayload<T extends AsesoramientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AsesoramientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AsesoramientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AsesoramientoGroupByOutputType[P]>
            : GetScalarType<T[P], AsesoramientoGroupByOutputType[P]>
        }
      >
    >


  export type AsesoramientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    estudianteId?: boolean
    temaLegal?: boolean
    resumen?: boolean
    duracionMinutos?: boolean
    createdAt?: boolean
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
    estudiante?: boolean | Asesoramiento$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["asesoramiento"]>

  export type AsesoramientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    estudianteId?: boolean
    temaLegal?: boolean
    resumen?: boolean
    duracionMinutos?: boolean
    createdAt?: boolean
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
    estudiante?: boolean | Asesoramiento$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["asesoramiento"]>

  export type AsesoramientoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    estudianteId?: boolean
    temaLegal?: boolean
    resumen?: boolean
    duracionMinutos?: boolean
    createdAt?: boolean
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
    estudiante?: boolean | Asesoramiento$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["asesoramiento"]>

  export type AsesoramientoSelectScalar = {
    id?: boolean
    conversacionId?: boolean
    estudianteId?: boolean
    temaLegal?: boolean
    resumen?: boolean
    duracionMinutos?: boolean
    createdAt?: boolean
  }

  export type AsesoramientoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversacionId" | "estudianteId" | "temaLegal" | "resumen" | "duracionMinutos" | "createdAt", ExtArgs["result"]["asesoramiento"]>
  export type AsesoramientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
    estudiante?: boolean | Asesoramiento$estudianteArgs<ExtArgs>
  }
  export type AsesoramientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
    estudiante?: boolean | Asesoramiento$estudianteArgs<ExtArgs>
  }
  export type AsesoramientoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | ConversacionDefaultArgs<ExtArgs>
    estudiante?: boolean | Asesoramiento$estudianteArgs<ExtArgs>
  }

  export type $AsesoramientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asesoramiento"
    objects: {
      conversacion: Prisma.$ConversacionPayload<ExtArgs>
      estudiante: Prisma.$EstudiantePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversacionId: string
      estudianteId: string | null
      temaLegal: string
      resumen: string | null
      duracionMinutos: number | null
      createdAt: Date
    }, ExtArgs["result"]["asesoramiento"]>
    composites: {}
  }

  type AsesoramientoGetPayload<S extends boolean | null | undefined | AsesoramientoDefaultArgs> = $Result.GetResult<Prisma.$AsesoramientoPayload, S>

  type AsesoramientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AsesoramientoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AsesoramientoCountAggregateInputType | true
    }

  export interface AsesoramientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asesoramiento'], meta: { name: 'Asesoramiento' } }
    /**
     * Find zero or one Asesoramiento that matches the filter.
     * @param {AsesoramientoFindUniqueArgs} args - Arguments to find a Asesoramiento
     * @example
     * // Get one Asesoramiento
     * const asesoramiento = await prisma.asesoramiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AsesoramientoFindUniqueArgs>(args: SelectSubset<T, AsesoramientoFindUniqueArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asesoramiento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AsesoramientoFindUniqueOrThrowArgs} args - Arguments to find a Asesoramiento
     * @example
     * // Get one Asesoramiento
     * const asesoramiento = await prisma.asesoramiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AsesoramientoFindUniqueOrThrowArgs>(args: SelectSubset<T, AsesoramientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asesoramiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsesoramientoFindFirstArgs} args - Arguments to find a Asesoramiento
     * @example
     * // Get one Asesoramiento
     * const asesoramiento = await prisma.asesoramiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AsesoramientoFindFirstArgs>(args?: SelectSubset<T, AsesoramientoFindFirstArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asesoramiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsesoramientoFindFirstOrThrowArgs} args - Arguments to find a Asesoramiento
     * @example
     * // Get one Asesoramiento
     * const asesoramiento = await prisma.asesoramiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AsesoramientoFindFirstOrThrowArgs>(args?: SelectSubset<T, AsesoramientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Asesoramientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsesoramientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Asesoramientos
     * const asesoramientos = await prisma.asesoramiento.findMany()
     * 
     * // Get first 10 Asesoramientos
     * const asesoramientos = await prisma.asesoramiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const asesoramientoWithIdOnly = await prisma.asesoramiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AsesoramientoFindManyArgs>(args?: SelectSubset<T, AsesoramientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asesoramiento.
     * @param {AsesoramientoCreateArgs} args - Arguments to create a Asesoramiento.
     * @example
     * // Create one Asesoramiento
     * const Asesoramiento = await prisma.asesoramiento.create({
     *   data: {
     *     // ... data to create a Asesoramiento
     *   }
     * })
     * 
     */
    create<T extends AsesoramientoCreateArgs>(args: SelectSubset<T, AsesoramientoCreateArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Asesoramientos.
     * @param {AsesoramientoCreateManyArgs} args - Arguments to create many Asesoramientos.
     * @example
     * // Create many Asesoramientos
     * const asesoramiento = await prisma.asesoramiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AsesoramientoCreateManyArgs>(args?: SelectSubset<T, AsesoramientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Asesoramientos and returns the data saved in the database.
     * @param {AsesoramientoCreateManyAndReturnArgs} args - Arguments to create many Asesoramientos.
     * @example
     * // Create many Asesoramientos
     * const asesoramiento = await prisma.asesoramiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Asesoramientos and only return the `id`
     * const asesoramientoWithIdOnly = await prisma.asesoramiento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AsesoramientoCreateManyAndReturnArgs>(args?: SelectSubset<T, AsesoramientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Asesoramiento.
     * @param {AsesoramientoDeleteArgs} args - Arguments to delete one Asesoramiento.
     * @example
     * // Delete one Asesoramiento
     * const Asesoramiento = await prisma.asesoramiento.delete({
     *   where: {
     *     // ... filter to delete one Asesoramiento
     *   }
     * })
     * 
     */
    delete<T extends AsesoramientoDeleteArgs>(args: SelectSubset<T, AsesoramientoDeleteArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asesoramiento.
     * @param {AsesoramientoUpdateArgs} args - Arguments to update one Asesoramiento.
     * @example
     * // Update one Asesoramiento
     * const asesoramiento = await prisma.asesoramiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AsesoramientoUpdateArgs>(args: SelectSubset<T, AsesoramientoUpdateArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Asesoramientos.
     * @param {AsesoramientoDeleteManyArgs} args - Arguments to filter Asesoramientos to delete.
     * @example
     * // Delete a few Asesoramientos
     * const { count } = await prisma.asesoramiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AsesoramientoDeleteManyArgs>(args?: SelectSubset<T, AsesoramientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Asesoramientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsesoramientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Asesoramientos
     * const asesoramiento = await prisma.asesoramiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AsesoramientoUpdateManyArgs>(args: SelectSubset<T, AsesoramientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Asesoramientos and returns the data updated in the database.
     * @param {AsesoramientoUpdateManyAndReturnArgs} args - Arguments to update many Asesoramientos.
     * @example
     * // Update many Asesoramientos
     * const asesoramiento = await prisma.asesoramiento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Asesoramientos and only return the `id`
     * const asesoramientoWithIdOnly = await prisma.asesoramiento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AsesoramientoUpdateManyAndReturnArgs>(args: SelectSubset<T, AsesoramientoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Asesoramiento.
     * @param {AsesoramientoUpsertArgs} args - Arguments to update or create a Asesoramiento.
     * @example
     * // Update or create a Asesoramiento
     * const asesoramiento = await prisma.asesoramiento.upsert({
     *   create: {
     *     // ... data to create a Asesoramiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asesoramiento we want to update
     *   }
     * })
     */
    upsert<T extends AsesoramientoUpsertArgs>(args: SelectSubset<T, AsesoramientoUpsertArgs<ExtArgs>>): Prisma__AsesoramientoClient<$Result.GetResult<Prisma.$AsesoramientoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Asesoramientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsesoramientoCountArgs} args - Arguments to filter Asesoramientos to count.
     * @example
     * // Count the number of Asesoramientos
     * const count = await prisma.asesoramiento.count({
     *   where: {
     *     // ... the filter for the Asesoramientos we want to count
     *   }
     * })
    **/
    count<T extends AsesoramientoCountArgs>(
      args?: Subset<T, AsesoramientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AsesoramientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asesoramiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsesoramientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AsesoramientoAggregateArgs>(args: Subset<T, AsesoramientoAggregateArgs>): Prisma.PrismaPromise<GetAsesoramientoAggregateType<T>>

    /**
     * Group by Asesoramiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsesoramientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AsesoramientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AsesoramientoGroupByArgs['orderBy'] }
        : { orderBy?: AsesoramientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AsesoramientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAsesoramientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asesoramiento model
   */
  readonly fields: AsesoramientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asesoramiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AsesoramientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversacion<T extends ConversacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversacionDefaultArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    estudiante<T extends Asesoramiento$estudianteArgs<ExtArgs> = {}>(args?: Subset<T, Asesoramiento$estudianteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asesoramiento model
   */
  interface AsesoramientoFieldRefs {
    readonly id: FieldRef<"Asesoramiento", 'String'>
    readonly conversacionId: FieldRef<"Asesoramiento", 'String'>
    readonly estudianteId: FieldRef<"Asesoramiento", 'String'>
    readonly temaLegal: FieldRef<"Asesoramiento", 'String'>
    readonly resumen: FieldRef<"Asesoramiento", 'String'>
    readonly duracionMinutos: FieldRef<"Asesoramiento", 'Int'>
    readonly createdAt: FieldRef<"Asesoramiento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asesoramiento findUnique
   */
  export type AsesoramientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * Filter, which Asesoramiento to fetch.
     */
    where: AsesoramientoWhereUniqueInput
  }

  /**
   * Asesoramiento findUniqueOrThrow
   */
  export type AsesoramientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * Filter, which Asesoramiento to fetch.
     */
    where: AsesoramientoWhereUniqueInput
  }

  /**
   * Asesoramiento findFirst
   */
  export type AsesoramientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * Filter, which Asesoramiento to fetch.
     */
    where?: AsesoramientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Asesoramientos to fetch.
     */
    orderBy?: AsesoramientoOrderByWithRelationInput | AsesoramientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Asesoramientos.
     */
    cursor?: AsesoramientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Asesoramientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Asesoramientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Asesoramientos.
     */
    distinct?: AsesoramientoScalarFieldEnum | AsesoramientoScalarFieldEnum[]
  }

  /**
   * Asesoramiento findFirstOrThrow
   */
  export type AsesoramientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * Filter, which Asesoramiento to fetch.
     */
    where?: AsesoramientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Asesoramientos to fetch.
     */
    orderBy?: AsesoramientoOrderByWithRelationInput | AsesoramientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Asesoramientos.
     */
    cursor?: AsesoramientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Asesoramientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Asesoramientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Asesoramientos.
     */
    distinct?: AsesoramientoScalarFieldEnum | AsesoramientoScalarFieldEnum[]
  }

  /**
   * Asesoramiento findMany
   */
  export type AsesoramientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * Filter, which Asesoramientos to fetch.
     */
    where?: AsesoramientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Asesoramientos to fetch.
     */
    orderBy?: AsesoramientoOrderByWithRelationInput | AsesoramientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Asesoramientos.
     */
    cursor?: AsesoramientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Asesoramientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Asesoramientos.
     */
    skip?: number
    distinct?: AsesoramientoScalarFieldEnum | AsesoramientoScalarFieldEnum[]
  }

  /**
   * Asesoramiento create
   */
  export type AsesoramientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Asesoramiento.
     */
    data: XOR<AsesoramientoCreateInput, AsesoramientoUncheckedCreateInput>
  }

  /**
   * Asesoramiento createMany
   */
  export type AsesoramientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Asesoramientos.
     */
    data: AsesoramientoCreateManyInput | AsesoramientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asesoramiento createManyAndReturn
   */
  export type AsesoramientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * The data used to create many Asesoramientos.
     */
    data: AsesoramientoCreateManyInput | AsesoramientoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asesoramiento update
   */
  export type AsesoramientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Asesoramiento.
     */
    data: XOR<AsesoramientoUpdateInput, AsesoramientoUncheckedUpdateInput>
    /**
     * Choose, which Asesoramiento to update.
     */
    where: AsesoramientoWhereUniqueInput
  }

  /**
   * Asesoramiento updateMany
   */
  export type AsesoramientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Asesoramientos.
     */
    data: XOR<AsesoramientoUpdateManyMutationInput, AsesoramientoUncheckedUpdateManyInput>
    /**
     * Filter which Asesoramientos to update
     */
    where?: AsesoramientoWhereInput
    /**
     * Limit how many Asesoramientos to update.
     */
    limit?: number
  }

  /**
   * Asesoramiento updateManyAndReturn
   */
  export type AsesoramientoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * The data used to update Asesoramientos.
     */
    data: XOR<AsesoramientoUpdateManyMutationInput, AsesoramientoUncheckedUpdateManyInput>
    /**
     * Filter which Asesoramientos to update
     */
    where?: AsesoramientoWhereInput
    /**
     * Limit how many Asesoramientos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asesoramiento upsert
   */
  export type AsesoramientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Asesoramiento to update in case it exists.
     */
    where: AsesoramientoWhereUniqueInput
    /**
     * In case the Asesoramiento found by the `where` argument doesn't exist, create a new Asesoramiento with this data.
     */
    create: XOR<AsesoramientoCreateInput, AsesoramientoUncheckedCreateInput>
    /**
     * In case the Asesoramiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AsesoramientoUpdateInput, AsesoramientoUncheckedUpdateInput>
  }

  /**
   * Asesoramiento delete
   */
  export type AsesoramientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
    /**
     * Filter which Asesoramiento to delete.
     */
    where: AsesoramientoWhereUniqueInput
  }

  /**
   * Asesoramiento deleteMany
   */
  export type AsesoramientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asesoramientos to delete
     */
    where?: AsesoramientoWhereInput
    /**
     * Limit how many Asesoramientos to delete.
     */
    limit?: number
  }

  /**
   * Asesoramiento.estudiante
   */
  export type Asesoramiento$estudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
  }

  /**
   * Asesoramiento without action
   */
  export type AsesoramientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asesoramiento
     */
    select?: AsesoramientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asesoramiento
     */
    omit?: AsesoramientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AsesoramientoInclude<ExtArgs> | null
  }


  /**
   * Model EncuestaSatisfaccion
   */

  export type AggregateEncuestaSatisfaccion = {
    _count: EncuestaSatisfaccionCountAggregateOutputType | null
    _avg: EncuestaSatisfaccionAvgAggregateOutputType | null
    _sum: EncuestaSatisfaccionSumAggregateOutputType | null
    _min: EncuestaSatisfaccionMinAggregateOutputType | null
    _max: EncuestaSatisfaccionMaxAggregateOutputType | null
  }

  export type EncuestaSatisfaccionAvgAggregateOutputType = {
    calificacion: number | null
  }

  export type EncuestaSatisfaccionSumAggregateOutputType = {
    calificacion: number | null
  }

  export type EncuestaSatisfaccionMinAggregateOutputType = {
    id: string | null
    conversacionId: string | null
    estudianteId: string | null
    calificacion: number | null
    comentario: string | null
    respondida: boolean | null
    fuente: string | null
    createdAt: Date | null
  }

  export type EncuestaSatisfaccionMaxAggregateOutputType = {
    id: string | null
    conversacionId: string | null
    estudianteId: string | null
    calificacion: number | null
    comentario: string | null
    respondida: boolean | null
    fuente: string | null
    createdAt: Date | null
  }

  export type EncuestaSatisfaccionCountAggregateOutputType = {
    id: number
    conversacionId: number
    estudianteId: number
    calificacion: number
    comentario: number
    respondida: number
    fuente: number
    createdAt: number
    _all: number
  }


  export type EncuestaSatisfaccionAvgAggregateInputType = {
    calificacion?: true
  }

  export type EncuestaSatisfaccionSumAggregateInputType = {
    calificacion?: true
  }

  export type EncuestaSatisfaccionMinAggregateInputType = {
    id?: true
    conversacionId?: true
    estudianteId?: true
    calificacion?: true
    comentario?: true
    respondida?: true
    fuente?: true
    createdAt?: true
  }

  export type EncuestaSatisfaccionMaxAggregateInputType = {
    id?: true
    conversacionId?: true
    estudianteId?: true
    calificacion?: true
    comentario?: true
    respondida?: true
    fuente?: true
    createdAt?: true
  }

  export type EncuestaSatisfaccionCountAggregateInputType = {
    id?: true
    conversacionId?: true
    estudianteId?: true
    calificacion?: true
    comentario?: true
    respondida?: true
    fuente?: true
    createdAt?: true
    _all?: true
  }

  export type EncuestaSatisfaccionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncuestaSatisfaccion to aggregate.
     */
    where?: EncuestaSatisfaccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncuestaSatisfaccions to fetch.
     */
    orderBy?: EncuestaSatisfaccionOrderByWithRelationInput | EncuestaSatisfaccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncuestaSatisfaccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncuestaSatisfaccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncuestaSatisfaccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncuestaSatisfaccions
    **/
    _count?: true | EncuestaSatisfaccionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncuestaSatisfaccionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncuestaSatisfaccionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncuestaSatisfaccionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncuestaSatisfaccionMaxAggregateInputType
  }

  export type GetEncuestaSatisfaccionAggregateType<T extends EncuestaSatisfaccionAggregateArgs> = {
        [P in keyof T & keyof AggregateEncuestaSatisfaccion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncuestaSatisfaccion[P]>
      : GetScalarType<T[P], AggregateEncuestaSatisfaccion[P]>
  }




  export type EncuestaSatisfaccionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncuestaSatisfaccionWhereInput
    orderBy?: EncuestaSatisfaccionOrderByWithAggregationInput | EncuestaSatisfaccionOrderByWithAggregationInput[]
    by: EncuestaSatisfaccionScalarFieldEnum[] | EncuestaSatisfaccionScalarFieldEnum
    having?: EncuestaSatisfaccionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncuestaSatisfaccionCountAggregateInputType | true
    _avg?: EncuestaSatisfaccionAvgAggregateInputType
    _sum?: EncuestaSatisfaccionSumAggregateInputType
    _min?: EncuestaSatisfaccionMinAggregateInputType
    _max?: EncuestaSatisfaccionMaxAggregateInputType
  }

  export type EncuestaSatisfaccionGroupByOutputType = {
    id: string
    conversacionId: string | null
    estudianteId: string | null
    calificacion: number
    comentario: string | null
    respondida: boolean
    fuente: string
    createdAt: Date
    _count: EncuestaSatisfaccionCountAggregateOutputType | null
    _avg: EncuestaSatisfaccionAvgAggregateOutputType | null
    _sum: EncuestaSatisfaccionSumAggregateOutputType | null
    _min: EncuestaSatisfaccionMinAggregateOutputType | null
    _max: EncuestaSatisfaccionMaxAggregateOutputType | null
  }

  type GetEncuestaSatisfaccionGroupByPayload<T extends EncuestaSatisfaccionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncuestaSatisfaccionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncuestaSatisfaccionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncuestaSatisfaccionGroupByOutputType[P]>
            : GetScalarType<T[P], EncuestaSatisfaccionGroupByOutputType[P]>
        }
      >
    >


  export type EncuestaSatisfaccionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    estudianteId?: boolean
    calificacion?: boolean
    comentario?: boolean
    respondida?: boolean
    fuente?: boolean
    createdAt?: boolean
    conversacion?: boolean | EncuestaSatisfaccion$conversacionArgs<ExtArgs>
    estudiante?: boolean | EncuestaSatisfaccion$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["encuestaSatisfaccion"]>

  export type EncuestaSatisfaccionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    estudianteId?: boolean
    calificacion?: boolean
    comentario?: boolean
    respondida?: boolean
    fuente?: boolean
    createdAt?: boolean
    conversacion?: boolean | EncuestaSatisfaccion$conversacionArgs<ExtArgs>
    estudiante?: boolean | EncuestaSatisfaccion$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["encuestaSatisfaccion"]>

  export type EncuestaSatisfaccionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversacionId?: boolean
    estudianteId?: boolean
    calificacion?: boolean
    comentario?: boolean
    respondida?: boolean
    fuente?: boolean
    createdAt?: boolean
    conversacion?: boolean | EncuestaSatisfaccion$conversacionArgs<ExtArgs>
    estudiante?: boolean | EncuestaSatisfaccion$estudianteArgs<ExtArgs>
  }, ExtArgs["result"]["encuestaSatisfaccion"]>

  export type EncuestaSatisfaccionSelectScalar = {
    id?: boolean
    conversacionId?: boolean
    estudianteId?: boolean
    calificacion?: boolean
    comentario?: boolean
    respondida?: boolean
    fuente?: boolean
    createdAt?: boolean
  }

  export type EncuestaSatisfaccionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversacionId" | "estudianteId" | "calificacion" | "comentario" | "respondida" | "fuente" | "createdAt", ExtArgs["result"]["encuestaSatisfaccion"]>
  export type EncuestaSatisfaccionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | EncuestaSatisfaccion$conversacionArgs<ExtArgs>
    estudiante?: boolean | EncuestaSatisfaccion$estudianteArgs<ExtArgs>
  }
  export type EncuestaSatisfaccionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | EncuestaSatisfaccion$conversacionArgs<ExtArgs>
    estudiante?: boolean | EncuestaSatisfaccion$estudianteArgs<ExtArgs>
  }
  export type EncuestaSatisfaccionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversacion?: boolean | EncuestaSatisfaccion$conversacionArgs<ExtArgs>
    estudiante?: boolean | EncuestaSatisfaccion$estudianteArgs<ExtArgs>
  }

  export type $EncuestaSatisfaccionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncuestaSatisfaccion"
    objects: {
      conversacion: Prisma.$ConversacionPayload<ExtArgs> | null
      estudiante: Prisma.$EstudiantePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversacionId: string | null
      estudianteId: string | null
      calificacion: number
      comentario: string | null
      respondida: boolean
      fuente: string
      createdAt: Date
    }, ExtArgs["result"]["encuestaSatisfaccion"]>
    composites: {}
  }

  type EncuestaSatisfaccionGetPayload<S extends boolean | null | undefined | EncuestaSatisfaccionDefaultArgs> = $Result.GetResult<Prisma.$EncuestaSatisfaccionPayload, S>

  type EncuestaSatisfaccionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncuestaSatisfaccionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncuestaSatisfaccionCountAggregateInputType | true
    }

  export interface EncuestaSatisfaccionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncuestaSatisfaccion'], meta: { name: 'EncuestaSatisfaccion' } }
    /**
     * Find zero or one EncuestaSatisfaccion that matches the filter.
     * @param {EncuestaSatisfaccionFindUniqueArgs} args - Arguments to find a EncuestaSatisfaccion
     * @example
     * // Get one EncuestaSatisfaccion
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncuestaSatisfaccionFindUniqueArgs>(args: SelectSubset<T, EncuestaSatisfaccionFindUniqueArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EncuestaSatisfaccion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncuestaSatisfaccionFindUniqueOrThrowArgs} args - Arguments to find a EncuestaSatisfaccion
     * @example
     * // Get one EncuestaSatisfaccion
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncuestaSatisfaccionFindUniqueOrThrowArgs>(args: SelectSubset<T, EncuestaSatisfaccionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncuestaSatisfaccion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncuestaSatisfaccionFindFirstArgs} args - Arguments to find a EncuestaSatisfaccion
     * @example
     * // Get one EncuestaSatisfaccion
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncuestaSatisfaccionFindFirstArgs>(args?: SelectSubset<T, EncuestaSatisfaccionFindFirstArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncuestaSatisfaccion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncuestaSatisfaccionFindFirstOrThrowArgs} args - Arguments to find a EncuestaSatisfaccion
     * @example
     * // Get one EncuestaSatisfaccion
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncuestaSatisfaccionFindFirstOrThrowArgs>(args?: SelectSubset<T, EncuestaSatisfaccionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EncuestaSatisfaccions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncuestaSatisfaccionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncuestaSatisfaccions
     * const encuestaSatisfaccions = await prisma.encuestaSatisfaccion.findMany()
     * 
     * // Get first 10 EncuestaSatisfaccions
     * const encuestaSatisfaccions = await prisma.encuestaSatisfaccion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encuestaSatisfaccionWithIdOnly = await prisma.encuestaSatisfaccion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncuestaSatisfaccionFindManyArgs>(args?: SelectSubset<T, EncuestaSatisfaccionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EncuestaSatisfaccion.
     * @param {EncuestaSatisfaccionCreateArgs} args - Arguments to create a EncuestaSatisfaccion.
     * @example
     * // Create one EncuestaSatisfaccion
     * const EncuestaSatisfaccion = await prisma.encuestaSatisfaccion.create({
     *   data: {
     *     // ... data to create a EncuestaSatisfaccion
     *   }
     * })
     * 
     */
    create<T extends EncuestaSatisfaccionCreateArgs>(args: SelectSubset<T, EncuestaSatisfaccionCreateArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EncuestaSatisfaccions.
     * @param {EncuestaSatisfaccionCreateManyArgs} args - Arguments to create many EncuestaSatisfaccions.
     * @example
     * // Create many EncuestaSatisfaccions
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncuestaSatisfaccionCreateManyArgs>(args?: SelectSubset<T, EncuestaSatisfaccionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncuestaSatisfaccions and returns the data saved in the database.
     * @param {EncuestaSatisfaccionCreateManyAndReturnArgs} args - Arguments to create many EncuestaSatisfaccions.
     * @example
     * // Create many EncuestaSatisfaccions
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncuestaSatisfaccions and only return the `id`
     * const encuestaSatisfaccionWithIdOnly = await prisma.encuestaSatisfaccion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncuestaSatisfaccionCreateManyAndReturnArgs>(args?: SelectSubset<T, EncuestaSatisfaccionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EncuestaSatisfaccion.
     * @param {EncuestaSatisfaccionDeleteArgs} args - Arguments to delete one EncuestaSatisfaccion.
     * @example
     * // Delete one EncuestaSatisfaccion
     * const EncuestaSatisfaccion = await prisma.encuestaSatisfaccion.delete({
     *   where: {
     *     // ... filter to delete one EncuestaSatisfaccion
     *   }
     * })
     * 
     */
    delete<T extends EncuestaSatisfaccionDeleteArgs>(args: SelectSubset<T, EncuestaSatisfaccionDeleteArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EncuestaSatisfaccion.
     * @param {EncuestaSatisfaccionUpdateArgs} args - Arguments to update one EncuestaSatisfaccion.
     * @example
     * // Update one EncuestaSatisfaccion
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncuestaSatisfaccionUpdateArgs>(args: SelectSubset<T, EncuestaSatisfaccionUpdateArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EncuestaSatisfaccions.
     * @param {EncuestaSatisfaccionDeleteManyArgs} args - Arguments to filter EncuestaSatisfaccions to delete.
     * @example
     * // Delete a few EncuestaSatisfaccions
     * const { count } = await prisma.encuestaSatisfaccion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncuestaSatisfaccionDeleteManyArgs>(args?: SelectSubset<T, EncuestaSatisfaccionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncuestaSatisfaccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncuestaSatisfaccionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncuestaSatisfaccions
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncuestaSatisfaccionUpdateManyArgs>(args: SelectSubset<T, EncuestaSatisfaccionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncuestaSatisfaccions and returns the data updated in the database.
     * @param {EncuestaSatisfaccionUpdateManyAndReturnArgs} args - Arguments to update many EncuestaSatisfaccions.
     * @example
     * // Update many EncuestaSatisfaccions
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EncuestaSatisfaccions and only return the `id`
     * const encuestaSatisfaccionWithIdOnly = await prisma.encuestaSatisfaccion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncuestaSatisfaccionUpdateManyAndReturnArgs>(args: SelectSubset<T, EncuestaSatisfaccionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EncuestaSatisfaccion.
     * @param {EncuestaSatisfaccionUpsertArgs} args - Arguments to update or create a EncuestaSatisfaccion.
     * @example
     * // Update or create a EncuestaSatisfaccion
     * const encuestaSatisfaccion = await prisma.encuestaSatisfaccion.upsert({
     *   create: {
     *     // ... data to create a EncuestaSatisfaccion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncuestaSatisfaccion we want to update
     *   }
     * })
     */
    upsert<T extends EncuestaSatisfaccionUpsertArgs>(args: SelectSubset<T, EncuestaSatisfaccionUpsertArgs<ExtArgs>>): Prisma__EncuestaSatisfaccionClient<$Result.GetResult<Prisma.$EncuestaSatisfaccionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EncuestaSatisfaccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncuestaSatisfaccionCountArgs} args - Arguments to filter EncuestaSatisfaccions to count.
     * @example
     * // Count the number of EncuestaSatisfaccions
     * const count = await prisma.encuestaSatisfaccion.count({
     *   where: {
     *     // ... the filter for the EncuestaSatisfaccions we want to count
     *   }
     * })
    **/
    count<T extends EncuestaSatisfaccionCountArgs>(
      args?: Subset<T, EncuestaSatisfaccionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncuestaSatisfaccionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncuestaSatisfaccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncuestaSatisfaccionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncuestaSatisfaccionAggregateArgs>(args: Subset<T, EncuestaSatisfaccionAggregateArgs>): Prisma.PrismaPromise<GetEncuestaSatisfaccionAggregateType<T>>

    /**
     * Group by EncuestaSatisfaccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncuestaSatisfaccionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncuestaSatisfaccionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncuestaSatisfaccionGroupByArgs['orderBy'] }
        : { orderBy?: EncuestaSatisfaccionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncuestaSatisfaccionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncuestaSatisfaccionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncuestaSatisfaccion model
   */
  readonly fields: EncuestaSatisfaccionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncuestaSatisfaccion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncuestaSatisfaccionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversacion<T extends EncuestaSatisfaccion$conversacionArgs<ExtArgs> = {}>(args?: Subset<T, EncuestaSatisfaccion$conversacionArgs<ExtArgs>>): Prisma__ConversacionClient<$Result.GetResult<Prisma.$ConversacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    estudiante<T extends EncuestaSatisfaccion$estudianteArgs<ExtArgs> = {}>(args?: Subset<T, EncuestaSatisfaccion$estudianteArgs<ExtArgs>>): Prisma__EstudianteClient<$Result.GetResult<Prisma.$EstudiantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncuestaSatisfaccion model
   */
  interface EncuestaSatisfaccionFieldRefs {
    readonly id: FieldRef<"EncuestaSatisfaccion", 'String'>
    readonly conversacionId: FieldRef<"EncuestaSatisfaccion", 'String'>
    readonly estudianteId: FieldRef<"EncuestaSatisfaccion", 'String'>
    readonly calificacion: FieldRef<"EncuestaSatisfaccion", 'Int'>
    readonly comentario: FieldRef<"EncuestaSatisfaccion", 'String'>
    readonly respondida: FieldRef<"EncuestaSatisfaccion", 'Boolean'>
    readonly fuente: FieldRef<"EncuestaSatisfaccion", 'String'>
    readonly createdAt: FieldRef<"EncuestaSatisfaccion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncuestaSatisfaccion findUnique
   */
  export type EncuestaSatisfaccionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * Filter, which EncuestaSatisfaccion to fetch.
     */
    where: EncuestaSatisfaccionWhereUniqueInput
  }

  /**
   * EncuestaSatisfaccion findUniqueOrThrow
   */
  export type EncuestaSatisfaccionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * Filter, which EncuestaSatisfaccion to fetch.
     */
    where: EncuestaSatisfaccionWhereUniqueInput
  }

  /**
   * EncuestaSatisfaccion findFirst
   */
  export type EncuestaSatisfaccionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * Filter, which EncuestaSatisfaccion to fetch.
     */
    where?: EncuestaSatisfaccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncuestaSatisfaccions to fetch.
     */
    orderBy?: EncuestaSatisfaccionOrderByWithRelationInput | EncuestaSatisfaccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncuestaSatisfaccions.
     */
    cursor?: EncuestaSatisfaccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncuestaSatisfaccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncuestaSatisfaccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncuestaSatisfaccions.
     */
    distinct?: EncuestaSatisfaccionScalarFieldEnum | EncuestaSatisfaccionScalarFieldEnum[]
  }

  /**
   * EncuestaSatisfaccion findFirstOrThrow
   */
  export type EncuestaSatisfaccionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * Filter, which EncuestaSatisfaccion to fetch.
     */
    where?: EncuestaSatisfaccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncuestaSatisfaccions to fetch.
     */
    orderBy?: EncuestaSatisfaccionOrderByWithRelationInput | EncuestaSatisfaccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncuestaSatisfaccions.
     */
    cursor?: EncuestaSatisfaccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncuestaSatisfaccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncuestaSatisfaccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncuestaSatisfaccions.
     */
    distinct?: EncuestaSatisfaccionScalarFieldEnum | EncuestaSatisfaccionScalarFieldEnum[]
  }

  /**
   * EncuestaSatisfaccion findMany
   */
  export type EncuestaSatisfaccionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * Filter, which EncuestaSatisfaccions to fetch.
     */
    where?: EncuestaSatisfaccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncuestaSatisfaccions to fetch.
     */
    orderBy?: EncuestaSatisfaccionOrderByWithRelationInput | EncuestaSatisfaccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncuestaSatisfaccions.
     */
    cursor?: EncuestaSatisfaccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncuestaSatisfaccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncuestaSatisfaccions.
     */
    skip?: number
    distinct?: EncuestaSatisfaccionScalarFieldEnum | EncuestaSatisfaccionScalarFieldEnum[]
  }

  /**
   * EncuestaSatisfaccion create
   */
  export type EncuestaSatisfaccionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * The data needed to create a EncuestaSatisfaccion.
     */
    data: XOR<EncuestaSatisfaccionCreateInput, EncuestaSatisfaccionUncheckedCreateInput>
  }

  /**
   * EncuestaSatisfaccion createMany
   */
  export type EncuestaSatisfaccionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncuestaSatisfaccions.
     */
    data: EncuestaSatisfaccionCreateManyInput | EncuestaSatisfaccionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncuestaSatisfaccion createManyAndReturn
   */
  export type EncuestaSatisfaccionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * The data used to create many EncuestaSatisfaccions.
     */
    data: EncuestaSatisfaccionCreateManyInput | EncuestaSatisfaccionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncuestaSatisfaccion update
   */
  export type EncuestaSatisfaccionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * The data needed to update a EncuestaSatisfaccion.
     */
    data: XOR<EncuestaSatisfaccionUpdateInput, EncuestaSatisfaccionUncheckedUpdateInput>
    /**
     * Choose, which EncuestaSatisfaccion to update.
     */
    where: EncuestaSatisfaccionWhereUniqueInput
  }

  /**
   * EncuestaSatisfaccion updateMany
   */
  export type EncuestaSatisfaccionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncuestaSatisfaccions.
     */
    data: XOR<EncuestaSatisfaccionUpdateManyMutationInput, EncuestaSatisfaccionUncheckedUpdateManyInput>
    /**
     * Filter which EncuestaSatisfaccions to update
     */
    where?: EncuestaSatisfaccionWhereInput
    /**
     * Limit how many EncuestaSatisfaccions to update.
     */
    limit?: number
  }

  /**
   * EncuestaSatisfaccion updateManyAndReturn
   */
  export type EncuestaSatisfaccionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * The data used to update EncuestaSatisfaccions.
     */
    data: XOR<EncuestaSatisfaccionUpdateManyMutationInput, EncuestaSatisfaccionUncheckedUpdateManyInput>
    /**
     * Filter which EncuestaSatisfaccions to update
     */
    where?: EncuestaSatisfaccionWhereInput
    /**
     * Limit how many EncuestaSatisfaccions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncuestaSatisfaccion upsert
   */
  export type EncuestaSatisfaccionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * The filter to search for the EncuestaSatisfaccion to update in case it exists.
     */
    where: EncuestaSatisfaccionWhereUniqueInput
    /**
     * In case the EncuestaSatisfaccion found by the `where` argument doesn't exist, create a new EncuestaSatisfaccion with this data.
     */
    create: XOR<EncuestaSatisfaccionCreateInput, EncuestaSatisfaccionUncheckedCreateInput>
    /**
     * In case the EncuestaSatisfaccion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncuestaSatisfaccionUpdateInput, EncuestaSatisfaccionUncheckedUpdateInput>
  }

  /**
   * EncuestaSatisfaccion delete
   */
  export type EncuestaSatisfaccionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
    /**
     * Filter which EncuestaSatisfaccion to delete.
     */
    where: EncuestaSatisfaccionWhereUniqueInput
  }

  /**
   * EncuestaSatisfaccion deleteMany
   */
  export type EncuestaSatisfaccionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncuestaSatisfaccions to delete
     */
    where?: EncuestaSatisfaccionWhereInput
    /**
     * Limit how many EncuestaSatisfaccions to delete.
     */
    limit?: number
  }

  /**
   * EncuestaSatisfaccion.conversacion
   */
  export type EncuestaSatisfaccion$conversacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversacion
     */
    select?: ConversacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversacion
     */
    omit?: ConversacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversacionInclude<ExtArgs> | null
    where?: ConversacionWhereInput
  }

  /**
   * EncuestaSatisfaccion.estudiante
   */
  export type EncuestaSatisfaccion$estudianteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estudiante
     */
    select?: EstudianteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Estudiante
     */
    omit?: EstudianteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EstudianteInclude<ExtArgs> | null
    where?: EstudianteWhereInput
  }

  /**
   * EncuestaSatisfaccion without action
   */
  export type EncuestaSatisfaccionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncuestaSatisfaccion
     */
    select?: EncuestaSatisfaccionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncuestaSatisfaccion
     */
    omit?: EncuestaSatisfaccionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncuestaSatisfaccionInclude<ExtArgs> | null
  }


  /**
   * Model MetricaMensual
   */

  export type AggregateMetricaMensual = {
    _count: MetricaMensualCountAggregateOutputType | null
    _avg: MetricaMensualAvgAggregateOutputType | null
    _sum: MetricaMensualSumAggregateOutputType | null
    _min: MetricaMensualMinAggregateOutputType | null
    _max: MetricaMensualMaxAggregateOutputType | null
  }

  export type MetricaMensualAvgAggregateOutputType = {
    anio: number | null
    mes: number | null
    totalConversaciones: number | null
    totalAsesoramientos: number | null
    totalCitas: number | null
    citasCompletadas: number | null
    citasCanceladas: number | null
    promedioSatisfaccion: number | null
    totalEncuestas: number | null
  }

  export type MetricaMensualSumAggregateOutputType = {
    anio: number | null
    mes: number | null
    totalConversaciones: number | null
    totalAsesoramientos: number | null
    totalCitas: number | null
    citasCompletadas: number | null
    citasCanceladas: number | null
    promedioSatisfaccion: number | null
    totalEncuestas: number | null
  }

  export type MetricaMensualMinAggregateOutputType = {
    id: string | null
    anio: number | null
    mes: number | null
    totalConversaciones: number | null
    totalAsesoramientos: number | null
    totalCitas: number | null
    citasCompletadas: number | null
    citasCanceladas: number | null
    promedioSatisfaccion: number | null
    totalEncuestas: number | null
  }

  export type MetricaMensualMaxAggregateOutputType = {
    id: string | null
    anio: number | null
    mes: number | null
    totalConversaciones: number | null
    totalAsesoramientos: number | null
    totalCitas: number | null
    citasCompletadas: number | null
    citasCanceladas: number | null
    promedioSatisfaccion: number | null
    totalEncuestas: number | null
  }

  export type MetricaMensualCountAggregateOutputType = {
    id: number
    anio: number
    mes: number
    totalConversaciones: number
    totalAsesoramientos: number
    totalCitas: number
    citasCompletadas: number
    citasCanceladas: number
    promedioSatisfaccion: number
    totalEncuestas: number
    _all: number
  }


  export type MetricaMensualAvgAggregateInputType = {
    anio?: true
    mes?: true
    totalConversaciones?: true
    totalAsesoramientos?: true
    totalCitas?: true
    citasCompletadas?: true
    citasCanceladas?: true
    promedioSatisfaccion?: true
    totalEncuestas?: true
  }

  export type MetricaMensualSumAggregateInputType = {
    anio?: true
    mes?: true
    totalConversaciones?: true
    totalAsesoramientos?: true
    totalCitas?: true
    citasCompletadas?: true
    citasCanceladas?: true
    promedioSatisfaccion?: true
    totalEncuestas?: true
  }

  export type MetricaMensualMinAggregateInputType = {
    id?: true
    anio?: true
    mes?: true
    totalConversaciones?: true
    totalAsesoramientos?: true
    totalCitas?: true
    citasCompletadas?: true
    citasCanceladas?: true
    promedioSatisfaccion?: true
    totalEncuestas?: true
  }

  export type MetricaMensualMaxAggregateInputType = {
    id?: true
    anio?: true
    mes?: true
    totalConversaciones?: true
    totalAsesoramientos?: true
    totalCitas?: true
    citasCompletadas?: true
    citasCanceladas?: true
    promedioSatisfaccion?: true
    totalEncuestas?: true
  }

  export type MetricaMensualCountAggregateInputType = {
    id?: true
    anio?: true
    mes?: true
    totalConversaciones?: true
    totalAsesoramientos?: true
    totalCitas?: true
    citasCompletadas?: true
    citasCanceladas?: true
    promedioSatisfaccion?: true
    totalEncuestas?: true
    _all?: true
  }

  export type MetricaMensualAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetricaMensual to aggregate.
     */
    where?: MetricaMensualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetricaMensuals to fetch.
     */
    orderBy?: MetricaMensualOrderByWithRelationInput | MetricaMensualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetricaMensualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetricaMensuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetricaMensuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetricaMensuals
    **/
    _count?: true | MetricaMensualCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetricaMensualAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetricaMensualSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetricaMensualMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetricaMensualMaxAggregateInputType
  }

  export type GetMetricaMensualAggregateType<T extends MetricaMensualAggregateArgs> = {
        [P in keyof T & keyof AggregateMetricaMensual]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetricaMensual[P]>
      : GetScalarType<T[P], AggregateMetricaMensual[P]>
  }




  export type MetricaMensualGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetricaMensualWhereInput
    orderBy?: MetricaMensualOrderByWithAggregationInput | MetricaMensualOrderByWithAggregationInput[]
    by: MetricaMensualScalarFieldEnum[] | MetricaMensualScalarFieldEnum
    having?: MetricaMensualScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetricaMensualCountAggregateInputType | true
    _avg?: MetricaMensualAvgAggregateInputType
    _sum?: MetricaMensualSumAggregateInputType
    _min?: MetricaMensualMinAggregateInputType
    _max?: MetricaMensualMaxAggregateInputType
  }

  export type MetricaMensualGroupByOutputType = {
    id: string
    anio: number
    mes: number
    totalConversaciones: number
    totalAsesoramientos: number
    totalCitas: number
    citasCompletadas: number
    citasCanceladas: number
    promedioSatisfaccion: number
    totalEncuestas: number
    _count: MetricaMensualCountAggregateOutputType | null
    _avg: MetricaMensualAvgAggregateOutputType | null
    _sum: MetricaMensualSumAggregateOutputType | null
    _min: MetricaMensualMinAggregateOutputType | null
    _max: MetricaMensualMaxAggregateOutputType | null
  }

  type GetMetricaMensualGroupByPayload<T extends MetricaMensualGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetricaMensualGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetricaMensualGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetricaMensualGroupByOutputType[P]>
            : GetScalarType<T[P], MetricaMensualGroupByOutputType[P]>
        }
      >
    >


  export type MetricaMensualSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anio?: boolean
    mes?: boolean
    totalConversaciones?: boolean
    totalAsesoramientos?: boolean
    totalCitas?: boolean
    citasCompletadas?: boolean
    citasCanceladas?: boolean
    promedioSatisfaccion?: boolean
    totalEncuestas?: boolean
  }, ExtArgs["result"]["metricaMensual"]>

  export type MetricaMensualSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anio?: boolean
    mes?: boolean
    totalConversaciones?: boolean
    totalAsesoramientos?: boolean
    totalCitas?: boolean
    citasCompletadas?: boolean
    citasCanceladas?: boolean
    promedioSatisfaccion?: boolean
    totalEncuestas?: boolean
  }, ExtArgs["result"]["metricaMensual"]>

  export type MetricaMensualSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    anio?: boolean
    mes?: boolean
    totalConversaciones?: boolean
    totalAsesoramientos?: boolean
    totalCitas?: boolean
    citasCompletadas?: boolean
    citasCanceladas?: boolean
    promedioSatisfaccion?: boolean
    totalEncuestas?: boolean
  }, ExtArgs["result"]["metricaMensual"]>

  export type MetricaMensualSelectScalar = {
    id?: boolean
    anio?: boolean
    mes?: boolean
    totalConversaciones?: boolean
    totalAsesoramientos?: boolean
    totalCitas?: boolean
    citasCompletadas?: boolean
    citasCanceladas?: boolean
    promedioSatisfaccion?: boolean
    totalEncuestas?: boolean
  }

  export type MetricaMensualOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "anio" | "mes" | "totalConversaciones" | "totalAsesoramientos" | "totalCitas" | "citasCompletadas" | "citasCanceladas" | "promedioSatisfaccion" | "totalEncuestas", ExtArgs["result"]["metricaMensual"]>

  export type $MetricaMensualPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MetricaMensual"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      anio: number
      mes: number
      totalConversaciones: number
      totalAsesoramientos: number
      totalCitas: number
      citasCompletadas: number
      citasCanceladas: number
      promedioSatisfaccion: number
      totalEncuestas: number
    }, ExtArgs["result"]["metricaMensual"]>
    composites: {}
  }

  type MetricaMensualGetPayload<S extends boolean | null | undefined | MetricaMensualDefaultArgs> = $Result.GetResult<Prisma.$MetricaMensualPayload, S>

  type MetricaMensualCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetricaMensualFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetricaMensualCountAggregateInputType | true
    }

  export interface MetricaMensualDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MetricaMensual'], meta: { name: 'MetricaMensual' } }
    /**
     * Find zero or one MetricaMensual that matches the filter.
     * @param {MetricaMensualFindUniqueArgs} args - Arguments to find a MetricaMensual
     * @example
     * // Get one MetricaMensual
     * const metricaMensual = await prisma.metricaMensual.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetricaMensualFindUniqueArgs>(args: SelectSubset<T, MetricaMensualFindUniqueArgs<ExtArgs>>): Prisma__MetricaMensualClient<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MetricaMensual that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetricaMensualFindUniqueOrThrowArgs} args - Arguments to find a MetricaMensual
     * @example
     * // Get one MetricaMensual
     * const metricaMensual = await prisma.metricaMensual.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetricaMensualFindUniqueOrThrowArgs>(args: SelectSubset<T, MetricaMensualFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetricaMensualClient<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetricaMensual that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricaMensualFindFirstArgs} args - Arguments to find a MetricaMensual
     * @example
     * // Get one MetricaMensual
     * const metricaMensual = await prisma.metricaMensual.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetricaMensualFindFirstArgs>(args?: SelectSubset<T, MetricaMensualFindFirstArgs<ExtArgs>>): Prisma__MetricaMensualClient<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetricaMensual that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricaMensualFindFirstOrThrowArgs} args - Arguments to find a MetricaMensual
     * @example
     * // Get one MetricaMensual
     * const metricaMensual = await prisma.metricaMensual.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetricaMensualFindFirstOrThrowArgs>(args?: SelectSubset<T, MetricaMensualFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetricaMensualClient<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MetricaMensuals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricaMensualFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetricaMensuals
     * const metricaMensuals = await prisma.metricaMensual.findMany()
     * 
     * // Get first 10 MetricaMensuals
     * const metricaMensuals = await prisma.metricaMensual.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metricaMensualWithIdOnly = await prisma.metricaMensual.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetricaMensualFindManyArgs>(args?: SelectSubset<T, MetricaMensualFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MetricaMensual.
     * @param {MetricaMensualCreateArgs} args - Arguments to create a MetricaMensual.
     * @example
     * // Create one MetricaMensual
     * const MetricaMensual = await prisma.metricaMensual.create({
     *   data: {
     *     // ... data to create a MetricaMensual
     *   }
     * })
     * 
     */
    create<T extends MetricaMensualCreateArgs>(args: SelectSubset<T, MetricaMensualCreateArgs<ExtArgs>>): Prisma__MetricaMensualClient<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MetricaMensuals.
     * @param {MetricaMensualCreateManyArgs} args - Arguments to create many MetricaMensuals.
     * @example
     * // Create many MetricaMensuals
     * const metricaMensual = await prisma.metricaMensual.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetricaMensualCreateManyArgs>(args?: SelectSubset<T, MetricaMensualCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MetricaMensuals and returns the data saved in the database.
     * @param {MetricaMensualCreateManyAndReturnArgs} args - Arguments to create many MetricaMensuals.
     * @example
     * // Create many MetricaMensuals
     * const metricaMensual = await prisma.metricaMensual.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MetricaMensuals and only return the `id`
     * const metricaMensualWithIdOnly = await prisma.metricaMensual.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetricaMensualCreateManyAndReturnArgs>(args?: SelectSubset<T, MetricaMensualCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MetricaMensual.
     * @param {MetricaMensualDeleteArgs} args - Arguments to delete one MetricaMensual.
     * @example
     * // Delete one MetricaMensual
     * const MetricaMensual = await prisma.metricaMensual.delete({
     *   where: {
     *     // ... filter to delete one MetricaMensual
     *   }
     * })
     * 
     */
    delete<T extends MetricaMensualDeleteArgs>(args: SelectSubset<T, MetricaMensualDeleteArgs<ExtArgs>>): Prisma__MetricaMensualClient<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MetricaMensual.
     * @param {MetricaMensualUpdateArgs} args - Arguments to update one MetricaMensual.
     * @example
     * // Update one MetricaMensual
     * const metricaMensual = await prisma.metricaMensual.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetricaMensualUpdateArgs>(args: SelectSubset<T, MetricaMensualUpdateArgs<ExtArgs>>): Prisma__MetricaMensualClient<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MetricaMensuals.
     * @param {MetricaMensualDeleteManyArgs} args - Arguments to filter MetricaMensuals to delete.
     * @example
     * // Delete a few MetricaMensuals
     * const { count } = await prisma.metricaMensual.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetricaMensualDeleteManyArgs>(args?: SelectSubset<T, MetricaMensualDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetricaMensuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricaMensualUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetricaMensuals
     * const metricaMensual = await prisma.metricaMensual.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetricaMensualUpdateManyArgs>(args: SelectSubset<T, MetricaMensualUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetricaMensuals and returns the data updated in the database.
     * @param {MetricaMensualUpdateManyAndReturnArgs} args - Arguments to update many MetricaMensuals.
     * @example
     * // Update many MetricaMensuals
     * const metricaMensual = await prisma.metricaMensual.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MetricaMensuals and only return the `id`
     * const metricaMensualWithIdOnly = await prisma.metricaMensual.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MetricaMensualUpdateManyAndReturnArgs>(args: SelectSubset<T, MetricaMensualUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MetricaMensual.
     * @param {MetricaMensualUpsertArgs} args - Arguments to update or create a MetricaMensual.
     * @example
     * // Update or create a MetricaMensual
     * const metricaMensual = await prisma.metricaMensual.upsert({
     *   create: {
     *     // ... data to create a MetricaMensual
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetricaMensual we want to update
     *   }
     * })
     */
    upsert<T extends MetricaMensualUpsertArgs>(args: SelectSubset<T, MetricaMensualUpsertArgs<ExtArgs>>): Prisma__MetricaMensualClient<$Result.GetResult<Prisma.$MetricaMensualPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MetricaMensuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricaMensualCountArgs} args - Arguments to filter MetricaMensuals to count.
     * @example
     * // Count the number of MetricaMensuals
     * const count = await prisma.metricaMensual.count({
     *   where: {
     *     // ... the filter for the MetricaMensuals we want to count
     *   }
     * })
    **/
    count<T extends MetricaMensualCountArgs>(
      args?: Subset<T, MetricaMensualCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetricaMensualCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetricaMensual.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricaMensualAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetricaMensualAggregateArgs>(args: Subset<T, MetricaMensualAggregateArgs>): Prisma.PrismaPromise<GetMetricaMensualAggregateType<T>>

    /**
     * Group by MetricaMensual.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricaMensualGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetricaMensualGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricaMensualGroupByArgs['orderBy'] }
        : { orderBy?: MetricaMensualGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetricaMensualGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetricaMensualGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MetricaMensual model
   */
  readonly fields: MetricaMensualFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetricaMensual.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetricaMensualClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MetricaMensual model
   */
  interface MetricaMensualFieldRefs {
    readonly id: FieldRef<"MetricaMensual", 'String'>
    readonly anio: FieldRef<"MetricaMensual", 'Int'>
    readonly mes: FieldRef<"MetricaMensual", 'Int'>
    readonly totalConversaciones: FieldRef<"MetricaMensual", 'Int'>
    readonly totalAsesoramientos: FieldRef<"MetricaMensual", 'Int'>
    readonly totalCitas: FieldRef<"MetricaMensual", 'Int'>
    readonly citasCompletadas: FieldRef<"MetricaMensual", 'Int'>
    readonly citasCanceladas: FieldRef<"MetricaMensual", 'Int'>
    readonly promedioSatisfaccion: FieldRef<"MetricaMensual", 'Float'>
    readonly totalEncuestas: FieldRef<"MetricaMensual", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MetricaMensual findUnique
   */
  export type MetricaMensualFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * Filter, which MetricaMensual to fetch.
     */
    where: MetricaMensualWhereUniqueInput
  }

  /**
   * MetricaMensual findUniqueOrThrow
   */
  export type MetricaMensualFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * Filter, which MetricaMensual to fetch.
     */
    where: MetricaMensualWhereUniqueInput
  }

  /**
   * MetricaMensual findFirst
   */
  export type MetricaMensualFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * Filter, which MetricaMensual to fetch.
     */
    where?: MetricaMensualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetricaMensuals to fetch.
     */
    orderBy?: MetricaMensualOrderByWithRelationInput | MetricaMensualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetricaMensuals.
     */
    cursor?: MetricaMensualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetricaMensuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetricaMensuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetricaMensuals.
     */
    distinct?: MetricaMensualScalarFieldEnum | MetricaMensualScalarFieldEnum[]
  }

  /**
   * MetricaMensual findFirstOrThrow
   */
  export type MetricaMensualFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * Filter, which MetricaMensual to fetch.
     */
    where?: MetricaMensualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetricaMensuals to fetch.
     */
    orderBy?: MetricaMensualOrderByWithRelationInput | MetricaMensualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetricaMensuals.
     */
    cursor?: MetricaMensualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetricaMensuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetricaMensuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetricaMensuals.
     */
    distinct?: MetricaMensualScalarFieldEnum | MetricaMensualScalarFieldEnum[]
  }

  /**
   * MetricaMensual findMany
   */
  export type MetricaMensualFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * Filter, which MetricaMensuals to fetch.
     */
    where?: MetricaMensualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetricaMensuals to fetch.
     */
    orderBy?: MetricaMensualOrderByWithRelationInput | MetricaMensualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetricaMensuals.
     */
    cursor?: MetricaMensualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetricaMensuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetricaMensuals.
     */
    skip?: number
    distinct?: MetricaMensualScalarFieldEnum | MetricaMensualScalarFieldEnum[]
  }

  /**
   * MetricaMensual create
   */
  export type MetricaMensualCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * The data needed to create a MetricaMensual.
     */
    data: XOR<MetricaMensualCreateInput, MetricaMensualUncheckedCreateInput>
  }

  /**
   * MetricaMensual createMany
   */
  export type MetricaMensualCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MetricaMensuals.
     */
    data: MetricaMensualCreateManyInput | MetricaMensualCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MetricaMensual createManyAndReturn
   */
  export type MetricaMensualCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * The data used to create many MetricaMensuals.
     */
    data: MetricaMensualCreateManyInput | MetricaMensualCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MetricaMensual update
   */
  export type MetricaMensualUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * The data needed to update a MetricaMensual.
     */
    data: XOR<MetricaMensualUpdateInput, MetricaMensualUncheckedUpdateInput>
    /**
     * Choose, which MetricaMensual to update.
     */
    where: MetricaMensualWhereUniqueInput
  }

  /**
   * MetricaMensual updateMany
   */
  export type MetricaMensualUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MetricaMensuals.
     */
    data: XOR<MetricaMensualUpdateManyMutationInput, MetricaMensualUncheckedUpdateManyInput>
    /**
     * Filter which MetricaMensuals to update
     */
    where?: MetricaMensualWhereInput
    /**
     * Limit how many MetricaMensuals to update.
     */
    limit?: number
  }

  /**
   * MetricaMensual updateManyAndReturn
   */
  export type MetricaMensualUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * The data used to update MetricaMensuals.
     */
    data: XOR<MetricaMensualUpdateManyMutationInput, MetricaMensualUncheckedUpdateManyInput>
    /**
     * Filter which MetricaMensuals to update
     */
    where?: MetricaMensualWhereInput
    /**
     * Limit how many MetricaMensuals to update.
     */
    limit?: number
  }

  /**
   * MetricaMensual upsert
   */
  export type MetricaMensualUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * The filter to search for the MetricaMensual to update in case it exists.
     */
    where: MetricaMensualWhereUniqueInput
    /**
     * In case the MetricaMensual found by the `where` argument doesn't exist, create a new MetricaMensual with this data.
     */
    create: XOR<MetricaMensualCreateInput, MetricaMensualUncheckedCreateInput>
    /**
     * In case the MetricaMensual was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricaMensualUpdateInput, MetricaMensualUncheckedUpdateInput>
  }

  /**
   * MetricaMensual delete
   */
  export type MetricaMensualDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
    /**
     * Filter which MetricaMensual to delete.
     */
    where: MetricaMensualWhereUniqueInput
  }

  /**
   * MetricaMensual deleteMany
   */
  export type MetricaMensualDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetricaMensuals to delete
     */
    where?: MetricaMensualWhereInput
    /**
     * Limit how many MetricaMensuals to delete.
     */
    limit?: number
  }

  /**
   * MetricaMensual without action
   */
  export type MetricaMensualDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetricaMensual
     */
    select?: MetricaMensualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetricaMensual
     */
    omit?: MetricaMensualOmit<ExtArgs> | null
  }


  /**
   * Model Notificacion
   */

  export type AggregateNotificacion = {
    _count: NotificacionCountAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  export type NotificacionMinAggregateOutputType = {
    id: string | null
    tipo: string | null
    titulo: string | null
    mensaje: string | null
    prioridad: string | null
    leida: boolean | null
    estudianteId: string | null
    createdAt: Date | null
  }

  export type NotificacionMaxAggregateOutputType = {
    id: string | null
    tipo: string | null
    titulo: string | null
    mensaje: string | null
    prioridad: string | null
    leida: boolean | null
    estudianteId: string | null
    createdAt: Date | null
  }

  export type NotificacionCountAggregateOutputType = {
    id: number
    tipo: number
    titulo: number
    mensaje: number
    prioridad: number
    leida: number
    estudianteId: number
    createdAt: number
    _all: number
  }


  export type NotificacionMinAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    prioridad?: true
    leida?: true
    estudianteId?: true
    createdAt?: true
  }

  export type NotificacionMaxAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    prioridad?: true
    leida?: true
    estudianteId?: true
    createdAt?: true
  }

  export type NotificacionCountAggregateInputType = {
    id?: true
    tipo?: true
    titulo?: true
    mensaje?: true
    prioridad?: true
    leida?: true
    estudianteId?: true
    createdAt?: true
    _all?: true
  }

  export type NotificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacion to aggregate.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacions
    **/
    _count?: true | NotificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionMaxAggregateInputType
  }

  export type GetNotificacionAggregateType<T extends NotificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacion[P]>
      : GetScalarType<T[P], AggregateNotificacion[P]>
  }




  export type NotificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithAggregationInput | NotificacionOrderByWithAggregationInput[]
    by: NotificacionScalarFieldEnum[] | NotificacionScalarFieldEnum
    having?: NotificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionCountAggregateInputType | true
    _min?: NotificacionMinAggregateInputType
    _max?: NotificacionMaxAggregateInputType
  }

  export type NotificacionGroupByOutputType = {
    id: string
    tipo: string
    titulo: string
    mensaje: string
    prioridad: string
    leida: boolean
    estudianteId: string | null
    createdAt: Date
    _count: NotificacionCountAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  type GetNotificacionGroupByPayload<T extends NotificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
        }
      >
    >


  export type NotificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    prioridad?: boolean
    leida?: boolean
    estudianteId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    prioridad?: boolean
    leida?: boolean
    estudianteId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    prioridad?: boolean
    leida?: boolean
    estudianteId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["notificacion"]>

  export type NotificacionSelectScalar = {
    id?: boolean
    tipo?: boolean
    titulo?: boolean
    mensaje?: boolean
    prioridad?: boolean
    leida?: boolean
    estudianteId?: boolean
    createdAt?: boolean
  }

  export type NotificacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "titulo" | "mensaje" | "prioridad" | "leida" | "estudianteId" | "createdAt", ExtArgs["result"]["notificacion"]>

  export type $NotificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: string
      titulo: string
      mensaje: string
      prioridad: string
      leida: boolean
      estudianteId: string | null
      createdAt: Date
    }, ExtArgs["result"]["notificacion"]>
    composites: {}
  }

  type NotificacionGetPayload<S extends boolean | null | undefined | NotificacionDefaultArgs> = $Result.GetResult<Prisma.$NotificacionPayload, S>

  type NotificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificacionCountAggregateInputType | true
    }

  export interface NotificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacion'], meta: { name: 'Notificacion' } }
    /**
     * Find zero or one Notificacion that matches the filter.
     * @param {NotificacionFindUniqueArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacionFindUniqueArgs>(args: SelectSubset<T, NotificacionFindUniqueArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificacionFindUniqueOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacionFindFirstArgs>(args?: SelectSubset<T, NotificacionFindFirstArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacions
     * const notificacions = await prisma.notificacion.findMany()
     * 
     * // Get first 10 Notificacions
     * const notificacions = await prisma.notificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificacionFindManyArgs>(args?: SelectSubset<T, NotificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notificacion.
     * @param {NotificacionCreateArgs} args - Arguments to create a Notificacion.
     * @example
     * // Create one Notificacion
     * const Notificacion = await prisma.notificacion.create({
     *   data: {
     *     // ... data to create a Notificacion
     *   }
     * })
     * 
     */
    create<T extends NotificacionCreateArgs>(args: SelectSubset<T, NotificacionCreateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notificacions.
     * @param {NotificacionCreateManyArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificacionCreateManyArgs>(args?: SelectSubset<T, NotificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notificacions and returns the data saved in the database.
     * @param {NotificacionCreateManyAndReturnArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notificacions and only return the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificacionCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notificacion.
     * @param {NotificacionDeleteArgs} args - Arguments to delete one Notificacion.
     * @example
     * // Delete one Notificacion
     * const Notificacion = await prisma.notificacion.delete({
     *   where: {
     *     // ... filter to delete one Notificacion
     *   }
     * })
     * 
     */
    delete<T extends NotificacionDeleteArgs>(args: SelectSubset<T, NotificacionDeleteArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notificacion.
     * @param {NotificacionUpdateArgs} args - Arguments to update one Notificacion.
     * @example
     * // Update one Notificacion
     * const notificacion = await prisma.notificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificacionUpdateArgs>(args: SelectSubset<T, NotificacionUpdateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notificacions.
     * @param {NotificacionDeleteManyArgs} args - Arguments to filter Notificacions to delete.
     * @example
     * // Delete a few Notificacions
     * const { count } = await prisma.notificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificacionDeleteManyArgs>(args?: SelectSubset<T, NotificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificacionUpdateManyArgs>(args: SelectSubset<T, NotificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions and returns the data updated in the database.
     * @param {NotificacionUpdateManyAndReturnArgs} args - Arguments to update many Notificacions.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notificacions and only return the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificacionUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notificacion.
     * @param {NotificacionUpsertArgs} args - Arguments to update or create a Notificacion.
     * @example
     * // Update or create a Notificacion
     * const notificacion = await prisma.notificacion.upsert({
     *   create: {
     *     // ... data to create a Notificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacion we want to update
     *   }
     * })
     */
    upsert<T extends NotificacionUpsertArgs>(args: SelectSubset<T, NotificacionUpsertArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionCountArgs} args - Arguments to filter Notificacions to count.
     * @example
     * // Count the number of Notificacions
     * const count = await prisma.notificacion.count({
     *   where: {
     *     // ... the filter for the Notificacions we want to count
     *   }
     * })
    **/
    count<T extends NotificacionCountArgs>(
      args?: Subset<T, NotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionAggregateArgs>(args: Subset<T, NotificacionAggregateArgs>): Prisma.PrismaPromise<GetNotificacionAggregateType<T>>

    /**
     * Group by Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacionGroupByArgs['orderBy'] }
        : { orderBy?: NotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacion model
   */
  readonly fields: NotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notificacion model
   */
  interface NotificacionFieldRefs {
    readonly id: FieldRef<"Notificacion", 'String'>
    readonly tipo: FieldRef<"Notificacion", 'String'>
    readonly titulo: FieldRef<"Notificacion", 'String'>
    readonly mensaje: FieldRef<"Notificacion", 'String'>
    readonly prioridad: FieldRef<"Notificacion", 'String'>
    readonly leida: FieldRef<"Notificacion", 'Boolean'>
    readonly estudianteId: FieldRef<"Notificacion", 'String'>
    readonly createdAt: FieldRef<"Notificacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notificacion findUnique
   */
  export type NotificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findUniqueOrThrow
   */
  export type NotificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findFirst
   */
  export type NotificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findFirstOrThrow
   */
  export type NotificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findMany
   */
  export type NotificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Filter, which Notificacions to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion create
   */
  export type NotificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data needed to create a Notificacion.
     */
    data: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
  }

  /**
   * Notificacion createMany
   */
  export type NotificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notificacion createManyAndReturn
   */
  export type NotificacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notificacion update
   */
  export type NotificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data needed to update a Notificacion.
     */
    data: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
    /**
     * Choose, which Notificacion to update.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion updateMany
   */
  export type NotificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
  }

  /**
   * Notificacion updateManyAndReturn
   */
  export type NotificacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
  }

  /**
   * Notificacion upsert
   */
  export type NotificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * The filter to search for the Notificacion to update in case it exists.
     */
    where: NotificacionWhereUniqueInput
    /**
     * In case the Notificacion found by the `where` argument doesn't exist, create a new Notificacion with this data.
     */
    create: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
    /**
     * In case the Notificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
  }

  /**
   * Notificacion delete
   */
  export type NotificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Filter which Notificacion to delete.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion deleteMany
   */
  export type NotificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacions to delete
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to delete.
     */
    limit?: number
  }

  /**
   * Notificacion without action
   */
  export type NotificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    channel: $Enums.Channel | null
    externalId: string | null
    displayName: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    channel: $Enums.Channel | null
    externalId: string | null
    displayName: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    tenantId: number
    channel: number
    externalId: number
    displayName: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    tenantId?: true
    channel?: true
    externalId?: true
    displayName?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    tenantId?: true
    channel?: true
    externalId?: true
    displayName?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    tenantId?: true
    channel?: true
    externalId?: true
    displayName?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    tenantId: string
    channel: $Enums.Channel
    externalId: string
    displayName: string | null
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    channel?: boolean
    externalId?: boolean
    displayName?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversations?: boolean | Contact$conversationsArgs<ExtArgs>
    messages?: boolean | Contact$messagesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    channel?: boolean
    externalId?: boolean
    displayName?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    channel?: boolean
    externalId?: boolean
    displayName?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    tenantId?: boolean
    channel?: boolean
    externalId?: boolean
    displayName?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "channel" | "externalId" | "displayName" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | Contact$conversationsArgs<ExtArgs>
    messages?: boolean | Contact$messagesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      channel: $Enums.Channel
      externalId: string
      displayName: string | null
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversations<T extends Contact$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Contact$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly tenantId: FieldRef<"Contact", 'String'>
    readonly channel: FieldRef<"Contact", 'Channel'>
    readonly externalId: FieldRef<"Contact", 'String'>
    readonly displayName: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.conversations
   */
  export type Contact$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Contact.messages
   */
  export type Contact$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    channel: $Enums.Channel | null
    status: $Enums.ConversationStatus | null
    lastMessageAt: Date | null
    currentFlowVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    channel: $Enums.Channel | null
    status: $Enums.ConversationStatus | null
    lastMessageAt: Date | null
    currentFlowVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    tenantId: number
    contactId: number
    channel: number
    status: number
    lastMessageAt: number
    currentFlowVersionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    channel?: true
    status?: true
    lastMessageAt?: true
    currentFlowVersionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    channel?: true
    status?: true
    lastMessageAt?: true
    currentFlowVersionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    channel?: true
    status?: true
    lastMessageAt?: true
    currentFlowVersionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    tenantId: string
    contactId: string
    channel: $Enums.Channel
    status: $Enums.ConversationStatus
    lastMessageAt: Date
    currentFlowVersionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    channel?: boolean
    status?: boolean
    lastMessageAt?: boolean
    currentFlowVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    contexts?: boolean | Conversation$contextsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    channel?: boolean
    status?: boolean
    lastMessageAt?: boolean
    currentFlowVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    channel?: boolean
    status?: boolean
    lastMessageAt?: boolean
    currentFlowVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    channel?: boolean
    status?: boolean
    lastMessageAt?: boolean
    currentFlowVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactId" | "channel" | "status" | "lastMessageAt" | "currentFlowVersionId" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    contexts?: boolean | Conversation$contextsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      contexts: Prisma.$ConversationContextPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactId: string
      channel: $Enums.Channel
      status: $Enums.ConversationStatus
      lastMessageAt: Date
      currentFlowVersionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contexts<T extends Conversation$contextsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$contextsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly tenantId: FieldRef<"Conversation", 'String'>
    readonly contactId: FieldRef<"Conversation", 'String'>
    readonly channel: FieldRef<"Conversation", 'Channel'>
    readonly status: FieldRef<"Conversation", 'ConversationStatus'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly currentFlowVersionId: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.contexts
   */
  export type Conversation$contextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    where?: ConversationContextWhereInput
    orderBy?: ConversationContextOrderByWithRelationInput | ConversationContextOrderByWithRelationInput[]
    cursor?: ConversationContextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationContextScalarFieldEnum | ConversationContextScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    conversationId: string | null
    contactId: string | null
    direction: $Enums.Direction | null
    type: $Enums.MessageType | null
    text: string | null
    providerMessageId: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    conversationId: string | null
    contactId: string | null
    direction: $Enums.Direction | null
    type: $Enums.MessageType | null
    text: string | null
    providerMessageId: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    tenantId: number
    conversationId: number
    contactId: number
    direction: number
    type: number
    text: number
    payload: number
    providerMessageId: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    tenantId?: true
    conversationId?: true
    contactId?: true
    direction?: true
    type?: true
    text?: true
    providerMessageId?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    tenantId?: true
    conversationId?: true
    contactId?: true
    direction?: true
    type?: true
    text?: true
    providerMessageId?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    tenantId?: true
    conversationId?: true
    contactId?: true
    direction?: true
    type?: true
    text?: true
    payload?: true
    providerMessageId?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    tenantId: string
    conversationId: string
    contactId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text: string | null
    payload: JsonValue
    providerMessageId: string | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    conversationId?: boolean
    contactId?: boolean
    direction?: boolean
    type?: boolean
    text?: boolean
    payload?: boolean
    providerMessageId?: boolean
    createdAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    conversationId?: boolean
    contactId?: boolean
    direction?: boolean
    type?: boolean
    text?: boolean
    payload?: boolean
    providerMessageId?: boolean
    createdAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    conversationId?: boolean
    contactId?: boolean
    direction?: boolean
    type?: boolean
    text?: boolean
    payload?: boolean
    providerMessageId?: boolean
    createdAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    tenantId?: boolean
    conversationId?: boolean
    contactId?: boolean
    direction?: boolean
    type?: boolean
    text?: boolean
    payload?: boolean
    providerMessageId?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "conversationId" | "contactId" | "direction" | "type" | "text" | "payload" | "providerMessageId" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      conversationId: string
      contactId: string
      direction: $Enums.Direction
      type: $Enums.MessageType
      text: string | null
      payload: Prisma.JsonValue
      providerMessageId: string | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly tenantId: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly contactId: FieldRef<"Message", 'String'>
    readonly direction: FieldRef<"Message", 'Direction'>
    readonly type: FieldRef<"Message", 'MessageType'>
    readonly text: FieldRef<"Message", 'String'>
    readonly payload: FieldRef<"Message", 'Json'>
    readonly providerMessageId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ConversationContext
   */

  export type AggregateConversationContext = {
    _count: ConversationContextCountAggregateOutputType | null
    _avg: ConversationContextAvgAggregateOutputType | null
    _sum: ConversationContextSumAggregateOutputType | null
    _min: ConversationContextMinAggregateOutputType | null
    _max: ConversationContextMaxAggregateOutputType | null
  }

  export type ConversationContextAvgAggregateOutputType = {
    version: number | null
  }

  export type ConversationContextSumAggregateOutputType = {
    version: number | null
  }

  export type ConversationContextMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    conversationId: string | null
    version: number | null
    createdAt: Date | null
  }

  export type ConversationContextMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    conversationId: string | null
    version: number | null
    createdAt: Date | null
  }

  export type ConversationContextCountAggregateOutputType = {
    id: number
    tenantId: number
    conversationId: number
    version: number
    data: number
    createdAt: number
    _all: number
  }


  export type ConversationContextAvgAggregateInputType = {
    version?: true
  }

  export type ConversationContextSumAggregateInputType = {
    version?: true
  }

  export type ConversationContextMinAggregateInputType = {
    id?: true
    tenantId?: true
    conversationId?: true
    version?: true
    createdAt?: true
  }

  export type ConversationContextMaxAggregateInputType = {
    id?: true
    tenantId?: true
    conversationId?: true
    version?: true
    createdAt?: true
  }

  export type ConversationContextCountAggregateInputType = {
    id?: true
    tenantId?: true
    conversationId?: true
    version?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationContext to aggregate.
     */
    where?: ConversationContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationContexts to fetch.
     */
    orderBy?: ConversationContextOrderByWithRelationInput | ConversationContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationContexts
    **/
    _count?: true | ConversationContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationContextAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationContextSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationContextMaxAggregateInputType
  }

  export type GetConversationContextAggregateType<T extends ConversationContextAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationContext[P]>
      : GetScalarType<T[P], AggregateConversationContext[P]>
  }




  export type ConversationContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationContextWhereInput
    orderBy?: ConversationContextOrderByWithAggregationInput | ConversationContextOrderByWithAggregationInput[]
    by: ConversationContextScalarFieldEnum[] | ConversationContextScalarFieldEnum
    having?: ConversationContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationContextCountAggregateInputType | true
    _avg?: ConversationContextAvgAggregateInputType
    _sum?: ConversationContextSumAggregateInputType
    _min?: ConversationContextMinAggregateInputType
    _max?: ConversationContextMaxAggregateInputType
  }

  export type ConversationContextGroupByOutputType = {
    id: string
    tenantId: string
    conversationId: string
    version: number
    data: JsonValue
    createdAt: Date
    _count: ConversationContextCountAggregateOutputType | null
    _avg: ConversationContextAvgAggregateOutputType | null
    _sum: ConversationContextSumAggregateOutputType | null
    _min: ConversationContextMinAggregateOutputType | null
    _max: ConversationContextMaxAggregateOutputType | null
  }

  type GetConversationContextGroupByPayload<T extends ConversationContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationContextGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationContextGroupByOutputType[P]>
        }
      >
    >


  export type ConversationContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    conversationId?: boolean
    version?: boolean
    data?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationContext"]>

  export type ConversationContextSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    conversationId?: boolean
    version?: boolean
    data?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationContext"]>

  export type ConversationContextSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    conversationId?: boolean
    version?: boolean
    data?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationContext"]>

  export type ConversationContextSelectScalar = {
    id?: boolean
    tenantId?: boolean
    conversationId?: boolean
    version?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type ConversationContextOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "conversationId" | "version" | "data" | "createdAt", ExtArgs["result"]["conversationContext"]>
  export type ConversationContextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationContextIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationContextIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $ConversationContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationContext"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      conversationId: string
      version: number
      data: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["conversationContext"]>
    composites: {}
  }

  type ConversationContextGetPayload<S extends boolean | null | undefined | ConversationContextDefaultArgs> = $Result.GetResult<Prisma.$ConversationContextPayload, S>

  type ConversationContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationContextFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationContextCountAggregateInputType | true
    }

  export interface ConversationContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationContext'], meta: { name: 'ConversationContext' } }
    /**
     * Find zero or one ConversationContext that matches the filter.
     * @param {ConversationContextFindUniqueArgs} args - Arguments to find a ConversationContext
     * @example
     * // Get one ConversationContext
     * const conversationContext = await prisma.conversationContext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationContextFindUniqueArgs>(args: SelectSubset<T, ConversationContextFindUniqueArgs<ExtArgs>>): Prisma__ConversationContextClient<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationContext that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationContextFindUniqueOrThrowArgs} args - Arguments to find a ConversationContext
     * @example
     * // Get one ConversationContext
     * const conversationContext = await prisma.conversationContext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationContextFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationContextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationContextClient<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationContext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationContextFindFirstArgs} args - Arguments to find a ConversationContext
     * @example
     * // Get one ConversationContext
     * const conversationContext = await prisma.conversationContext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationContextFindFirstArgs>(args?: SelectSubset<T, ConversationContextFindFirstArgs<ExtArgs>>): Prisma__ConversationContextClient<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationContext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationContextFindFirstOrThrowArgs} args - Arguments to find a ConversationContext
     * @example
     * // Get one ConversationContext
     * const conversationContext = await prisma.conversationContext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationContextFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationContextFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationContextClient<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationContexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationContextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationContexts
     * const conversationContexts = await prisma.conversationContext.findMany()
     * 
     * // Get first 10 ConversationContexts
     * const conversationContexts = await prisma.conversationContext.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationContextWithIdOnly = await prisma.conversationContext.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationContextFindManyArgs>(args?: SelectSubset<T, ConversationContextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationContext.
     * @param {ConversationContextCreateArgs} args - Arguments to create a ConversationContext.
     * @example
     * // Create one ConversationContext
     * const ConversationContext = await prisma.conversationContext.create({
     *   data: {
     *     // ... data to create a ConversationContext
     *   }
     * })
     * 
     */
    create<T extends ConversationContextCreateArgs>(args: SelectSubset<T, ConversationContextCreateArgs<ExtArgs>>): Prisma__ConversationContextClient<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationContexts.
     * @param {ConversationContextCreateManyArgs} args - Arguments to create many ConversationContexts.
     * @example
     * // Create many ConversationContexts
     * const conversationContext = await prisma.conversationContext.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationContextCreateManyArgs>(args?: SelectSubset<T, ConversationContextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationContexts and returns the data saved in the database.
     * @param {ConversationContextCreateManyAndReturnArgs} args - Arguments to create many ConversationContexts.
     * @example
     * // Create many ConversationContexts
     * const conversationContext = await prisma.conversationContext.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationContexts and only return the `id`
     * const conversationContextWithIdOnly = await prisma.conversationContext.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationContextCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationContextCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationContext.
     * @param {ConversationContextDeleteArgs} args - Arguments to delete one ConversationContext.
     * @example
     * // Delete one ConversationContext
     * const ConversationContext = await prisma.conversationContext.delete({
     *   where: {
     *     // ... filter to delete one ConversationContext
     *   }
     * })
     * 
     */
    delete<T extends ConversationContextDeleteArgs>(args: SelectSubset<T, ConversationContextDeleteArgs<ExtArgs>>): Prisma__ConversationContextClient<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationContext.
     * @param {ConversationContextUpdateArgs} args - Arguments to update one ConversationContext.
     * @example
     * // Update one ConversationContext
     * const conversationContext = await prisma.conversationContext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationContextUpdateArgs>(args: SelectSubset<T, ConversationContextUpdateArgs<ExtArgs>>): Prisma__ConversationContextClient<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationContexts.
     * @param {ConversationContextDeleteManyArgs} args - Arguments to filter ConversationContexts to delete.
     * @example
     * // Delete a few ConversationContexts
     * const { count } = await prisma.conversationContext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationContextDeleteManyArgs>(args?: SelectSubset<T, ConversationContextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationContexts
     * const conversationContext = await prisma.conversationContext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationContextUpdateManyArgs>(args: SelectSubset<T, ConversationContextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationContexts and returns the data updated in the database.
     * @param {ConversationContextUpdateManyAndReturnArgs} args - Arguments to update many ConversationContexts.
     * @example
     * // Update many ConversationContexts
     * const conversationContext = await prisma.conversationContext.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationContexts and only return the `id`
     * const conversationContextWithIdOnly = await prisma.conversationContext.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationContextUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationContextUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationContext.
     * @param {ConversationContextUpsertArgs} args - Arguments to update or create a ConversationContext.
     * @example
     * // Update or create a ConversationContext
     * const conversationContext = await prisma.conversationContext.upsert({
     *   create: {
     *     // ... data to create a ConversationContext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationContext we want to update
     *   }
     * })
     */
    upsert<T extends ConversationContextUpsertArgs>(args: SelectSubset<T, ConversationContextUpsertArgs<ExtArgs>>): Prisma__ConversationContextClient<$Result.GetResult<Prisma.$ConversationContextPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationContextCountArgs} args - Arguments to filter ConversationContexts to count.
     * @example
     * // Count the number of ConversationContexts
     * const count = await prisma.conversationContext.count({
     *   where: {
     *     // ... the filter for the ConversationContexts we want to count
     *   }
     * })
    **/
    count<T extends ConversationContextCountArgs>(
      args?: Subset<T, ConversationContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationContextAggregateArgs>(args: Subset<T, ConversationContextAggregateArgs>): Prisma.PrismaPromise<GetConversationContextAggregateType<T>>

    /**
     * Group by ConversationContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationContextGroupByArgs['orderBy'] }
        : { orderBy?: ConversationContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationContext model
   */
  readonly fields: ConversationContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationContext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationContext model
   */
  interface ConversationContextFieldRefs {
    readonly id: FieldRef<"ConversationContext", 'String'>
    readonly tenantId: FieldRef<"ConversationContext", 'String'>
    readonly conversationId: FieldRef<"ConversationContext", 'String'>
    readonly version: FieldRef<"ConversationContext", 'Int'>
    readonly data: FieldRef<"ConversationContext", 'Json'>
    readonly createdAt: FieldRef<"ConversationContext", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationContext findUnique
   */
  export type ConversationContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * Filter, which ConversationContext to fetch.
     */
    where: ConversationContextWhereUniqueInput
  }

  /**
   * ConversationContext findUniqueOrThrow
   */
  export type ConversationContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * Filter, which ConversationContext to fetch.
     */
    where: ConversationContextWhereUniqueInput
  }

  /**
   * ConversationContext findFirst
   */
  export type ConversationContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * Filter, which ConversationContext to fetch.
     */
    where?: ConversationContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationContexts to fetch.
     */
    orderBy?: ConversationContextOrderByWithRelationInput | ConversationContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationContexts.
     */
    cursor?: ConversationContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationContexts.
     */
    distinct?: ConversationContextScalarFieldEnum | ConversationContextScalarFieldEnum[]
  }

  /**
   * ConversationContext findFirstOrThrow
   */
  export type ConversationContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * Filter, which ConversationContext to fetch.
     */
    where?: ConversationContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationContexts to fetch.
     */
    orderBy?: ConversationContextOrderByWithRelationInput | ConversationContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationContexts.
     */
    cursor?: ConversationContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationContexts.
     */
    distinct?: ConversationContextScalarFieldEnum | ConversationContextScalarFieldEnum[]
  }

  /**
   * ConversationContext findMany
   */
  export type ConversationContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * Filter, which ConversationContexts to fetch.
     */
    where?: ConversationContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationContexts to fetch.
     */
    orderBy?: ConversationContextOrderByWithRelationInput | ConversationContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationContexts.
     */
    cursor?: ConversationContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationContexts.
     */
    skip?: number
    distinct?: ConversationContextScalarFieldEnum | ConversationContextScalarFieldEnum[]
  }

  /**
   * ConversationContext create
   */
  export type ConversationContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationContext.
     */
    data: XOR<ConversationContextCreateInput, ConversationContextUncheckedCreateInput>
  }

  /**
   * ConversationContext createMany
   */
  export type ConversationContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationContexts.
     */
    data: ConversationContextCreateManyInput | ConversationContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationContext createManyAndReturn
   */
  export type ConversationContextCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationContexts.
     */
    data: ConversationContextCreateManyInput | ConversationContextCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationContext update
   */
  export type ConversationContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationContext.
     */
    data: XOR<ConversationContextUpdateInput, ConversationContextUncheckedUpdateInput>
    /**
     * Choose, which ConversationContext to update.
     */
    where: ConversationContextWhereUniqueInput
  }

  /**
   * ConversationContext updateMany
   */
  export type ConversationContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationContexts.
     */
    data: XOR<ConversationContextUpdateManyMutationInput, ConversationContextUncheckedUpdateManyInput>
    /**
     * Filter which ConversationContexts to update
     */
    where?: ConversationContextWhereInput
    /**
     * Limit how many ConversationContexts to update.
     */
    limit?: number
  }

  /**
   * ConversationContext updateManyAndReturn
   */
  export type ConversationContextUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * The data used to update ConversationContexts.
     */
    data: XOR<ConversationContextUpdateManyMutationInput, ConversationContextUncheckedUpdateManyInput>
    /**
     * Filter which ConversationContexts to update
     */
    where?: ConversationContextWhereInput
    /**
     * Limit how many ConversationContexts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationContext upsert
   */
  export type ConversationContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationContext to update in case it exists.
     */
    where: ConversationContextWhereUniqueInput
    /**
     * In case the ConversationContext found by the `where` argument doesn't exist, create a new ConversationContext with this data.
     */
    create: XOR<ConversationContextCreateInput, ConversationContextUncheckedCreateInput>
    /**
     * In case the ConversationContext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationContextUpdateInput, ConversationContextUncheckedUpdateInput>
  }

  /**
   * ConversationContext delete
   */
  export type ConversationContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
    /**
     * Filter which ConversationContext to delete.
     */
    where: ConversationContextWhereUniqueInput
  }

  /**
   * ConversationContext deleteMany
   */
  export type ConversationContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationContexts to delete
     */
    where?: ConversationContextWhereInput
    /**
     * Limit how many ConversationContexts to delete.
     */
    limit?: number
  }

  /**
   * ConversationContext without action
   */
  export type ConversationContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationContext
     */
    select?: ConversationContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationContext
     */
    omit?: ConversationContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationContextInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombreCompleto: 'nombreCompleto',
    correo: 'correo',
    telefono: 'telefono',
    passwordHash: 'passwordHash',
    primerIngreso: 'primerIngreso',
    rol: 'rol',
    estado: 'estado',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const IntentoLoginScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    correo: 'correo',
    tipo: 'tipo',
    exitoso: 'exitoso',
    origen: 'origen',
    ip: 'ip',
    userAgent: 'userAgent',
    motivoFallo: 'motivoFallo',
    creadoEn: 'creadoEn'
  };

  export type IntentoLoginScalarFieldEnum = (typeof IntentoLoginScalarFieldEnum)[keyof typeof IntentoLoginScalarFieldEnum]


  export const SesionScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    token: 'token',
    ip: 'ip',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    ultimoAcceso: 'ultimoAcceso',
    activa: 'activa',
    creadaEn: 'creadaEn'
  };

  export type SesionScalarFieldEnum = (typeof SesionScalarFieldEnum)[keyof typeof SesionScalarFieldEnum]


  export const EstudianteScalarFieldEnum: {
    id: 'id',
    documento: 'documento',
    nombre: 'nombre',
    correo: 'correo',
    telefono: 'telefono',
    programa: 'programa',
    semestre: 'semestre',
    modalidad: 'modalidad',
    estado: 'estado',
    estadoCuenta: 'estadoCuenta',
    accesoCitas: 'accesoCitas',
    acudimientos: 'acudimientos',
    fechaInicio: 'fechaInicio',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type EstudianteScalarFieldEnum = (typeof EstudianteScalarFieldEnum)[keyof typeof EstudianteScalarFieldEnum]


  export const CitaScalarFieldEnum: {
    id: 'id',
    estudianteId: 'estudianteId',
    fecha: 'fecha',
    hora: 'hora',
    modalidad: 'modalidad',
    motivo: 'motivo',
    estado: 'estado',
    usuarioNombre: 'usuarioNombre',
    usuarioTipoDocumento: 'usuarioTipoDocumento',
    usuarioNumeroDocumento: 'usuarioNumeroDocumento',
    usuarioCorreo: 'usuarioCorreo',
    usuarioTelefono: 'usuarioTelefono',
    enlaceReunion: 'enlaceReunion',
    conversacionId: 'conversacionId',
    notifEnviada24h: 'notifEnviada24h',
    notifEnviada15m: 'notifEnviada15m',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type CitaScalarFieldEnum = (typeof CitaScalarFieldEnum)[keyof typeof CitaScalarFieldEnum]


  export const AuditoriaScalarFieldEnum: {
    id: 'id',
    accion: 'accion',
    entidad: 'entidad',
    entidadId: 'entidadId',
    detalles: 'detalles',
    adminId: 'adminId',
    adminNombre: 'adminNombre',
    ip: 'ip',
    userAgent: 'userAgent',
    creadoEn: 'creadoEn'
  };

  export type AuditoriaScalarFieldEnum = (typeof AuditoriaScalarFieldEnum)[keyof typeof AuditoriaScalarFieldEnum]


  export const ConfiguracionWhatsAppScalarFieldEnum: {
    id: 'id',
    nombreBot: 'nombreBot',
    phoneNumberId: 'phoneNumberId',
    businessAccountId: 'businessAccountId',
    webhookVerifyToken: 'webhookVerifyToken',
    webhookUrl: 'webhookUrl',
    tokenAcceso: 'tokenAcceso',
    activo: 'activo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfiguracionWhatsAppScalarFieldEnum = (typeof ConfiguracionWhatsAppScalarFieldEnum)[keyof typeof ConfiguracionWhatsAppScalarFieldEnum]


  export const WebhookLogScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    payload: 'payload',
    processed: 'processed',
    createdAt: 'createdAt'
  };

  export type WebhookLogScalarFieldEnum = (typeof WebhookLogScalarFieldEnum)[keyof typeof WebhookLogScalarFieldEnum]


  export const PlantillaMensajeScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    contenido: 'contenido',
    tipo: 'tipo',
    idioma: 'idioma',
    activa: 'activa',
    createdAt: 'createdAt'
  };

  export type PlantillaMensajeScalarFieldEnum = (typeof PlantillaMensajeScalarFieldEnum)[keyof typeof PlantillaMensajeScalarFieldEnum]


  export const ConversacionScalarFieldEnum: {
    id: 'id',
    estudianteId: 'estudianteId',
    temaLegal: 'temaLegal',
    consultorio: 'consultorio',
    estado: 'estado',
    canal: 'canal',
    primerMensaje: 'primerMensaje',
    resumen: 'resumen',
    createdAt: 'createdAt'
  };

  export type ConversacionScalarFieldEnum = (typeof ConversacionScalarFieldEnum)[keyof typeof ConversacionScalarFieldEnum]


  export const MensajeScalarFieldEnum: {
    id: 'id',
    conversacionId: 'conversacionId',
    tipo: 'tipo',
    contenido: 'contenido',
    createdAt: 'createdAt'
  };

  export type MensajeScalarFieldEnum = (typeof MensajeScalarFieldEnum)[keyof typeof MensajeScalarFieldEnum]


  export const AsesoramientoScalarFieldEnum: {
    id: 'id',
    conversacionId: 'conversacionId',
    estudianteId: 'estudianteId',
    temaLegal: 'temaLegal',
    resumen: 'resumen',
    duracionMinutos: 'duracionMinutos',
    createdAt: 'createdAt'
  };

  export type AsesoramientoScalarFieldEnum = (typeof AsesoramientoScalarFieldEnum)[keyof typeof AsesoramientoScalarFieldEnum]


  export const EncuestaSatisfaccionScalarFieldEnum: {
    id: 'id',
    conversacionId: 'conversacionId',
    estudianteId: 'estudianteId',
    calificacion: 'calificacion',
    comentario: 'comentario',
    respondida: 'respondida',
    fuente: 'fuente',
    createdAt: 'createdAt'
  };

  export type EncuestaSatisfaccionScalarFieldEnum = (typeof EncuestaSatisfaccionScalarFieldEnum)[keyof typeof EncuestaSatisfaccionScalarFieldEnum]


  export const MetricaMensualScalarFieldEnum: {
    id: 'id',
    anio: 'anio',
    mes: 'mes',
    totalConversaciones: 'totalConversaciones',
    totalAsesoramientos: 'totalAsesoramientos',
    totalCitas: 'totalCitas',
    citasCompletadas: 'citasCompletadas',
    citasCanceladas: 'citasCanceladas',
    promedioSatisfaccion: 'promedioSatisfaccion',
    totalEncuestas: 'totalEncuestas'
  };

  export type MetricaMensualScalarFieldEnum = (typeof MetricaMensualScalarFieldEnum)[keyof typeof MetricaMensualScalarFieldEnum]


  export const NotificacionScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    titulo: 'titulo',
    mensaje: 'mensaje',
    prioridad: 'prioridad',
    leida: 'leida',
    estudianteId: 'estudianteId',
    createdAt: 'createdAt'
  };

  export type NotificacionScalarFieldEnum = (typeof NotificacionScalarFieldEnum)[keyof typeof NotificacionScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    channel: 'channel',
    externalId: 'externalId',
    displayName: 'displayName',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactId: 'contactId',
    channel: 'channel',
    status: 'status',
    lastMessageAt: 'lastMessageAt',
    currentFlowVersionId: 'currentFlowVersionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    conversationId: 'conversationId',
    contactId: 'contactId',
    direction: 'direction',
    type: 'type',
    text: 'text',
    payload: 'payload',
    providerMessageId: 'providerMessageId',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ConversationContextScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    conversationId: 'conversationId',
    version: 'version',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type ConversationContextScalarFieldEnum = (typeof ConversationContextScalarFieldEnum)[keyof typeof ConversationContextScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Rol[]'
   */
  export type ListEnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol[]'>
    


  /**
   * Reference to a field of type 'EstadoUsuario'
   */
  export type EnumEstadoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoUsuario'>
    


  /**
   * Reference to a field of type 'EstadoUsuario[]'
   */
  export type ListEnumEstadoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoUsuario[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TipoIntentoLogin'
   */
  export type EnumTipoIntentoLoginFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoIntentoLogin'>
    


  /**
   * Reference to a field of type 'TipoIntentoLogin[]'
   */
  export type ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoIntentoLogin[]'>
    


  /**
   * Reference to a field of type 'OrigenIntento'
   */
  export type EnumOrigenIntentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrigenIntento'>
    


  /**
   * Reference to a field of type 'OrigenIntento[]'
   */
  export type ListEnumOrigenIntentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrigenIntento[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Modalidad'
   */
  export type EnumModalidadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Modalidad'>
    


  /**
   * Reference to a field of type 'Modalidad[]'
   */
  export type ListEnumModalidadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Modalidad[]'>
    


  /**
   * Reference to a field of type 'EstadoEstudiante'
   */
  export type EnumEstadoEstudianteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoEstudiante'>
    


  /**
   * Reference to a field of type 'EstadoEstudiante[]'
   */
  export type ListEnumEstadoEstudianteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoEstudiante[]'>
    


  /**
   * Reference to a field of type 'EstadoCita'
   */
  export type EnumEstadoCitaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoCita'>
    


  /**
   * Reference to a field of type 'EstadoCita[]'
   */
  export type ListEnumEstadoCitaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoCita[]'>
    


  /**
   * Reference to a field of type 'TipoAuditoria'
   */
  export type EnumTipoAuditoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoAuditoria'>
    


  /**
   * Reference to a field of type 'TipoAuditoria[]'
   */
  export type ListEnumTipoAuditoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoAuditoria[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Channel'
   */
  export type EnumChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Channel'>
    


  /**
   * Reference to a field of type 'Channel[]'
   */
  export type ListEnumChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Channel[]'>
    


  /**
   * Reference to a field of type 'ConversationStatus'
   */
  export type EnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus'>
    


  /**
   * Reference to a field of type 'ConversationStatus[]'
   */
  export type ListEnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus[]'>
    


  /**
   * Reference to a field of type 'Direction'
   */
  export type EnumDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Direction'>
    


  /**
   * Reference to a field of type 'Direction[]'
   */
  export type ListEnumDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Direction[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    nombreCompleto?: StringFilter<"Usuario"> | string
    correo?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    passwordHash?: StringFilter<"Usuario"> | string
    primerIngreso?: BoolFilter<"Usuario"> | boolean
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    estado?: EnumEstadoUsuarioFilter<"Usuario"> | $Enums.EstadoUsuario
    creadoEn?: DateTimeFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeFilter<"Usuario"> | Date | string
    intentosLogin?: IntentoLoginListRelationFilter
    sesiones?: SesionListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombreCompleto?: SortOrder
    correo?: SortOrder
    telefono?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    primerIngreso?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    intentosLogin?: IntentoLoginOrderByRelationAggregateInput
    sesiones?: SesionOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    correo?: string
    telefono?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombreCompleto?: StringFilter<"Usuario"> | string
    passwordHash?: StringFilter<"Usuario"> | string
    primerIngreso?: BoolFilter<"Usuario"> | boolean
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    estado?: EnumEstadoUsuarioFilter<"Usuario"> | $Enums.EstadoUsuario
    creadoEn?: DateTimeFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeFilter<"Usuario"> | Date | string
    intentosLogin?: IntentoLoginListRelationFilter
    sesiones?: SesionListRelationFilter
  }, "id" | "correo" | "telefono">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombreCompleto?: SortOrder
    correo?: SortOrder
    telefono?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    primerIngreso?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    nombreCompleto?: StringWithAggregatesFilter<"Usuario"> | string
    correo?: StringWithAggregatesFilter<"Usuario"> | string
    telefono?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    passwordHash?: StringWithAggregatesFilter<"Usuario"> | string
    primerIngreso?: BoolWithAggregatesFilter<"Usuario"> | boolean
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    estado?: EnumEstadoUsuarioWithAggregatesFilter<"Usuario"> | $Enums.EstadoUsuario
    creadoEn?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type IntentoLoginWhereInput = {
    AND?: IntentoLoginWhereInput | IntentoLoginWhereInput[]
    OR?: IntentoLoginWhereInput[]
    NOT?: IntentoLoginWhereInput | IntentoLoginWhereInput[]
    id?: StringFilter<"IntentoLogin"> | string
    usuarioId?: StringNullableFilter<"IntentoLogin"> | string | null
    correo?: StringFilter<"IntentoLogin"> | string
    tipo?: EnumTipoIntentoLoginFilter<"IntentoLogin"> | $Enums.TipoIntentoLogin
    exitoso?: BoolFilter<"IntentoLogin"> | boolean
    origen?: EnumOrigenIntentoFilter<"IntentoLogin"> | $Enums.OrigenIntento
    ip?: StringNullableFilter<"IntentoLogin"> | string | null
    userAgent?: StringNullableFilter<"IntentoLogin"> | string | null
    motivoFallo?: StringNullableFilter<"IntentoLogin"> | string | null
    creadoEn?: DateTimeFilter<"IntentoLogin"> | Date | string
    usuario?: XOR<UsuarioNullableScalarRelationFilter, UsuarioWhereInput> | null
  }

  export type IntentoLoginOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrderInput | SortOrder
    correo?: SortOrder
    tipo?: SortOrder
    exitoso?: SortOrder
    origen?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    motivoFallo?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type IntentoLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntentoLoginWhereInput | IntentoLoginWhereInput[]
    OR?: IntentoLoginWhereInput[]
    NOT?: IntentoLoginWhereInput | IntentoLoginWhereInput[]
    usuarioId?: StringNullableFilter<"IntentoLogin"> | string | null
    correo?: StringFilter<"IntentoLogin"> | string
    tipo?: EnumTipoIntentoLoginFilter<"IntentoLogin"> | $Enums.TipoIntentoLogin
    exitoso?: BoolFilter<"IntentoLogin"> | boolean
    origen?: EnumOrigenIntentoFilter<"IntentoLogin"> | $Enums.OrigenIntento
    ip?: StringNullableFilter<"IntentoLogin"> | string | null
    userAgent?: StringNullableFilter<"IntentoLogin"> | string | null
    motivoFallo?: StringNullableFilter<"IntentoLogin"> | string | null
    creadoEn?: DateTimeFilter<"IntentoLogin"> | Date | string
    usuario?: XOR<UsuarioNullableScalarRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type IntentoLoginOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrderInput | SortOrder
    correo?: SortOrder
    tipo?: SortOrder
    exitoso?: SortOrder
    origen?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    motivoFallo?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    _count?: IntentoLoginCountOrderByAggregateInput
    _max?: IntentoLoginMaxOrderByAggregateInput
    _min?: IntentoLoginMinOrderByAggregateInput
  }

  export type IntentoLoginScalarWhereWithAggregatesInput = {
    AND?: IntentoLoginScalarWhereWithAggregatesInput | IntentoLoginScalarWhereWithAggregatesInput[]
    OR?: IntentoLoginScalarWhereWithAggregatesInput[]
    NOT?: IntentoLoginScalarWhereWithAggregatesInput | IntentoLoginScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntentoLogin"> | string
    usuarioId?: StringNullableWithAggregatesFilter<"IntentoLogin"> | string | null
    correo?: StringWithAggregatesFilter<"IntentoLogin"> | string
    tipo?: EnumTipoIntentoLoginWithAggregatesFilter<"IntentoLogin"> | $Enums.TipoIntentoLogin
    exitoso?: BoolWithAggregatesFilter<"IntentoLogin"> | boolean
    origen?: EnumOrigenIntentoWithAggregatesFilter<"IntentoLogin"> | $Enums.OrigenIntento
    ip?: StringNullableWithAggregatesFilter<"IntentoLogin"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"IntentoLogin"> | string | null
    motivoFallo?: StringNullableWithAggregatesFilter<"IntentoLogin"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"IntentoLogin"> | Date | string
  }

  export type SesionWhereInput = {
    AND?: SesionWhereInput | SesionWhereInput[]
    OR?: SesionWhereInput[]
    NOT?: SesionWhereInput | SesionWhereInput[]
    id?: StringFilter<"Sesion"> | string
    usuarioId?: StringFilter<"Sesion"> | string
    token?: StringFilter<"Sesion"> | string
    ip?: StringNullableFilter<"Sesion"> | string | null
    userAgent?: StringNullableFilter<"Sesion"> | string | null
    expiresAt?: DateTimeFilter<"Sesion"> | Date | string
    ultimoAcceso?: DateTimeFilter<"Sesion"> | Date | string
    activa?: BoolFilter<"Sesion"> | boolean
    creadaEn?: DateTimeFilter<"Sesion"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type SesionOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    ultimoAcceso?: SortOrder
    activa?: SortOrder
    creadaEn?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type SesionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SesionWhereInput | SesionWhereInput[]
    OR?: SesionWhereInput[]
    NOT?: SesionWhereInput | SesionWhereInput[]
    usuarioId?: StringFilter<"Sesion"> | string
    ip?: StringNullableFilter<"Sesion"> | string | null
    userAgent?: StringNullableFilter<"Sesion"> | string | null
    expiresAt?: DateTimeFilter<"Sesion"> | Date | string
    ultimoAcceso?: DateTimeFilter<"Sesion"> | Date | string
    activa?: BoolFilter<"Sesion"> | boolean
    creadaEn?: DateTimeFilter<"Sesion"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id" | "token">

  export type SesionOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    ultimoAcceso?: SortOrder
    activa?: SortOrder
    creadaEn?: SortOrder
    _count?: SesionCountOrderByAggregateInput
    _max?: SesionMaxOrderByAggregateInput
    _min?: SesionMinOrderByAggregateInput
  }

  export type SesionScalarWhereWithAggregatesInput = {
    AND?: SesionScalarWhereWithAggregatesInput | SesionScalarWhereWithAggregatesInput[]
    OR?: SesionScalarWhereWithAggregatesInput[]
    NOT?: SesionScalarWhereWithAggregatesInput | SesionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sesion"> | string
    usuarioId?: StringWithAggregatesFilter<"Sesion"> | string
    token?: StringWithAggregatesFilter<"Sesion"> | string
    ip?: StringNullableWithAggregatesFilter<"Sesion"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Sesion"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Sesion"> | Date | string
    ultimoAcceso?: DateTimeWithAggregatesFilter<"Sesion"> | Date | string
    activa?: BoolWithAggregatesFilter<"Sesion"> | boolean
    creadaEn?: DateTimeWithAggregatesFilter<"Sesion"> | Date | string
  }

  export type EstudianteWhereInput = {
    AND?: EstudianteWhereInput | EstudianteWhereInput[]
    OR?: EstudianteWhereInput[]
    NOT?: EstudianteWhereInput | EstudianteWhereInput[]
    id?: StringFilter<"Estudiante"> | string
    documento?: StringFilter<"Estudiante"> | string
    nombre?: StringFilter<"Estudiante"> | string
    correo?: StringNullableFilter<"Estudiante"> | string | null
    telefono?: StringNullableFilter<"Estudiante"> | string | null
    programa?: StringNullableFilter<"Estudiante"> | string | null
    semestre?: IntNullableFilter<"Estudiante"> | number | null
    modalidad?: EnumModalidadFilter<"Estudiante"> | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFilter<"Estudiante"> | $Enums.EstadoEstudiante
    estadoCuenta?: StringFilter<"Estudiante"> | string
    accesoCitas?: BoolFilter<"Estudiante"> | boolean
    acudimientos?: BoolFilter<"Estudiante"> | boolean
    fechaInicio?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    creadoEn?: DateTimeFilter<"Estudiante"> | Date | string
    actualizadoEn?: DateTimeFilter<"Estudiante"> | Date | string
    citas?: CitaListRelationFilter
    conversaciones?: ConversacionListRelationFilter
    encuestas?: EncuestaSatisfaccionListRelationFilter
    asesoramiento?: AsesoramientoListRelationFilter
  }

  export type EstudianteOrderByWithRelationInput = {
    id?: SortOrder
    documento?: SortOrder
    nombre?: SortOrder
    correo?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    programa?: SortOrderInput | SortOrder
    semestre?: SortOrderInput | SortOrder
    modalidad?: SortOrder
    estado?: SortOrder
    estadoCuenta?: SortOrder
    accesoCitas?: SortOrder
    acudimientos?: SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    citas?: CitaOrderByRelationAggregateInput
    conversaciones?: ConversacionOrderByRelationAggregateInput
    encuestas?: EncuestaSatisfaccionOrderByRelationAggregateInput
    asesoramiento?: AsesoramientoOrderByRelationAggregateInput
  }

  export type EstudianteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documento?: string
    AND?: EstudianteWhereInput | EstudianteWhereInput[]
    OR?: EstudianteWhereInput[]
    NOT?: EstudianteWhereInput | EstudianteWhereInput[]
    nombre?: StringFilter<"Estudiante"> | string
    correo?: StringNullableFilter<"Estudiante"> | string | null
    telefono?: StringNullableFilter<"Estudiante"> | string | null
    programa?: StringNullableFilter<"Estudiante"> | string | null
    semestre?: IntNullableFilter<"Estudiante"> | number | null
    modalidad?: EnumModalidadFilter<"Estudiante"> | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFilter<"Estudiante"> | $Enums.EstadoEstudiante
    estadoCuenta?: StringFilter<"Estudiante"> | string
    accesoCitas?: BoolFilter<"Estudiante"> | boolean
    acudimientos?: BoolFilter<"Estudiante"> | boolean
    fechaInicio?: DateTimeNullableFilter<"Estudiante"> | Date | string | null
    creadoEn?: DateTimeFilter<"Estudiante"> | Date | string
    actualizadoEn?: DateTimeFilter<"Estudiante"> | Date | string
    citas?: CitaListRelationFilter
    conversaciones?: ConversacionListRelationFilter
    encuestas?: EncuestaSatisfaccionListRelationFilter
    asesoramiento?: AsesoramientoListRelationFilter
  }, "id" | "documento">

  export type EstudianteOrderByWithAggregationInput = {
    id?: SortOrder
    documento?: SortOrder
    nombre?: SortOrder
    correo?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    programa?: SortOrderInput | SortOrder
    semestre?: SortOrderInput | SortOrder
    modalidad?: SortOrder
    estado?: SortOrder
    estadoCuenta?: SortOrder
    accesoCitas?: SortOrder
    acudimientos?: SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: EstudianteCountOrderByAggregateInput
    _avg?: EstudianteAvgOrderByAggregateInput
    _max?: EstudianteMaxOrderByAggregateInput
    _min?: EstudianteMinOrderByAggregateInput
    _sum?: EstudianteSumOrderByAggregateInput
  }

  export type EstudianteScalarWhereWithAggregatesInput = {
    AND?: EstudianteScalarWhereWithAggregatesInput | EstudianteScalarWhereWithAggregatesInput[]
    OR?: EstudianteScalarWhereWithAggregatesInput[]
    NOT?: EstudianteScalarWhereWithAggregatesInput | EstudianteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Estudiante"> | string
    documento?: StringWithAggregatesFilter<"Estudiante"> | string
    nombre?: StringWithAggregatesFilter<"Estudiante"> | string
    correo?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    programa?: StringNullableWithAggregatesFilter<"Estudiante"> | string | null
    semestre?: IntNullableWithAggregatesFilter<"Estudiante"> | number | null
    modalidad?: EnumModalidadWithAggregatesFilter<"Estudiante"> | $Enums.Modalidad
    estado?: EnumEstadoEstudianteWithAggregatesFilter<"Estudiante"> | $Enums.EstadoEstudiante
    estadoCuenta?: StringWithAggregatesFilter<"Estudiante"> | string
    accesoCitas?: BoolWithAggregatesFilter<"Estudiante"> | boolean
    acudimientos?: BoolWithAggregatesFilter<"Estudiante"> | boolean
    fechaInicio?: DateTimeNullableWithAggregatesFilter<"Estudiante"> | Date | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"Estudiante"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Estudiante"> | Date | string
  }

  export type CitaWhereInput = {
    AND?: CitaWhereInput | CitaWhereInput[]
    OR?: CitaWhereInput[]
    NOT?: CitaWhereInput | CitaWhereInput[]
    id?: StringFilter<"Cita"> | string
    estudianteId?: StringFilter<"Cita"> | string
    fecha?: DateTimeFilter<"Cita"> | Date | string
    hora?: StringFilter<"Cita"> | string
    modalidad?: EnumModalidadFilter<"Cita"> | $Enums.Modalidad
    motivo?: StringNullableFilter<"Cita"> | string | null
    estado?: EnumEstadoCitaFilter<"Cita"> | $Enums.EstadoCita
    usuarioNombre?: StringNullableFilter<"Cita"> | string | null
    usuarioTipoDocumento?: StringNullableFilter<"Cita"> | string | null
    usuarioNumeroDocumento?: StringNullableFilter<"Cita"> | string | null
    usuarioCorreo?: StringNullableFilter<"Cita"> | string | null
    usuarioTelefono?: StringNullableFilter<"Cita"> | string | null
    enlaceReunion?: StringNullableFilter<"Cita"> | string | null
    conversacionId?: StringNullableFilter<"Cita"> | string | null
    notifEnviada24h?: BoolFilter<"Cita"> | boolean
    notifEnviada15m?: BoolFilter<"Cita"> | boolean
    creadoEn?: DateTimeFilter<"Cita"> | Date | string
    actualizadoEn?: DateTimeFilter<"Cita"> | Date | string
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
    conversacion?: XOR<ConversacionNullableScalarRelationFilter, ConversacionWhereInput> | null
  }

  export type CitaOrderByWithRelationInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    modalidad?: SortOrder
    motivo?: SortOrderInput | SortOrder
    estado?: SortOrder
    usuarioNombre?: SortOrderInput | SortOrder
    usuarioTipoDocumento?: SortOrderInput | SortOrder
    usuarioNumeroDocumento?: SortOrderInput | SortOrder
    usuarioCorreo?: SortOrderInput | SortOrder
    usuarioTelefono?: SortOrderInput | SortOrder
    enlaceReunion?: SortOrderInput | SortOrder
    conversacionId?: SortOrderInput | SortOrder
    notifEnviada24h?: SortOrder
    notifEnviada15m?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
    conversacion?: ConversacionOrderByWithRelationInput
  }

  export type CitaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CitaWhereInput | CitaWhereInput[]
    OR?: CitaWhereInput[]
    NOT?: CitaWhereInput | CitaWhereInput[]
    estudianteId?: StringFilter<"Cita"> | string
    fecha?: DateTimeFilter<"Cita"> | Date | string
    hora?: StringFilter<"Cita"> | string
    modalidad?: EnumModalidadFilter<"Cita"> | $Enums.Modalidad
    motivo?: StringNullableFilter<"Cita"> | string | null
    estado?: EnumEstadoCitaFilter<"Cita"> | $Enums.EstadoCita
    usuarioNombre?: StringNullableFilter<"Cita"> | string | null
    usuarioTipoDocumento?: StringNullableFilter<"Cita"> | string | null
    usuarioNumeroDocumento?: StringNullableFilter<"Cita"> | string | null
    usuarioCorreo?: StringNullableFilter<"Cita"> | string | null
    usuarioTelefono?: StringNullableFilter<"Cita"> | string | null
    enlaceReunion?: StringNullableFilter<"Cita"> | string | null
    conversacionId?: StringNullableFilter<"Cita"> | string | null
    notifEnviada24h?: BoolFilter<"Cita"> | boolean
    notifEnviada15m?: BoolFilter<"Cita"> | boolean
    creadoEn?: DateTimeFilter<"Cita"> | Date | string
    actualizadoEn?: DateTimeFilter<"Cita"> | Date | string
    estudiante?: XOR<EstudianteScalarRelationFilter, EstudianteWhereInput>
    conversacion?: XOR<ConversacionNullableScalarRelationFilter, ConversacionWhereInput> | null
  }, "id">

  export type CitaOrderByWithAggregationInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    modalidad?: SortOrder
    motivo?: SortOrderInput | SortOrder
    estado?: SortOrder
    usuarioNombre?: SortOrderInput | SortOrder
    usuarioTipoDocumento?: SortOrderInput | SortOrder
    usuarioNumeroDocumento?: SortOrderInput | SortOrder
    usuarioCorreo?: SortOrderInput | SortOrder
    usuarioTelefono?: SortOrderInput | SortOrder
    enlaceReunion?: SortOrderInput | SortOrder
    conversacionId?: SortOrderInput | SortOrder
    notifEnviada24h?: SortOrder
    notifEnviada15m?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: CitaCountOrderByAggregateInput
    _max?: CitaMaxOrderByAggregateInput
    _min?: CitaMinOrderByAggregateInput
  }

  export type CitaScalarWhereWithAggregatesInput = {
    AND?: CitaScalarWhereWithAggregatesInput | CitaScalarWhereWithAggregatesInput[]
    OR?: CitaScalarWhereWithAggregatesInput[]
    NOT?: CitaScalarWhereWithAggregatesInput | CitaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cita"> | string
    estudianteId?: StringWithAggregatesFilter<"Cita"> | string
    fecha?: DateTimeWithAggregatesFilter<"Cita"> | Date | string
    hora?: StringWithAggregatesFilter<"Cita"> | string
    modalidad?: EnumModalidadWithAggregatesFilter<"Cita"> | $Enums.Modalidad
    motivo?: StringNullableWithAggregatesFilter<"Cita"> | string | null
    estado?: EnumEstadoCitaWithAggregatesFilter<"Cita"> | $Enums.EstadoCita
    usuarioNombre?: StringNullableWithAggregatesFilter<"Cita"> | string | null
    usuarioTipoDocumento?: StringNullableWithAggregatesFilter<"Cita"> | string | null
    usuarioNumeroDocumento?: StringNullableWithAggregatesFilter<"Cita"> | string | null
    usuarioCorreo?: StringNullableWithAggregatesFilter<"Cita"> | string | null
    usuarioTelefono?: StringNullableWithAggregatesFilter<"Cita"> | string | null
    enlaceReunion?: StringNullableWithAggregatesFilter<"Cita"> | string | null
    conversacionId?: StringNullableWithAggregatesFilter<"Cita"> | string | null
    notifEnviada24h?: BoolWithAggregatesFilter<"Cita"> | boolean
    notifEnviada15m?: BoolWithAggregatesFilter<"Cita"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"Cita"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Cita"> | Date | string
  }

  export type AuditoriaWhereInput = {
    AND?: AuditoriaWhereInput | AuditoriaWhereInput[]
    OR?: AuditoriaWhereInput[]
    NOT?: AuditoriaWhereInput | AuditoriaWhereInput[]
    id?: StringFilter<"Auditoria"> | string
    accion?: EnumTipoAuditoriaFilter<"Auditoria"> | $Enums.TipoAuditoria
    entidad?: StringFilter<"Auditoria"> | string
    entidadId?: StringNullableFilter<"Auditoria"> | string | null
    detalles?: StringFilter<"Auditoria"> | string
    adminId?: StringNullableFilter<"Auditoria"> | string | null
    adminNombre?: StringNullableFilter<"Auditoria"> | string | null
    ip?: StringNullableFilter<"Auditoria"> | string | null
    userAgent?: StringNullableFilter<"Auditoria"> | string | null
    creadoEn?: DateTimeFilter<"Auditoria"> | Date | string
  }

  export type AuditoriaOrderByWithRelationInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrderInput | SortOrder
    detalles?: SortOrder
    adminId?: SortOrderInput | SortOrder
    adminNombre?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
  }

  export type AuditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditoriaWhereInput | AuditoriaWhereInput[]
    OR?: AuditoriaWhereInput[]
    NOT?: AuditoriaWhereInput | AuditoriaWhereInput[]
    accion?: EnumTipoAuditoriaFilter<"Auditoria"> | $Enums.TipoAuditoria
    entidad?: StringFilter<"Auditoria"> | string
    entidadId?: StringNullableFilter<"Auditoria"> | string | null
    detalles?: StringFilter<"Auditoria"> | string
    adminId?: StringNullableFilter<"Auditoria"> | string | null
    adminNombre?: StringNullableFilter<"Auditoria"> | string | null
    ip?: StringNullableFilter<"Auditoria"> | string | null
    userAgent?: StringNullableFilter<"Auditoria"> | string | null
    creadoEn?: DateTimeFilter<"Auditoria"> | Date | string
  }, "id">

  export type AuditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrderInput | SortOrder
    detalles?: SortOrder
    adminId?: SortOrderInput | SortOrder
    adminNombre?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    _count?: AuditoriaCountOrderByAggregateInput
    _max?: AuditoriaMaxOrderByAggregateInput
    _min?: AuditoriaMinOrderByAggregateInput
  }

  export type AuditoriaScalarWhereWithAggregatesInput = {
    AND?: AuditoriaScalarWhereWithAggregatesInput | AuditoriaScalarWhereWithAggregatesInput[]
    OR?: AuditoriaScalarWhereWithAggregatesInput[]
    NOT?: AuditoriaScalarWhereWithAggregatesInput | AuditoriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Auditoria"> | string
    accion?: EnumTipoAuditoriaWithAggregatesFilter<"Auditoria"> | $Enums.TipoAuditoria
    entidad?: StringWithAggregatesFilter<"Auditoria"> | string
    entidadId?: StringNullableWithAggregatesFilter<"Auditoria"> | string | null
    detalles?: StringWithAggregatesFilter<"Auditoria"> | string
    adminId?: StringNullableWithAggregatesFilter<"Auditoria"> | string | null
    adminNombre?: StringNullableWithAggregatesFilter<"Auditoria"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Auditoria"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Auditoria"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"Auditoria"> | Date | string
  }

  export type ConfiguracionWhatsAppWhereInput = {
    AND?: ConfiguracionWhatsAppWhereInput | ConfiguracionWhatsAppWhereInput[]
    OR?: ConfiguracionWhatsAppWhereInput[]
    NOT?: ConfiguracionWhatsAppWhereInput | ConfiguracionWhatsAppWhereInput[]
    id?: StringFilter<"ConfiguracionWhatsApp"> | string
    nombreBot?: StringFilter<"ConfiguracionWhatsApp"> | string
    phoneNumberId?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    businessAccountId?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    webhookVerifyToken?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    webhookUrl?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    tokenAcceso?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    activo?: BoolFilter<"ConfiguracionWhatsApp"> | boolean
    createdAt?: DateTimeFilter<"ConfiguracionWhatsApp"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracionWhatsApp"> | Date | string
  }

  export type ConfiguracionWhatsAppOrderByWithRelationInput = {
    id?: SortOrder
    nombreBot?: SortOrder
    phoneNumberId?: SortOrderInput | SortOrder
    businessAccountId?: SortOrderInput | SortOrder
    webhookVerifyToken?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    tokenAcceso?: SortOrderInput | SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionWhatsAppWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConfiguracionWhatsAppWhereInput | ConfiguracionWhatsAppWhereInput[]
    OR?: ConfiguracionWhatsAppWhereInput[]
    NOT?: ConfiguracionWhatsAppWhereInput | ConfiguracionWhatsAppWhereInput[]
    nombreBot?: StringFilter<"ConfiguracionWhatsApp"> | string
    phoneNumberId?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    businessAccountId?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    webhookVerifyToken?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    webhookUrl?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    tokenAcceso?: StringNullableFilter<"ConfiguracionWhatsApp"> | string | null
    activo?: BoolFilter<"ConfiguracionWhatsApp"> | boolean
    createdAt?: DateTimeFilter<"ConfiguracionWhatsApp"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracionWhatsApp"> | Date | string
  }, "id">

  export type ConfiguracionWhatsAppOrderByWithAggregationInput = {
    id?: SortOrder
    nombreBot?: SortOrder
    phoneNumberId?: SortOrderInput | SortOrder
    businessAccountId?: SortOrderInput | SortOrder
    webhookVerifyToken?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    tokenAcceso?: SortOrderInput | SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfiguracionWhatsAppCountOrderByAggregateInput
    _max?: ConfiguracionWhatsAppMaxOrderByAggregateInput
    _min?: ConfiguracionWhatsAppMinOrderByAggregateInput
  }

  export type ConfiguracionWhatsAppScalarWhereWithAggregatesInput = {
    AND?: ConfiguracionWhatsAppScalarWhereWithAggregatesInput | ConfiguracionWhatsAppScalarWhereWithAggregatesInput[]
    OR?: ConfiguracionWhatsAppScalarWhereWithAggregatesInput[]
    NOT?: ConfiguracionWhatsAppScalarWhereWithAggregatesInput | ConfiguracionWhatsAppScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConfiguracionWhatsApp"> | string
    nombreBot?: StringWithAggregatesFilter<"ConfiguracionWhatsApp"> | string
    phoneNumberId?: StringNullableWithAggregatesFilter<"ConfiguracionWhatsApp"> | string | null
    businessAccountId?: StringNullableWithAggregatesFilter<"ConfiguracionWhatsApp"> | string | null
    webhookVerifyToken?: StringNullableWithAggregatesFilter<"ConfiguracionWhatsApp"> | string | null
    webhookUrl?: StringNullableWithAggregatesFilter<"ConfiguracionWhatsApp"> | string | null
    tokenAcceso?: StringNullableWithAggregatesFilter<"ConfiguracionWhatsApp"> | string | null
    activo?: BoolWithAggregatesFilter<"ConfiguracionWhatsApp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ConfiguracionWhatsApp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfiguracionWhatsApp"> | Date | string
  }

  export type WebhookLogWhereInput = {
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    id?: StringFilter<"WebhookLog"> | string
    tipo?: StringFilter<"WebhookLog"> | string
    payload?: JsonFilter<"WebhookLog">
    processed?: BoolFilter<"WebhookLog"> | boolean
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }

  export type WebhookLogOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    tipo?: StringFilter<"WebhookLog"> | string
    payload?: JsonFilter<"WebhookLog">
    processed?: BoolFilter<"WebhookLog"> | boolean
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }, "id">

  export type WebhookLogOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookLogCountOrderByAggregateInput
    _max?: WebhookLogMaxOrderByAggregateInput
    _min?: WebhookLogMinOrderByAggregateInput
  }

  export type WebhookLogScalarWhereWithAggregatesInput = {
    AND?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    OR?: WebhookLogScalarWhereWithAggregatesInput[]
    NOT?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookLog"> | string
    tipo?: StringWithAggregatesFilter<"WebhookLog"> | string
    payload?: JsonWithAggregatesFilter<"WebhookLog">
    processed?: BoolWithAggregatesFilter<"WebhookLog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WebhookLog"> | Date | string
  }

  export type PlantillaMensajeWhereInput = {
    AND?: PlantillaMensajeWhereInput | PlantillaMensajeWhereInput[]
    OR?: PlantillaMensajeWhereInput[]
    NOT?: PlantillaMensajeWhereInput | PlantillaMensajeWhereInput[]
    id?: StringFilter<"PlantillaMensaje"> | string
    nombre?: StringFilter<"PlantillaMensaje"> | string
    contenido?: StringFilter<"PlantillaMensaje"> | string
    tipo?: StringFilter<"PlantillaMensaje"> | string
    idioma?: StringFilter<"PlantillaMensaje"> | string
    activa?: BoolFilter<"PlantillaMensaje"> | boolean
    createdAt?: DateTimeFilter<"PlantillaMensaje"> | Date | string
  }

  export type PlantillaMensajeOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    idioma?: SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
  }

  export type PlantillaMensajeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nombre?: string
    AND?: PlantillaMensajeWhereInput | PlantillaMensajeWhereInput[]
    OR?: PlantillaMensajeWhereInput[]
    NOT?: PlantillaMensajeWhereInput | PlantillaMensajeWhereInput[]
    contenido?: StringFilter<"PlantillaMensaje"> | string
    tipo?: StringFilter<"PlantillaMensaje"> | string
    idioma?: StringFilter<"PlantillaMensaje"> | string
    activa?: BoolFilter<"PlantillaMensaje"> | boolean
    createdAt?: DateTimeFilter<"PlantillaMensaje"> | Date | string
  }, "id" | "nombre">

  export type PlantillaMensajeOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    idioma?: SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
    _count?: PlantillaMensajeCountOrderByAggregateInput
    _max?: PlantillaMensajeMaxOrderByAggregateInput
    _min?: PlantillaMensajeMinOrderByAggregateInput
  }

  export type PlantillaMensajeScalarWhereWithAggregatesInput = {
    AND?: PlantillaMensajeScalarWhereWithAggregatesInput | PlantillaMensajeScalarWhereWithAggregatesInput[]
    OR?: PlantillaMensajeScalarWhereWithAggregatesInput[]
    NOT?: PlantillaMensajeScalarWhereWithAggregatesInput | PlantillaMensajeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlantillaMensaje"> | string
    nombre?: StringWithAggregatesFilter<"PlantillaMensaje"> | string
    contenido?: StringWithAggregatesFilter<"PlantillaMensaje"> | string
    tipo?: StringWithAggregatesFilter<"PlantillaMensaje"> | string
    idioma?: StringWithAggregatesFilter<"PlantillaMensaje"> | string
    activa?: BoolWithAggregatesFilter<"PlantillaMensaje"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlantillaMensaje"> | Date | string
  }

  export type ConversacionWhereInput = {
    AND?: ConversacionWhereInput | ConversacionWhereInput[]
    OR?: ConversacionWhereInput[]
    NOT?: ConversacionWhereInput | ConversacionWhereInput[]
    id?: StringFilter<"Conversacion"> | string
    estudianteId?: StringNullableFilter<"Conversacion"> | string | null
    temaLegal?: StringFilter<"Conversacion"> | string
    consultorio?: StringNullableFilter<"Conversacion"> | string | null
    estado?: StringFilter<"Conversacion"> | string
    canal?: StringFilter<"Conversacion"> | string
    primerMensaje?: StringNullableFilter<"Conversacion"> | string | null
    resumen?: StringNullableFilter<"Conversacion"> | string | null
    createdAt?: DateTimeFilter<"Conversacion"> | Date | string
    estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
    citas?: CitaListRelationFilter
    mensajes?: MensajeListRelationFilter
    asesoramiento?: XOR<AsesoramientoNullableScalarRelationFilter, AsesoramientoWhereInput> | null
    encuesta?: XOR<EncuestaSatisfaccionNullableScalarRelationFilter, EncuestaSatisfaccionWhereInput> | null
  }

  export type ConversacionOrderByWithRelationInput = {
    id?: SortOrder
    estudianteId?: SortOrderInput | SortOrder
    temaLegal?: SortOrder
    consultorio?: SortOrderInput | SortOrder
    estado?: SortOrder
    canal?: SortOrder
    primerMensaje?: SortOrderInput | SortOrder
    resumen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    estudiante?: EstudianteOrderByWithRelationInput
    citas?: CitaOrderByRelationAggregateInput
    mensajes?: MensajeOrderByRelationAggregateInput
    asesoramiento?: AsesoramientoOrderByWithRelationInput
    encuesta?: EncuestaSatisfaccionOrderByWithRelationInput
  }

  export type ConversacionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversacionWhereInput | ConversacionWhereInput[]
    OR?: ConversacionWhereInput[]
    NOT?: ConversacionWhereInput | ConversacionWhereInput[]
    estudianteId?: StringNullableFilter<"Conversacion"> | string | null
    temaLegal?: StringFilter<"Conversacion"> | string
    consultorio?: StringNullableFilter<"Conversacion"> | string | null
    estado?: StringFilter<"Conversacion"> | string
    canal?: StringFilter<"Conversacion"> | string
    primerMensaje?: StringNullableFilter<"Conversacion"> | string | null
    resumen?: StringNullableFilter<"Conversacion"> | string | null
    createdAt?: DateTimeFilter<"Conversacion"> | Date | string
    estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
    citas?: CitaListRelationFilter
    mensajes?: MensajeListRelationFilter
    asesoramiento?: XOR<AsesoramientoNullableScalarRelationFilter, AsesoramientoWhereInput> | null
    encuesta?: XOR<EncuestaSatisfaccionNullableScalarRelationFilter, EncuestaSatisfaccionWhereInput> | null
  }, "id">

  export type ConversacionOrderByWithAggregationInput = {
    id?: SortOrder
    estudianteId?: SortOrderInput | SortOrder
    temaLegal?: SortOrder
    consultorio?: SortOrderInput | SortOrder
    estado?: SortOrder
    canal?: SortOrder
    primerMensaje?: SortOrderInput | SortOrder
    resumen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConversacionCountOrderByAggregateInput
    _max?: ConversacionMaxOrderByAggregateInput
    _min?: ConversacionMinOrderByAggregateInput
  }

  export type ConversacionScalarWhereWithAggregatesInput = {
    AND?: ConversacionScalarWhereWithAggregatesInput | ConversacionScalarWhereWithAggregatesInput[]
    OR?: ConversacionScalarWhereWithAggregatesInput[]
    NOT?: ConversacionScalarWhereWithAggregatesInput | ConversacionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversacion"> | string
    estudianteId?: StringNullableWithAggregatesFilter<"Conversacion"> | string | null
    temaLegal?: StringWithAggregatesFilter<"Conversacion"> | string
    consultorio?: StringNullableWithAggregatesFilter<"Conversacion"> | string | null
    estado?: StringWithAggregatesFilter<"Conversacion"> | string
    canal?: StringWithAggregatesFilter<"Conversacion"> | string
    primerMensaje?: StringNullableWithAggregatesFilter<"Conversacion"> | string | null
    resumen?: StringNullableWithAggregatesFilter<"Conversacion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversacion"> | Date | string
  }

  export type MensajeWhereInput = {
    AND?: MensajeWhereInput | MensajeWhereInput[]
    OR?: MensajeWhereInput[]
    NOT?: MensajeWhereInput | MensajeWhereInput[]
    id?: StringFilter<"Mensaje"> | string
    conversacionId?: StringFilter<"Mensaje"> | string
    tipo?: StringFilter<"Mensaje"> | string
    contenido?: StringFilter<"Mensaje"> | string
    createdAt?: DateTimeFilter<"Mensaje"> | Date | string
    conversacion?: XOR<ConversacionScalarRelationFilter, ConversacionWhereInput>
  }

  export type MensajeOrderByWithRelationInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    tipo?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
    conversacion?: ConversacionOrderByWithRelationInput
  }

  export type MensajeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MensajeWhereInput | MensajeWhereInput[]
    OR?: MensajeWhereInput[]
    NOT?: MensajeWhereInput | MensajeWhereInput[]
    conversacionId?: StringFilter<"Mensaje"> | string
    tipo?: StringFilter<"Mensaje"> | string
    contenido?: StringFilter<"Mensaje"> | string
    createdAt?: DateTimeFilter<"Mensaje"> | Date | string
    conversacion?: XOR<ConversacionScalarRelationFilter, ConversacionWhereInput>
  }, "id">

  export type MensajeOrderByWithAggregationInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    tipo?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
    _count?: MensajeCountOrderByAggregateInput
    _max?: MensajeMaxOrderByAggregateInput
    _min?: MensajeMinOrderByAggregateInput
  }

  export type MensajeScalarWhereWithAggregatesInput = {
    AND?: MensajeScalarWhereWithAggregatesInput | MensajeScalarWhereWithAggregatesInput[]
    OR?: MensajeScalarWhereWithAggregatesInput[]
    NOT?: MensajeScalarWhereWithAggregatesInput | MensajeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mensaje"> | string
    conversacionId?: StringWithAggregatesFilter<"Mensaje"> | string
    tipo?: StringWithAggregatesFilter<"Mensaje"> | string
    contenido?: StringWithAggregatesFilter<"Mensaje"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Mensaje"> | Date | string
  }

  export type AsesoramientoWhereInput = {
    AND?: AsesoramientoWhereInput | AsesoramientoWhereInput[]
    OR?: AsesoramientoWhereInput[]
    NOT?: AsesoramientoWhereInput | AsesoramientoWhereInput[]
    id?: StringFilter<"Asesoramiento"> | string
    conversacionId?: StringFilter<"Asesoramiento"> | string
    estudianteId?: StringNullableFilter<"Asesoramiento"> | string | null
    temaLegal?: StringFilter<"Asesoramiento"> | string
    resumen?: StringNullableFilter<"Asesoramiento"> | string | null
    duracionMinutos?: IntNullableFilter<"Asesoramiento"> | number | null
    createdAt?: DateTimeFilter<"Asesoramiento"> | Date | string
    conversacion?: XOR<ConversacionScalarRelationFilter, ConversacionWhereInput>
    estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
  }

  export type AsesoramientoOrderByWithRelationInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    estudianteId?: SortOrderInput | SortOrder
    temaLegal?: SortOrder
    resumen?: SortOrderInput | SortOrder
    duracionMinutos?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversacion?: ConversacionOrderByWithRelationInput
    estudiante?: EstudianteOrderByWithRelationInput
  }

  export type AsesoramientoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversacionId?: string
    AND?: AsesoramientoWhereInput | AsesoramientoWhereInput[]
    OR?: AsesoramientoWhereInput[]
    NOT?: AsesoramientoWhereInput | AsesoramientoWhereInput[]
    estudianteId?: StringNullableFilter<"Asesoramiento"> | string | null
    temaLegal?: StringFilter<"Asesoramiento"> | string
    resumen?: StringNullableFilter<"Asesoramiento"> | string | null
    duracionMinutos?: IntNullableFilter<"Asesoramiento"> | number | null
    createdAt?: DateTimeFilter<"Asesoramiento"> | Date | string
    conversacion?: XOR<ConversacionScalarRelationFilter, ConversacionWhereInput>
    estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
  }, "id" | "conversacionId">

  export type AsesoramientoOrderByWithAggregationInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    estudianteId?: SortOrderInput | SortOrder
    temaLegal?: SortOrder
    resumen?: SortOrderInput | SortOrder
    duracionMinutos?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AsesoramientoCountOrderByAggregateInput
    _avg?: AsesoramientoAvgOrderByAggregateInput
    _max?: AsesoramientoMaxOrderByAggregateInput
    _min?: AsesoramientoMinOrderByAggregateInput
    _sum?: AsesoramientoSumOrderByAggregateInput
  }

  export type AsesoramientoScalarWhereWithAggregatesInput = {
    AND?: AsesoramientoScalarWhereWithAggregatesInput | AsesoramientoScalarWhereWithAggregatesInput[]
    OR?: AsesoramientoScalarWhereWithAggregatesInput[]
    NOT?: AsesoramientoScalarWhereWithAggregatesInput | AsesoramientoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asesoramiento"> | string
    conversacionId?: StringWithAggregatesFilter<"Asesoramiento"> | string
    estudianteId?: StringNullableWithAggregatesFilter<"Asesoramiento"> | string | null
    temaLegal?: StringWithAggregatesFilter<"Asesoramiento"> | string
    resumen?: StringNullableWithAggregatesFilter<"Asesoramiento"> | string | null
    duracionMinutos?: IntNullableWithAggregatesFilter<"Asesoramiento"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Asesoramiento"> | Date | string
  }

  export type EncuestaSatisfaccionWhereInput = {
    AND?: EncuestaSatisfaccionWhereInput | EncuestaSatisfaccionWhereInput[]
    OR?: EncuestaSatisfaccionWhereInput[]
    NOT?: EncuestaSatisfaccionWhereInput | EncuestaSatisfaccionWhereInput[]
    id?: StringFilter<"EncuestaSatisfaccion"> | string
    conversacionId?: StringNullableFilter<"EncuestaSatisfaccion"> | string | null
    estudianteId?: StringNullableFilter<"EncuestaSatisfaccion"> | string | null
    calificacion?: IntFilter<"EncuestaSatisfaccion"> | number
    comentario?: StringNullableFilter<"EncuestaSatisfaccion"> | string | null
    respondida?: BoolFilter<"EncuestaSatisfaccion"> | boolean
    fuente?: StringFilter<"EncuestaSatisfaccion"> | string
    createdAt?: DateTimeFilter<"EncuestaSatisfaccion"> | Date | string
    conversacion?: XOR<ConversacionNullableScalarRelationFilter, ConversacionWhereInput> | null
    estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
  }

  export type EncuestaSatisfaccionOrderByWithRelationInput = {
    id?: SortOrder
    conversacionId?: SortOrderInput | SortOrder
    estudianteId?: SortOrderInput | SortOrder
    calificacion?: SortOrder
    comentario?: SortOrderInput | SortOrder
    respondida?: SortOrder
    fuente?: SortOrder
    createdAt?: SortOrder
    conversacion?: ConversacionOrderByWithRelationInput
    estudiante?: EstudianteOrderByWithRelationInput
  }

  export type EncuestaSatisfaccionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversacionId?: string
    AND?: EncuestaSatisfaccionWhereInput | EncuestaSatisfaccionWhereInput[]
    OR?: EncuestaSatisfaccionWhereInput[]
    NOT?: EncuestaSatisfaccionWhereInput | EncuestaSatisfaccionWhereInput[]
    estudianteId?: StringNullableFilter<"EncuestaSatisfaccion"> | string | null
    calificacion?: IntFilter<"EncuestaSatisfaccion"> | number
    comentario?: StringNullableFilter<"EncuestaSatisfaccion"> | string | null
    respondida?: BoolFilter<"EncuestaSatisfaccion"> | boolean
    fuente?: StringFilter<"EncuestaSatisfaccion"> | string
    createdAt?: DateTimeFilter<"EncuestaSatisfaccion"> | Date | string
    conversacion?: XOR<ConversacionNullableScalarRelationFilter, ConversacionWhereInput> | null
    estudiante?: XOR<EstudianteNullableScalarRelationFilter, EstudianteWhereInput> | null
  }, "id" | "conversacionId">

  export type EncuestaSatisfaccionOrderByWithAggregationInput = {
    id?: SortOrder
    conversacionId?: SortOrderInput | SortOrder
    estudianteId?: SortOrderInput | SortOrder
    calificacion?: SortOrder
    comentario?: SortOrderInput | SortOrder
    respondida?: SortOrder
    fuente?: SortOrder
    createdAt?: SortOrder
    _count?: EncuestaSatisfaccionCountOrderByAggregateInput
    _avg?: EncuestaSatisfaccionAvgOrderByAggregateInput
    _max?: EncuestaSatisfaccionMaxOrderByAggregateInput
    _min?: EncuestaSatisfaccionMinOrderByAggregateInput
    _sum?: EncuestaSatisfaccionSumOrderByAggregateInput
  }

  export type EncuestaSatisfaccionScalarWhereWithAggregatesInput = {
    AND?: EncuestaSatisfaccionScalarWhereWithAggregatesInput | EncuestaSatisfaccionScalarWhereWithAggregatesInput[]
    OR?: EncuestaSatisfaccionScalarWhereWithAggregatesInput[]
    NOT?: EncuestaSatisfaccionScalarWhereWithAggregatesInput | EncuestaSatisfaccionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EncuestaSatisfaccion"> | string
    conversacionId?: StringNullableWithAggregatesFilter<"EncuestaSatisfaccion"> | string | null
    estudianteId?: StringNullableWithAggregatesFilter<"EncuestaSatisfaccion"> | string | null
    calificacion?: IntWithAggregatesFilter<"EncuestaSatisfaccion"> | number
    comentario?: StringNullableWithAggregatesFilter<"EncuestaSatisfaccion"> | string | null
    respondida?: BoolWithAggregatesFilter<"EncuestaSatisfaccion"> | boolean
    fuente?: StringWithAggregatesFilter<"EncuestaSatisfaccion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EncuestaSatisfaccion"> | Date | string
  }

  export type MetricaMensualWhereInput = {
    AND?: MetricaMensualWhereInput | MetricaMensualWhereInput[]
    OR?: MetricaMensualWhereInput[]
    NOT?: MetricaMensualWhereInput | MetricaMensualWhereInput[]
    id?: StringFilter<"MetricaMensual"> | string
    anio?: IntFilter<"MetricaMensual"> | number
    mes?: IntFilter<"MetricaMensual"> | number
    totalConversaciones?: IntFilter<"MetricaMensual"> | number
    totalAsesoramientos?: IntFilter<"MetricaMensual"> | number
    totalCitas?: IntFilter<"MetricaMensual"> | number
    citasCompletadas?: IntFilter<"MetricaMensual"> | number
    citasCanceladas?: IntFilter<"MetricaMensual"> | number
    promedioSatisfaccion?: FloatFilter<"MetricaMensual"> | number
    totalEncuestas?: IntFilter<"MetricaMensual"> | number
  }

  export type MetricaMensualOrderByWithRelationInput = {
    id?: SortOrder
    anio?: SortOrder
    mes?: SortOrder
    totalConversaciones?: SortOrder
    totalAsesoramientos?: SortOrder
    totalCitas?: SortOrder
    citasCompletadas?: SortOrder
    citasCanceladas?: SortOrder
    promedioSatisfaccion?: SortOrder
    totalEncuestas?: SortOrder
  }

  export type MetricaMensualWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    anio_mes?: MetricaMensualAnioMesCompoundUniqueInput
    AND?: MetricaMensualWhereInput | MetricaMensualWhereInput[]
    OR?: MetricaMensualWhereInput[]
    NOT?: MetricaMensualWhereInput | MetricaMensualWhereInput[]
    anio?: IntFilter<"MetricaMensual"> | number
    mes?: IntFilter<"MetricaMensual"> | number
    totalConversaciones?: IntFilter<"MetricaMensual"> | number
    totalAsesoramientos?: IntFilter<"MetricaMensual"> | number
    totalCitas?: IntFilter<"MetricaMensual"> | number
    citasCompletadas?: IntFilter<"MetricaMensual"> | number
    citasCanceladas?: IntFilter<"MetricaMensual"> | number
    promedioSatisfaccion?: FloatFilter<"MetricaMensual"> | number
    totalEncuestas?: IntFilter<"MetricaMensual"> | number
  }, "id" | "anio_mes">

  export type MetricaMensualOrderByWithAggregationInput = {
    id?: SortOrder
    anio?: SortOrder
    mes?: SortOrder
    totalConversaciones?: SortOrder
    totalAsesoramientos?: SortOrder
    totalCitas?: SortOrder
    citasCompletadas?: SortOrder
    citasCanceladas?: SortOrder
    promedioSatisfaccion?: SortOrder
    totalEncuestas?: SortOrder
    _count?: MetricaMensualCountOrderByAggregateInput
    _avg?: MetricaMensualAvgOrderByAggregateInput
    _max?: MetricaMensualMaxOrderByAggregateInput
    _min?: MetricaMensualMinOrderByAggregateInput
    _sum?: MetricaMensualSumOrderByAggregateInput
  }

  export type MetricaMensualScalarWhereWithAggregatesInput = {
    AND?: MetricaMensualScalarWhereWithAggregatesInput | MetricaMensualScalarWhereWithAggregatesInput[]
    OR?: MetricaMensualScalarWhereWithAggregatesInput[]
    NOT?: MetricaMensualScalarWhereWithAggregatesInput | MetricaMensualScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MetricaMensual"> | string
    anio?: IntWithAggregatesFilter<"MetricaMensual"> | number
    mes?: IntWithAggregatesFilter<"MetricaMensual"> | number
    totalConversaciones?: IntWithAggregatesFilter<"MetricaMensual"> | number
    totalAsesoramientos?: IntWithAggregatesFilter<"MetricaMensual"> | number
    totalCitas?: IntWithAggregatesFilter<"MetricaMensual"> | number
    citasCompletadas?: IntWithAggregatesFilter<"MetricaMensual"> | number
    citasCanceladas?: IntWithAggregatesFilter<"MetricaMensual"> | number
    promedioSatisfaccion?: FloatWithAggregatesFilter<"MetricaMensual"> | number
    totalEncuestas?: IntWithAggregatesFilter<"MetricaMensual"> | number
  }

  export type NotificacionWhereInput = {
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    id?: StringFilter<"Notificacion"> | string
    tipo?: StringFilter<"Notificacion"> | string
    titulo?: StringFilter<"Notificacion"> | string
    mensaje?: StringFilter<"Notificacion"> | string
    prioridad?: StringFilter<"Notificacion"> | string
    leida?: BoolFilter<"Notificacion"> | boolean
    estudianteId?: StringNullableFilter<"Notificacion"> | string | null
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
  }

  export type NotificacionOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    prioridad?: SortOrder
    leida?: SortOrder
    estudianteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    tipo?: StringFilter<"Notificacion"> | string
    titulo?: StringFilter<"Notificacion"> | string
    mensaje?: StringFilter<"Notificacion"> | string
    prioridad?: StringFilter<"Notificacion"> | string
    leida?: BoolFilter<"Notificacion"> | boolean
    estudianteId?: StringNullableFilter<"Notificacion"> | string | null
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
  }, "id">

  export type NotificacionOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    prioridad?: SortOrder
    leida?: SortOrder
    estudianteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificacionCountOrderByAggregateInput
    _max?: NotificacionMaxOrderByAggregateInput
    _min?: NotificacionMinOrderByAggregateInput
  }

  export type NotificacionScalarWhereWithAggregatesInput = {
    AND?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    OR?: NotificacionScalarWhereWithAggregatesInput[]
    NOT?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notificacion"> | string
    tipo?: StringWithAggregatesFilter<"Notificacion"> | string
    titulo?: StringWithAggregatesFilter<"Notificacion"> | string
    mensaje?: StringWithAggregatesFilter<"Notificacion"> | string
    prioridad?: StringWithAggregatesFilter<"Notificacion"> | string
    leida?: BoolWithAggregatesFilter<"Notificacion"> | boolean
    estudianteId?: StringNullableWithAggregatesFilter<"Notificacion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notificacion"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    tenantId?: StringFilter<"Contact"> | string
    channel?: EnumChannelFilter<"Contact"> | $Enums.Channel
    externalId?: StringFilter<"Contact"> | string
    displayName?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversations?: ConversationOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_channel_externalId?: ContactTenantIdChannelExternalIdCompoundUniqueInput
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    tenantId?: StringFilter<"Contact"> | string
    channel?: EnumChannelFilter<"Contact"> | $Enums.Channel
    externalId?: StringFilter<"Contact"> | string
    displayName?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    conversations?: ConversationListRelationFilter
    messages?: MessageListRelationFilter
  }, "id" | "tenantId_channel_externalId">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    tenantId?: StringWithAggregatesFilter<"Contact"> | string
    channel?: EnumChannelWithAggregatesFilter<"Contact"> | $Enums.Channel
    externalId?: StringWithAggregatesFilter<"Contact"> | string
    displayName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    tenantId?: StringFilter<"Conversation"> | string
    contactId?: StringFilter<"Conversation"> | string
    channel?: EnumChannelFilter<"Conversation"> | $Enums.Channel
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    currentFlowVersionId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    contexts?: ConversationContextListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrder
    currentFlowVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    contexts?: ConversationContextOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    tenantId?: StringFilter<"Conversation"> | string
    contactId?: StringFilter<"Conversation"> | string
    channel?: EnumChannelFilter<"Conversation"> | $Enums.Channel
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    currentFlowVersionId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    contexts?: ConversationContextListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrder
    currentFlowVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    tenantId?: StringWithAggregatesFilter<"Conversation"> | string
    contactId?: StringWithAggregatesFilter<"Conversation"> | string
    channel?: EnumChannelWithAggregatesFilter<"Conversation"> | $Enums.Channel
    status?: EnumConversationStatusWithAggregatesFilter<"Conversation"> | $Enums.ConversationStatus
    lastMessageAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    currentFlowVersionId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    tenantId?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    contactId?: StringFilter<"Message"> | string
    direction?: EnumDirectionFilter<"Message"> | $Enums.Direction
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    text?: StringNullableFilter<"Message"> | string | null
    payload?: JsonFilter<"Message">
    providerMessageId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    direction?: SortOrder
    type?: SortOrder
    text?: SortOrderInput | SortOrder
    payload?: SortOrder
    providerMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    tenantId?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    contactId?: StringFilter<"Message"> | string
    direction?: EnumDirectionFilter<"Message"> | $Enums.Direction
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    text?: StringNullableFilter<"Message"> | string | null
    payload?: JsonFilter<"Message">
    providerMessageId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    direction?: SortOrder
    type?: SortOrder
    text?: SortOrderInput | SortOrder
    payload?: SortOrder
    providerMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    tenantId?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    contactId?: StringWithAggregatesFilter<"Message"> | string
    direction?: EnumDirectionWithAggregatesFilter<"Message"> | $Enums.Direction
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    text?: StringNullableWithAggregatesFilter<"Message"> | string | null
    payload?: JsonWithAggregatesFilter<"Message">
    providerMessageId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ConversationContextWhereInput = {
    AND?: ConversationContextWhereInput | ConversationContextWhereInput[]
    OR?: ConversationContextWhereInput[]
    NOT?: ConversationContextWhereInput | ConversationContextWhereInput[]
    id?: StringFilter<"ConversationContext"> | string
    tenantId?: StringFilter<"ConversationContext"> | string
    conversationId?: StringFilter<"ConversationContext"> | string
    version?: IntFilter<"ConversationContext"> | number
    data?: JsonFilter<"ConversationContext">
    createdAt?: DateTimeFilter<"ConversationContext"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type ConversationContextOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type ConversationContextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_conversationId_version?: ConversationContextTenantIdConversationIdVersionCompoundUniqueInput
    AND?: ConversationContextWhereInput | ConversationContextWhereInput[]
    OR?: ConversationContextWhereInput[]
    NOT?: ConversationContextWhereInput | ConversationContextWhereInput[]
    tenantId?: StringFilter<"ConversationContext"> | string
    conversationId?: StringFilter<"ConversationContext"> | string
    version?: IntFilter<"ConversationContext"> | number
    data?: JsonFilter<"ConversationContext">
    createdAt?: DateTimeFilter<"ConversationContext"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id" | "tenantId_conversationId_version">

  export type ConversationContextOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    _count?: ConversationContextCountOrderByAggregateInput
    _avg?: ConversationContextAvgOrderByAggregateInput
    _max?: ConversationContextMaxOrderByAggregateInput
    _min?: ConversationContextMinOrderByAggregateInput
    _sum?: ConversationContextSumOrderByAggregateInput
  }

  export type ConversationContextScalarWhereWithAggregatesInput = {
    AND?: ConversationContextScalarWhereWithAggregatesInput | ConversationContextScalarWhereWithAggregatesInput[]
    OR?: ConversationContextScalarWhereWithAggregatesInput[]
    NOT?: ConversationContextScalarWhereWithAggregatesInput | ConversationContextScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationContext"> | string
    tenantId?: StringWithAggregatesFilter<"ConversationContext"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationContext"> | string
    version?: IntWithAggregatesFilter<"ConversationContext"> | number
    data?: JsonWithAggregatesFilter<"ConversationContext">
    createdAt?: DateTimeWithAggregatesFilter<"ConversationContext"> | Date | string
  }

  export type UsuarioCreateInput = {
    id?: string
    nombreCompleto: string
    correo: string
    telefono?: string | null
    passwordHash: string
    primerIngreso?: boolean
    rol?: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    intentosLogin?: IntentoLoginCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    nombreCompleto: string
    correo: string
    telefono?: string | null
    passwordHash: string
    primerIngreso?: boolean
    rol?: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    intentosLogin?: IntentoLoginUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    primerIngreso?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentosLogin?: IntentoLoginUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    primerIngreso?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentosLogin?: IntentoLoginUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    nombreCompleto: string
    correo: string
    telefono?: string | null
    passwordHash: string
    primerIngreso?: boolean
    rol?: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    primerIngreso?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    primerIngreso?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentoLoginCreateInput = {
    id?: string
    correo: string
    tipo?: $Enums.TipoIntentoLogin
    exitoso?: boolean
    origen?: $Enums.OrigenIntento
    ip?: string | null
    userAgent?: string | null
    motivoFallo?: string | null
    creadoEn?: Date | string
    usuario?: UsuarioCreateNestedOneWithoutIntentosLoginInput
  }

  export type IntentoLoginUncheckedCreateInput = {
    id?: string
    usuarioId?: string | null
    correo: string
    tipo?: $Enums.TipoIntentoLogin
    exitoso?: boolean
    origen?: $Enums.OrigenIntento
    ip?: string | null
    userAgent?: string | null
    motivoFallo?: string | null
    creadoEn?: Date | string
  }

  export type IntentoLoginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoIntentoLoginFieldUpdateOperationsInput | $Enums.TipoIntentoLogin
    exitoso?: BoolFieldUpdateOperationsInput | boolean
    origen?: EnumOrigenIntentoFieldUpdateOperationsInput | $Enums.OrigenIntento
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    motivoFallo?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneWithoutIntentosLoginNestedInput
  }

  export type IntentoLoginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoIntentoLoginFieldUpdateOperationsInput | $Enums.TipoIntentoLogin
    exitoso?: BoolFieldUpdateOperationsInput | boolean
    origen?: EnumOrigenIntentoFieldUpdateOperationsInput | $Enums.OrigenIntento
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    motivoFallo?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentoLoginCreateManyInput = {
    id?: string
    usuarioId?: string | null
    correo: string
    tipo?: $Enums.TipoIntentoLogin
    exitoso?: boolean
    origen?: $Enums.OrigenIntento
    ip?: string | null
    userAgent?: string | null
    motivoFallo?: string | null
    creadoEn?: Date | string
  }

  export type IntentoLoginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoIntentoLoginFieldUpdateOperationsInput | $Enums.TipoIntentoLogin
    exitoso?: BoolFieldUpdateOperationsInput | boolean
    origen?: EnumOrigenIntentoFieldUpdateOperationsInput | $Enums.OrigenIntento
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    motivoFallo?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentoLoginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoIntentoLoginFieldUpdateOperationsInput | $Enums.TipoIntentoLogin
    exitoso?: BoolFieldUpdateOperationsInput | boolean
    origen?: EnumOrigenIntentoFieldUpdateOperationsInput | $Enums.OrigenIntento
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    motivoFallo?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionCreateInput = {
    id?: string
    token: string
    ip?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    ultimoAcceso?: Date | string
    activa?: boolean
    creadaEn?: Date | string
    usuario: UsuarioCreateNestedOneWithoutSesionesInput
  }

  export type SesionUncheckedCreateInput = {
    id?: string
    usuarioId: string
    token: string
    ip?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    ultimoAcceso?: Date | string
    activa?: boolean
    creadaEn?: Date | string
  }

  export type SesionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimoAcceso?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutSesionesNestedInput
  }

  export type SesionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimoAcceso?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionCreateManyInput = {
    id?: string
    usuarioId: string
    token: string
    ip?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    ultimoAcceso?: Date | string
    activa?: boolean
    creadaEn?: Date | string
  }

  export type SesionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimoAcceso?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimoAcceso?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteCreateInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    citas?: CitaCreateNestedManyWithoutEstudianteInput
    conversaciones?: ConversacionCreateNestedManyWithoutEstudianteInput
    encuestas?: EncuestaSatisfaccionCreateNestedManyWithoutEstudianteInput
    asesoramiento?: AsesoramientoCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutEstudianteInput
    conversaciones?: ConversacionUncheckedCreateNestedManyWithoutEstudianteInput
    encuestas?: EncuestaSatisfaccionUncheckedCreateNestedManyWithoutEstudianteInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUpdateManyWithoutEstudianteNestedInput
    conversaciones?: ConversacionUpdateManyWithoutEstudianteNestedInput
    encuestas?: EncuestaSatisfaccionUpdateManyWithoutEstudianteNestedInput
    asesoramiento?: AsesoramientoUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutEstudianteNestedInput
    conversaciones?: ConversacionUncheckedUpdateManyWithoutEstudianteNestedInput
    encuestas?: EncuestaSatisfaccionUncheckedUpdateManyWithoutEstudianteNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteCreateManyInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type EstudianteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EstudianteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitaCreateInput = {
    id?: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutCitasInput
    conversacion?: ConversacionCreateNestedOneWithoutCitasInput
  }

  export type CitaUncheckedCreateInput = {
    id?: string
    estudianteId: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    conversacionId?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type CitaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutCitasNestedInput
    conversacion?: ConversacionUpdateOneWithoutCitasNestedInput
  }

  export type CitaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    conversacionId?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitaCreateManyInput = {
    id?: string
    estudianteId: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    conversacionId?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type CitaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    conversacionId?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditoriaCreateInput = {
    id?: string
    accion: $Enums.TipoAuditoria
    entidad: string
    entidadId?: string | null
    detalles: string
    adminId?: string | null
    adminNombre?: string | null
    ip?: string | null
    userAgent?: string | null
    creadoEn?: Date | string
  }

  export type AuditoriaUncheckedCreateInput = {
    id?: string
    accion: $Enums.TipoAuditoria
    entidad: string
    entidadId?: string | null
    detalles: string
    adminId?: string | null
    adminNombre?: string | null
    ip?: string | null
    userAgent?: string | null
    creadoEn?: Date | string
  }

  export type AuditoriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumTipoAuditoriaFieldUpdateOperationsInput | $Enums.TipoAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    detalles?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNombre?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditoriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumTipoAuditoriaFieldUpdateOperationsInput | $Enums.TipoAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    detalles?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNombre?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditoriaCreateManyInput = {
    id?: string
    accion: $Enums.TipoAuditoria
    entidad: string
    entidadId?: string | null
    detalles: string
    adminId?: string | null
    adminNombre?: string | null
    ip?: string | null
    userAgent?: string | null
    creadoEn?: Date | string
  }

  export type AuditoriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumTipoAuditoriaFieldUpdateOperationsInput | $Enums.TipoAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    detalles?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNombre?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditoriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumTipoAuditoriaFieldUpdateOperationsInput | $Enums.TipoAuditoria
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableStringFieldUpdateOperationsInput | string | null
    detalles?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNombre?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionWhatsAppCreateInput = {
    id?: string
    nombreBot?: string
    phoneNumberId?: string | null
    businessAccountId?: string | null
    webhookVerifyToken?: string | null
    webhookUrl?: string | null
    tokenAcceso?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionWhatsAppUncheckedCreateInput = {
    id?: string
    nombreBot?: string
    phoneNumberId?: string | null
    businessAccountId?: string | null
    webhookVerifyToken?: string | null
    webhookUrl?: string | null
    tokenAcceso?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionWhatsAppUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreBot?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    businessAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionWhatsAppUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreBot?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    businessAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionWhatsAppCreateManyInput = {
    id?: string
    nombreBot?: string
    phoneNumberId?: string | null
    businessAccountId?: string | null
    webhookVerifyToken?: string | null
    webhookUrl?: string | null
    tokenAcceso?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracionWhatsAppUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreBot?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    businessAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionWhatsAppUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreBot?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: NullableStringFieldUpdateOperationsInput | string | null
    businessAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookVerifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenAcceso?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateInput = {
    id?: string
    tipo: string
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
  }

  export type WebhookLogUncheckedCreateInput = {
    id?: string
    tipo: string
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
  }

  export type WebhookLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateManyInput = {
    id?: string
    tipo: string
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
  }

  export type WebhookLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantillaMensajeCreateInput = {
    id?: string
    nombre: string
    contenido: string
    tipo: string
    idioma?: string
    activa?: boolean
    createdAt?: Date | string
  }

  export type PlantillaMensajeUncheckedCreateInput = {
    id?: string
    nombre: string
    contenido: string
    tipo: string
    idioma?: string
    activa?: boolean
    createdAt?: Date | string
  }

  export type PlantillaMensajeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    idioma?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantillaMensajeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    idioma?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantillaMensajeCreateManyInput = {
    id?: string
    nombre: string
    contenido: string
    tipo: string
    idioma?: string
    activa?: boolean
    createdAt?: Date | string
  }

  export type PlantillaMensajeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    idioma?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlantillaMensajeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    idioma?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversacionCreateInput = {
    id?: string
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutConversacionesInput
    citas?: CitaCreateNestedManyWithoutConversacionInput
    mensajes?: MensajeCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoCreateNestedOneWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionUncheckedCreateInput = {
    id?: string
    estudianteId?: string | null
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutConversacionInput
    mensajes?: MensajeUncheckedCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedOneWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionUncheckedCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutConversacionesNestedInput
    citas?: CitaUpdateManyWithoutConversacionNestedInput
    mensajes?: MensajeUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUpdateOneWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutConversacionNestedInput
    mensajes?: MensajeUncheckedUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateOneWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUncheckedUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionCreateManyInput = {
    id?: string
    estudianteId?: string | null
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
  }

  export type ConversacionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversacionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeCreateInput = {
    id?: string
    tipo: string
    contenido: string
    createdAt?: Date | string
    conversacion: ConversacionCreateNestedOneWithoutMensajesInput
  }

  export type MensajeUncheckedCreateInput = {
    id?: string
    conversacionId: string
    tipo: string
    contenido: string
    createdAt?: Date | string
  }

  export type MensajeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversacion?: ConversacionUpdateOneRequiredWithoutMensajesNestedInput
  }

  export type MensajeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeCreateManyInput = {
    id?: string
    conversacionId: string
    tipo: string
    contenido: string
    createdAt?: Date | string
  }

  export type MensajeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsesoramientoCreateInput = {
    id?: string
    temaLegal: string
    resumen?: string | null
    duracionMinutos?: number | null
    createdAt?: Date | string
    conversacion: ConversacionCreateNestedOneWithoutAsesoramientoInput
    estudiante?: EstudianteCreateNestedOneWithoutAsesoramientoInput
  }

  export type AsesoramientoUncheckedCreateInput = {
    id?: string
    conversacionId: string
    estudianteId?: string | null
    temaLegal: string
    resumen?: string | null
    duracionMinutos?: number | null
    createdAt?: Date | string
  }

  export type AsesoramientoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversacion?: ConversacionUpdateOneRequiredWithoutAsesoramientoNestedInput
    estudiante?: EstudianteUpdateOneWithoutAsesoramientoNestedInput
  }

  export type AsesoramientoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsesoramientoCreateManyInput = {
    id?: string
    conversacionId: string
    estudianteId?: string | null
    temaLegal: string
    resumen?: string | null
    duracionMinutos?: number | null
    createdAt?: Date | string
  }

  export type AsesoramientoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsesoramientoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncuestaSatisfaccionCreateInput = {
    id?: string
    calificacion: number
    comentario?: string | null
    respondida?: boolean
    fuente?: string
    createdAt?: Date | string
    conversacion?: ConversacionCreateNestedOneWithoutEncuestaInput
    estudiante?: EstudianteCreateNestedOneWithoutEncuestasInput
  }

  export type EncuestaSatisfaccionUncheckedCreateInput = {
    id?: string
    conversacionId?: string | null
    estudianteId?: string | null
    calificacion: number
    comentario?: string | null
    respondida?: boolean
    fuente?: string
    createdAt?: Date | string
  }

  export type EncuestaSatisfaccionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversacion?: ConversacionUpdateOneWithoutEncuestaNestedInput
    estudiante?: EstudianteUpdateOneWithoutEncuestasNestedInput
  }

  export type EncuestaSatisfaccionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncuestaSatisfaccionCreateManyInput = {
    id?: string
    conversacionId?: string | null
    estudianteId?: string | null
    calificacion: number
    comentario?: string | null
    respondida?: boolean
    fuente?: string
    createdAt?: Date | string
  }

  export type EncuestaSatisfaccionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncuestaSatisfaccionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricaMensualCreateInput = {
    id?: string
    anio: number
    mes: number
    totalConversaciones?: number
    totalAsesoramientos?: number
    totalCitas?: number
    citasCompletadas?: number
    citasCanceladas?: number
    promedioSatisfaccion?: number
    totalEncuestas?: number
  }

  export type MetricaMensualUncheckedCreateInput = {
    id?: string
    anio: number
    mes: number
    totalConversaciones?: number
    totalAsesoramientos?: number
    totalCitas?: number
    citasCompletadas?: number
    citasCanceladas?: number
    promedioSatisfaccion?: number
    totalEncuestas?: number
  }

  export type MetricaMensualUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    mes?: IntFieldUpdateOperationsInput | number
    totalConversaciones?: IntFieldUpdateOperationsInput | number
    totalAsesoramientos?: IntFieldUpdateOperationsInput | number
    totalCitas?: IntFieldUpdateOperationsInput | number
    citasCompletadas?: IntFieldUpdateOperationsInput | number
    citasCanceladas?: IntFieldUpdateOperationsInput | number
    promedioSatisfaccion?: FloatFieldUpdateOperationsInput | number
    totalEncuestas?: IntFieldUpdateOperationsInput | number
  }

  export type MetricaMensualUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    mes?: IntFieldUpdateOperationsInput | number
    totalConversaciones?: IntFieldUpdateOperationsInput | number
    totalAsesoramientos?: IntFieldUpdateOperationsInput | number
    totalCitas?: IntFieldUpdateOperationsInput | number
    citasCompletadas?: IntFieldUpdateOperationsInput | number
    citasCanceladas?: IntFieldUpdateOperationsInput | number
    promedioSatisfaccion?: FloatFieldUpdateOperationsInput | number
    totalEncuestas?: IntFieldUpdateOperationsInput | number
  }

  export type MetricaMensualCreateManyInput = {
    id?: string
    anio: number
    mes: number
    totalConversaciones?: number
    totalAsesoramientos?: number
    totalCitas?: number
    citasCompletadas?: number
    citasCanceladas?: number
    promedioSatisfaccion?: number
    totalEncuestas?: number
  }

  export type MetricaMensualUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    mes?: IntFieldUpdateOperationsInput | number
    totalConversaciones?: IntFieldUpdateOperationsInput | number
    totalAsesoramientos?: IntFieldUpdateOperationsInput | number
    totalCitas?: IntFieldUpdateOperationsInput | number
    citasCompletadas?: IntFieldUpdateOperationsInput | number
    citasCanceladas?: IntFieldUpdateOperationsInput | number
    promedioSatisfaccion?: FloatFieldUpdateOperationsInput | number
    totalEncuestas?: IntFieldUpdateOperationsInput | number
  }

  export type MetricaMensualUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    mes?: IntFieldUpdateOperationsInput | number
    totalConversaciones?: IntFieldUpdateOperationsInput | number
    totalAsesoramientos?: IntFieldUpdateOperationsInput | number
    totalCitas?: IntFieldUpdateOperationsInput | number
    citasCompletadas?: IntFieldUpdateOperationsInput | number
    citasCanceladas?: IntFieldUpdateOperationsInput | number
    promedioSatisfaccion?: FloatFieldUpdateOperationsInput | number
    totalEncuestas?: IntFieldUpdateOperationsInput | number
  }

  export type NotificacionCreateInput = {
    id?: string
    tipo: string
    titulo: string
    mensaje: string
    prioridad?: string
    leida?: boolean
    estudianteId?: string | null
    createdAt?: Date | string
  }

  export type NotificacionUncheckedCreateInput = {
    id?: string
    tipo: string
    titulo: string
    mensaje: string
    prioridad?: string
    leida?: boolean
    estudianteId?: string | null
    createdAt?: Date | string
  }

  export type NotificacionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionCreateManyInput = {
    id?: string
    tipo: string
    titulo: string
    mensaje: string
    prioridad?: string
    leida?: boolean
    estudianteId?: string | null
    createdAt?: Date | string
  }

  export type NotificacionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    mensaje?: StringFieldUpdateOperationsInput | string
    prioridad?: StringFieldUpdateOperationsInput | string
    leida?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    externalId: string
    displayName?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutContactInput
    messages?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    externalId: string
    displayName?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    externalId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutContactNestedInput
    messages?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    externalId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    externalId: string
    displayName?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    externalId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    externalId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutConversationsInput
    contexts?: ConversationContextCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    tenantId: string
    contactId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contexts?: ConversationContextUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutConversationsNestedInput
    contexts?: ConversationContextUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contexts?: ConversationContextUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    tenantId: string
    contactId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    tenantId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
    contact: ContactCreateNestedOneWithoutMessagesInput
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    tenantId: string
    conversationId: string
    contactId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    tenantId: string
    conversationId: string
    contactId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationContextCreateInput = {
    id?: string
    tenantId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutContextsInput
  }

  export type ConversationContextUncheckedCreateInput = {
    id?: string
    tenantId: string
    conversationId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationContextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutContextsNestedInput
  }

  export type ConversationContextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationContextCreateManyInput = {
    id?: string
    tenantId: string
    conversationId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationContextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationContextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type EnumEstadoUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoUsuario | EnumEstadoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoUsuarioFilter<$PrismaModel> | $Enums.EstadoUsuario
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntentoLoginListRelationFilter = {
    every?: IntentoLoginWhereInput
    some?: IntentoLoginWhereInput
    none?: IntentoLoginWhereInput
  }

  export type SesionListRelationFilter = {
    every?: SesionWhereInput
    some?: SesionWhereInput
    none?: SesionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type IntentoLoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SesionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombreCompleto?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    passwordHash?: SortOrder
    primerIngreso?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombreCompleto?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    passwordHash?: SortOrder
    primerIngreso?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombreCompleto?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    passwordHash?: SortOrder
    primerIngreso?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type EnumEstadoUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoUsuario | EnumEstadoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoUsuarioFilter<$PrismaModel>
    _max?: NestedEnumEstadoUsuarioFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumTipoIntentoLoginFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoIntentoLogin | EnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    in?: $Enums.TipoIntentoLogin[] | ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoIntentoLogin[] | ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoIntentoLoginFilter<$PrismaModel> | $Enums.TipoIntentoLogin
  }

  export type EnumOrigenIntentoFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigenIntento | EnumOrigenIntentoFieldRefInput<$PrismaModel>
    in?: $Enums.OrigenIntento[] | ListEnumOrigenIntentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrigenIntento[] | ListEnumOrigenIntentoFieldRefInput<$PrismaModel>
    not?: NestedEnumOrigenIntentoFilter<$PrismaModel> | $Enums.OrigenIntento
  }

  export type UsuarioNullableScalarRelationFilter = {
    is?: UsuarioWhereInput | null
    isNot?: UsuarioWhereInput | null
  }

  export type IntentoLoginCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    correo?: SortOrder
    tipo?: SortOrder
    exitoso?: SortOrder
    origen?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    motivoFallo?: SortOrder
    creadoEn?: SortOrder
  }

  export type IntentoLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    correo?: SortOrder
    tipo?: SortOrder
    exitoso?: SortOrder
    origen?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    motivoFallo?: SortOrder
    creadoEn?: SortOrder
  }

  export type IntentoLoginMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    correo?: SortOrder
    tipo?: SortOrder
    exitoso?: SortOrder
    origen?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    motivoFallo?: SortOrder
    creadoEn?: SortOrder
  }

  export type EnumTipoIntentoLoginWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoIntentoLogin | EnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    in?: $Enums.TipoIntentoLogin[] | ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoIntentoLogin[] | ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoIntentoLoginWithAggregatesFilter<$PrismaModel> | $Enums.TipoIntentoLogin
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoIntentoLoginFilter<$PrismaModel>
    _max?: NestedEnumTipoIntentoLoginFilter<$PrismaModel>
  }

  export type EnumOrigenIntentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigenIntento | EnumOrigenIntentoFieldRefInput<$PrismaModel>
    in?: $Enums.OrigenIntento[] | ListEnumOrigenIntentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrigenIntento[] | ListEnumOrigenIntentoFieldRefInput<$PrismaModel>
    not?: NestedEnumOrigenIntentoWithAggregatesFilter<$PrismaModel> | $Enums.OrigenIntento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrigenIntentoFilter<$PrismaModel>
    _max?: NestedEnumOrigenIntentoFilter<$PrismaModel>
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type SesionCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    ultimoAcceso?: SortOrder
    activa?: SortOrder
    creadaEn?: SortOrder
  }

  export type SesionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    ultimoAcceso?: SortOrder
    activa?: SortOrder
    creadaEn?: SortOrder
  }

  export type SesionMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    ultimoAcceso?: SortOrder
    activa?: SortOrder
    creadaEn?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumModalidadFilter<$PrismaModel = never> = {
    equals?: $Enums.Modalidad | EnumModalidadFieldRefInput<$PrismaModel>
    in?: $Enums.Modalidad[] | ListEnumModalidadFieldRefInput<$PrismaModel>
    notIn?: $Enums.Modalidad[] | ListEnumModalidadFieldRefInput<$PrismaModel>
    not?: NestedEnumModalidadFilter<$PrismaModel> | $Enums.Modalidad
  }

  export type EnumEstadoEstudianteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEstudiante | EnumEstadoEstudianteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEstudiante[] | ListEnumEstadoEstudianteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoEstudiante[] | ListEnumEstadoEstudianteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoEstudianteFilter<$PrismaModel> | $Enums.EstadoEstudiante
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CitaListRelationFilter = {
    every?: CitaWhereInput
    some?: CitaWhereInput
    none?: CitaWhereInput
  }

  export type ConversacionListRelationFilter = {
    every?: ConversacionWhereInput
    some?: ConversacionWhereInput
    none?: ConversacionWhereInput
  }

  export type EncuestaSatisfaccionListRelationFilter = {
    every?: EncuestaSatisfaccionWhereInput
    some?: EncuestaSatisfaccionWhereInput
    none?: EncuestaSatisfaccionWhereInput
  }

  export type AsesoramientoListRelationFilter = {
    every?: AsesoramientoWhereInput
    some?: AsesoramientoWhereInput
    none?: AsesoramientoWhereInput
  }

  export type CitaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncuestaSatisfaccionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AsesoramientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EstudianteCountOrderByAggregateInput = {
    id?: SortOrder
    documento?: SortOrder
    nombre?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    programa?: SortOrder
    semestre?: SortOrder
    modalidad?: SortOrder
    estado?: SortOrder
    estadoCuenta?: SortOrder
    accesoCitas?: SortOrder
    acudimientos?: SortOrder
    fechaInicio?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type EstudianteAvgOrderByAggregateInput = {
    semestre?: SortOrder
  }

  export type EstudianteMaxOrderByAggregateInput = {
    id?: SortOrder
    documento?: SortOrder
    nombre?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    programa?: SortOrder
    semestre?: SortOrder
    modalidad?: SortOrder
    estado?: SortOrder
    estadoCuenta?: SortOrder
    accesoCitas?: SortOrder
    acudimientos?: SortOrder
    fechaInicio?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type EstudianteMinOrderByAggregateInput = {
    id?: SortOrder
    documento?: SortOrder
    nombre?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    programa?: SortOrder
    semestre?: SortOrder
    modalidad?: SortOrder
    estado?: SortOrder
    estadoCuenta?: SortOrder
    accesoCitas?: SortOrder
    acudimientos?: SortOrder
    fechaInicio?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type EstudianteSumOrderByAggregateInput = {
    semestre?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumModalidadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Modalidad | EnumModalidadFieldRefInput<$PrismaModel>
    in?: $Enums.Modalidad[] | ListEnumModalidadFieldRefInput<$PrismaModel>
    notIn?: $Enums.Modalidad[] | ListEnumModalidadFieldRefInput<$PrismaModel>
    not?: NestedEnumModalidadWithAggregatesFilter<$PrismaModel> | $Enums.Modalidad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModalidadFilter<$PrismaModel>
    _max?: NestedEnumModalidadFilter<$PrismaModel>
  }

  export type EnumEstadoEstudianteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEstudiante | EnumEstadoEstudianteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEstudiante[] | ListEnumEstadoEstudianteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoEstudiante[] | ListEnumEstadoEstudianteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoEstudianteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoEstudiante
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoEstudianteFilter<$PrismaModel>
    _max?: NestedEnumEstadoEstudianteFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumEstadoCitaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoCita | EnumEstadoCitaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoCita[] | ListEnumEstadoCitaFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoCita[] | ListEnumEstadoCitaFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoCitaFilter<$PrismaModel> | $Enums.EstadoCita
  }

  export type EstudianteScalarRelationFilter = {
    is?: EstudianteWhereInput
    isNot?: EstudianteWhereInput
  }

  export type ConversacionNullableScalarRelationFilter = {
    is?: ConversacionWhereInput | null
    isNot?: ConversacionWhereInput | null
  }

  export type CitaCountOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    modalidad?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
    usuarioNombre?: SortOrder
    usuarioTipoDocumento?: SortOrder
    usuarioNumeroDocumento?: SortOrder
    usuarioCorreo?: SortOrder
    usuarioTelefono?: SortOrder
    enlaceReunion?: SortOrder
    conversacionId?: SortOrder
    notifEnviada24h?: SortOrder
    notifEnviada15m?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type CitaMaxOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    modalidad?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
    usuarioNombre?: SortOrder
    usuarioTipoDocumento?: SortOrder
    usuarioNumeroDocumento?: SortOrder
    usuarioCorreo?: SortOrder
    usuarioTelefono?: SortOrder
    enlaceReunion?: SortOrder
    conversacionId?: SortOrder
    notifEnviada24h?: SortOrder
    notifEnviada15m?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type CitaMinOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    modalidad?: SortOrder
    motivo?: SortOrder
    estado?: SortOrder
    usuarioNombre?: SortOrder
    usuarioTipoDocumento?: SortOrder
    usuarioNumeroDocumento?: SortOrder
    usuarioCorreo?: SortOrder
    usuarioTelefono?: SortOrder
    enlaceReunion?: SortOrder
    conversacionId?: SortOrder
    notifEnviada24h?: SortOrder
    notifEnviada15m?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type EnumEstadoCitaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoCita | EnumEstadoCitaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoCita[] | ListEnumEstadoCitaFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoCita[] | ListEnumEstadoCitaFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoCitaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoCita
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoCitaFilter<$PrismaModel>
    _max?: NestedEnumEstadoCitaFilter<$PrismaModel>
  }

  export type EnumTipoAuditoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoAuditoria | EnumTipoAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoAuditoria[] | ListEnumTipoAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoAuditoria[] | ListEnumTipoAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoAuditoriaFilter<$PrismaModel> | $Enums.TipoAuditoria
  }

  export type AuditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    detalles?: SortOrder
    adminId?: SortOrder
    adminNombre?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type AuditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    detalles?: SortOrder
    adminId?: SortOrder
    adminNombre?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type AuditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    detalles?: SortOrder
    adminId?: SortOrder
    adminNombre?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type EnumTipoAuditoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoAuditoria | EnumTipoAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoAuditoria[] | ListEnumTipoAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoAuditoria[] | ListEnumTipoAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoAuditoriaWithAggregatesFilter<$PrismaModel> | $Enums.TipoAuditoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoAuditoriaFilter<$PrismaModel>
    _max?: NestedEnumTipoAuditoriaFilter<$PrismaModel>
  }

  export type ConfiguracionWhatsAppCountOrderByAggregateInput = {
    id?: SortOrder
    nombreBot?: SortOrder
    phoneNumberId?: SortOrder
    businessAccountId?: SortOrder
    webhookVerifyToken?: SortOrder
    webhookUrl?: SortOrder
    tokenAcceso?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionWhatsAppMaxOrderByAggregateInput = {
    id?: SortOrder
    nombreBot?: SortOrder
    phoneNumberId?: SortOrder
    businessAccountId?: SortOrder
    webhookVerifyToken?: SortOrder
    webhookUrl?: SortOrder
    tokenAcceso?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracionWhatsAppMinOrderByAggregateInput = {
    id?: SortOrder
    nombreBot?: SortOrder
    phoneNumberId?: SortOrder
    businessAccountId?: SortOrder
    webhookVerifyToken?: SortOrder
    webhookUrl?: SortOrder
    tokenAcceso?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WebhookLogCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PlantillaMensajeCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    idioma?: SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
  }

  export type PlantillaMensajeMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    idioma?: SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
  }

  export type PlantillaMensajeMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    idioma?: SortOrder
    activa?: SortOrder
    createdAt?: SortOrder
  }

  export type EstudianteNullableScalarRelationFilter = {
    is?: EstudianteWhereInput | null
    isNot?: EstudianteWhereInput | null
  }

  export type MensajeListRelationFilter = {
    every?: MensajeWhereInput
    some?: MensajeWhereInput
    none?: MensajeWhereInput
  }

  export type AsesoramientoNullableScalarRelationFilter = {
    is?: AsesoramientoWhereInput | null
    isNot?: AsesoramientoWhereInput | null
  }

  export type EncuestaSatisfaccionNullableScalarRelationFilter = {
    is?: EncuestaSatisfaccionWhereInput | null
    isNot?: EncuestaSatisfaccionWhereInput | null
  }

  export type MensajeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversacionCountOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    temaLegal?: SortOrder
    consultorio?: SortOrder
    estado?: SortOrder
    canal?: SortOrder
    primerMensaje?: SortOrder
    resumen?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversacionMaxOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    temaLegal?: SortOrder
    consultorio?: SortOrder
    estado?: SortOrder
    canal?: SortOrder
    primerMensaje?: SortOrder
    resumen?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversacionMinOrderByAggregateInput = {
    id?: SortOrder
    estudianteId?: SortOrder
    temaLegal?: SortOrder
    consultorio?: SortOrder
    estado?: SortOrder
    canal?: SortOrder
    primerMensaje?: SortOrder
    resumen?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversacionScalarRelationFilter = {
    is?: ConversacionWhereInput
    isNot?: ConversacionWhereInput
  }

  export type MensajeCountOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    tipo?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
  }

  export type MensajeMaxOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    tipo?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
  }

  export type MensajeMinOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    tipo?: SortOrder
    contenido?: SortOrder
    createdAt?: SortOrder
  }

  export type AsesoramientoCountOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    estudianteId?: SortOrder
    temaLegal?: SortOrder
    resumen?: SortOrder
    duracionMinutos?: SortOrder
    createdAt?: SortOrder
  }

  export type AsesoramientoAvgOrderByAggregateInput = {
    duracionMinutos?: SortOrder
  }

  export type AsesoramientoMaxOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    estudianteId?: SortOrder
    temaLegal?: SortOrder
    resumen?: SortOrder
    duracionMinutos?: SortOrder
    createdAt?: SortOrder
  }

  export type AsesoramientoMinOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    estudianteId?: SortOrder
    temaLegal?: SortOrder
    resumen?: SortOrder
    duracionMinutos?: SortOrder
    createdAt?: SortOrder
  }

  export type AsesoramientoSumOrderByAggregateInput = {
    duracionMinutos?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EncuestaSatisfaccionCountOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    estudianteId?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    respondida?: SortOrder
    fuente?: SortOrder
    createdAt?: SortOrder
  }

  export type EncuestaSatisfaccionAvgOrderByAggregateInput = {
    calificacion?: SortOrder
  }

  export type EncuestaSatisfaccionMaxOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    estudianteId?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    respondida?: SortOrder
    fuente?: SortOrder
    createdAt?: SortOrder
  }

  export type EncuestaSatisfaccionMinOrderByAggregateInput = {
    id?: SortOrder
    conversacionId?: SortOrder
    estudianteId?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    respondida?: SortOrder
    fuente?: SortOrder
    createdAt?: SortOrder
  }

  export type EncuestaSatisfaccionSumOrderByAggregateInput = {
    calificacion?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MetricaMensualAnioMesCompoundUniqueInput = {
    anio: number
    mes: number
  }

  export type MetricaMensualCountOrderByAggregateInput = {
    id?: SortOrder
    anio?: SortOrder
    mes?: SortOrder
    totalConversaciones?: SortOrder
    totalAsesoramientos?: SortOrder
    totalCitas?: SortOrder
    citasCompletadas?: SortOrder
    citasCanceladas?: SortOrder
    promedioSatisfaccion?: SortOrder
    totalEncuestas?: SortOrder
  }

  export type MetricaMensualAvgOrderByAggregateInput = {
    anio?: SortOrder
    mes?: SortOrder
    totalConversaciones?: SortOrder
    totalAsesoramientos?: SortOrder
    totalCitas?: SortOrder
    citasCompletadas?: SortOrder
    citasCanceladas?: SortOrder
    promedioSatisfaccion?: SortOrder
    totalEncuestas?: SortOrder
  }

  export type MetricaMensualMaxOrderByAggregateInput = {
    id?: SortOrder
    anio?: SortOrder
    mes?: SortOrder
    totalConversaciones?: SortOrder
    totalAsesoramientos?: SortOrder
    totalCitas?: SortOrder
    citasCompletadas?: SortOrder
    citasCanceladas?: SortOrder
    promedioSatisfaccion?: SortOrder
    totalEncuestas?: SortOrder
  }

  export type MetricaMensualMinOrderByAggregateInput = {
    id?: SortOrder
    anio?: SortOrder
    mes?: SortOrder
    totalConversaciones?: SortOrder
    totalAsesoramientos?: SortOrder
    totalCitas?: SortOrder
    citasCompletadas?: SortOrder
    citasCanceladas?: SortOrder
    promedioSatisfaccion?: SortOrder
    totalEncuestas?: SortOrder
  }

  export type MetricaMensualSumOrderByAggregateInput = {
    anio?: SortOrder
    mes?: SortOrder
    totalConversaciones?: SortOrder
    totalAsesoramientos?: SortOrder
    totalCitas?: SortOrder
    citasCompletadas?: SortOrder
    citasCanceladas?: SortOrder
    promedioSatisfaccion?: SortOrder
    totalEncuestas?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NotificacionCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    prioridad?: SortOrder
    leida?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    prioridad?: SortOrder
    leida?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    mensaje?: SortOrder
    prioridad?: SortOrder
    leida?: SortOrder
    estudianteId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.Channel | EnumChannelFieldRefInput<$PrismaModel>
    in?: $Enums.Channel[] | ListEnumChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Channel[] | ListEnumChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelFilter<$PrismaModel> | $Enums.Channel
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactTenantIdChannelExternalIdCompoundUniqueInput = {
    tenantId: string
    channel: $Enums.Channel
    externalId: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrder
    displayName?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrder
    displayName?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    channel?: SortOrder
    externalId?: SortOrder
    displayName?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Channel | EnumChannelFieldRefInput<$PrismaModel>
    in?: $Enums.Channel[] | ListEnumChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Channel[] | ListEnumChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelWithAggregatesFilter<$PrismaModel> | $Enums.Channel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChannelFilter<$PrismaModel>
    _max?: NestedEnumChannelFilter<$PrismaModel>
  }

  export type EnumConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusFilter<$PrismaModel> | $Enums.ConversationStatus
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ConversationContextListRelationFilter = {
    every?: ConversationContextWhereInput
    some?: ConversationContextWhereInput
    none?: ConversationContextWhereInput
  }

  export type ConversationContextOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrder
    currentFlowVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrder
    currentFlowVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    channel?: SortOrder
    status?: SortOrder
    lastMessageAt?: SortOrder
    currentFlowVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumConversationStatusFilter<$PrismaModel>
  }

  export type EnumDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionFilter<$PrismaModel> | $Enums.Direction
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    direction?: SortOrder
    type?: SortOrder
    text?: SortOrder
    payload?: SortOrder
    providerMessageId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    direction?: SortOrder
    type?: SortOrder
    text?: SortOrder
    providerMessageId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    contactId?: SortOrder
    direction?: SortOrder
    type?: SortOrder
    text?: SortOrder
    providerMessageId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionWithAggregatesFilter<$PrismaModel> | $Enums.Direction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectionFilter<$PrismaModel>
    _max?: NestedEnumDirectionFilter<$PrismaModel>
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type ConversationContextTenantIdConversationIdVersionCompoundUniqueInput = {
    tenantId: string
    conversationId: string
    version: number
  }

  export type ConversationContextCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    version?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationContextAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ConversationContextMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationContextMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    conversationId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationContextSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type IntentoLoginCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<IntentoLoginCreateWithoutUsuarioInput, IntentoLoginUncheckedCreateWithoutUsuarioInput> | IntentoLoginCreateWithoutUsuarioInput[] | IntentoLoginUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: IntentoLoginCreateOrConnectWithoutUsuarioInput | IntentoLoginCreateOrConnectWithoutUsuarioInput[]
    createMany?: IntentoLoginCreateManyUsuarioInputEnvelope
    connect?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
  }

  export type SesionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput> | SesionCreateWithoutUsuarioInput[] | SesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SesionCreateOrConnectWithoutUsuarioInput | SesionCreateOrConnectWithoutUsuarioInput[]
    createMany?: SesionCreateManyUsuarioInputEnvelope
    connect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
  }

  export type IntentoLoginUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<IntentoLoginCreateWithoutUsuarioInput, IntentoLoginUncheckedCreateWithoutUsuarioInput> | IntentoLoginCreateWithoutUsuarioInput[] | IntentoLoginUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: IntentoLoginCreateOrConnectWithoutUsuarioInput | IntentoLoginCreateOrConnectWithoutUsuarioInput[]
    createMany?: IntentoLoginCreateManyUsuarioInputEnvelope
    connect?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
  }

  export type SesionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput> | SesionCreateWithoutUsuarioInput[] | SesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SesionCreateOrConnectWithoutUsuarioInput | SesionCreateOrConnectWithoutUsuarioInput[]
    createMany?: SesionCreateManyUsuarioInputEnvelope
    connect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type EnumEstadoUsuarioFieldUpdateOperationsInput = {
    set?: $Enums.EstadoUsuario
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntentoLoginUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<IntentoLoginCreateWithoutUsuarioInput, IntentoLoginUncheckedCreateWithoutUsuarioInput> | IntentoLoginCreateWithoutUsuarioInput[] | IntentoLoginUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: IntentoLoginCreateOrConnectWithoutUsuarioInput | IntentoLoginCreateOrConnectWithoutUsuarioInput[]
    upsert?: IntentoLoginUpsertWithWhereUniqueWithoutUsuarioInput | IntentoLoginUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: IntentoLoginCreateManyUsuarioInputEnvelope
    set?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
    disconnect?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
    delete?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
    connect?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
    update?: IntentoLoginUpdateWithWhereUniqueWithoutUsuarioInput | IntentoLoginUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: IntentoLoginUpdateManyWithWhereWithoutUsuarioInput | IntentoLoginUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: IntentoLoginScalarWhereInput | IntentoLoginScalarWhereInput[]
  }

  export type SesionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput> | SesionCreateWithoutUsuarioInput[] | SesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SesionCreateOrConnectWithoutUsuarioInput | SesionCreateOrConnectWithoutUsuarioInput[]
    upsert?: SesionUpsertWithWhereUniqueWithoutUsuarioInput | SesionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: SesionCreateManyUsuarioInputEnvelope
    set?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    disconnect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    delete?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    connect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    update?: SesionUpdateWithWhereUniqueWithoutUsuarioInput | SesionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: SesionUpdateManyWithWhereWithoutUsuarioInput | SesionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: SesionScalarWhereInput | SesionScalarWhereInput[]
  }

  export type IntentoLoginUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<IntentoLoginCreateWithoutUsuarioInput, IntentoLoginUncheckedCreateWithoutUsuarioInput> | IntentoLoginCreateWithoutUsuarioInput[] | IntentoLoginUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: IntentoLoginCreateOrConnectWithoutUsuarioInput | IntentoLoginCreateOrConnectWithoutUsuarioInput[]
    upsert?: IntentoLoginUpsertWithWhereUniqueWithoutUsuarioInput | IntentoLoginUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: IntentoLoginCreateManyUsuarioInputEnvelope
    set?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
    disconnect?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
    delete?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
    connect?: IntentoLoginWhereUniqueInput | IntentoLoginWhereUniqueInput[]
    update?: IntentoLoginUpdateWithWhereUniqueWithoutUsuarioInput | IntentoLoginUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: IntentoLoginUpdateManyWithWhereWithoutUsuarioInput | IntentoLoginUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: IntentoLoginScalarWhereInput | IntentoLoginScalarWhereInput[]
  }

  export type SesionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput> | SesionCreateWithoutUsuarioInput[] | SesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SesionCreateOrConnectWithoutUsuarioInput | SesionCreateOrConnectWithoutUsuarioInput[]
    upsert?: SesionUpsertWithWhereUniqueWithoutUsuarioInput | SesionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: SesionCreateManyUsuarioInputEnvelope
    set?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    disconnect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    delete?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    connect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    update?: SesionUpdateWithWhereUniqueWithoutUsuarioInput | SesionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: SesionUpdateManyWithWhereWithoutUsuarioInput | SesionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: SesionScalarWhereInput | SesionScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutIntentosLoginInput = {
    create?: XOR<UsuarioCreateWithoutIntentosLoginInput, UsuarioUncheckedCreateWithoutIntentosLoginInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutIntentosLoginInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EnumTipoIntentoLoginFieldUpdateOperationsInput = {
    set?: $Enums.TipoIntentoLogin
  }

  export type EnumOrigenIntentoFieldUpdateOperationsInput = {
    set?: $Enums.OrigenIntento
  }

  export type UsuarioUpdateOneWithoutIntentosLoginNestedInput = {
    create?: XOR<UsuarioCreateWithoutIntentosLoginInput, UsuarioUncheckedCreateWithoutIntentosLoginInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutIntentosLoginInput
    upsert?: UsuarioUpsertWithoutIntentosLoginInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutIntentosLoginInput, UsuarioUpdateWithoutIntentosLoginInput>, UsuarioUncheckedUpdateWithoutIntentosLoginInput>
  }

  export type UsuarioCreateNestedOneWithoutSesionesInput = {
    create?: XOR<UsuarioCreateWithoutSesionesInput, UsuarioUncheckedCreateWithoutSesionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSesionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutSesionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutSesionesInput, UsuarioUncheckedCreateWithoutSesionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSesionesInput
    upsert?: UsuarioUpsertWithoutSesionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutSesionesInput, UsuarioUpdateWithoutSesionesInput>, UsuarioUncheckedUpdateWithoutSesionesInput>
  }

  export type CitaCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<CitaCreateWithoutEstudianteInput, CitaUncheckedCreateWithoutEstudianteInput> | CitaCreateWithoutEstudianteInput[] | CitaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: CitaCreateOrConnectWithoutEstudianteInput | CitaCreateOrConnectWithoutEstudianteInput[]
    createMany?: CitaCreateManyEstudianteInputEnvelope
    connect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
  }

  export type ConversacionCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<ConversacionCreateWithoutEstudianteInput, ConversacionUncheckedCreateWithoutEstudianteInput> | ConversacionCreateWithoutEstudianteInput[] | ConversacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: ConversacionCreateOrConnectWithoutEstudianteInput | ConversacionCreateOrConnectWithoutEstudianteInput[]
    createMany?: ConversacionCreateManyEstudianteInputEnvelope
    connect?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
  }

  export type EncuestaSatisfaccionCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<EncuestaSatisfaccionCreateWithoutEstudianteInput, EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput> | EncuestaSatisfaccionCreateWithoutEstudianteInput[] | EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput | EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput[]
    createMany?: EncuestaSatisfaccionCreateManyEstudianteInputEnvelope
    connect?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
  }

  export type AsesoramientoCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<AsesoramientoCreateWithoutEstudianteInput, AsesoramientoUncheckedCreateWithoutEstudianteInput> | AsesoramientoCreateWithoutEstudianteInput[] | AsesoramientoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: AsesoramientoCreateOrConnectWithoutEstudianteInput | AsesoramientoCreateOrConnectWithoutEstudianteInput[]
    createMany?: AsesoramientoCreateManyEstudianteInputEnvelope
    connect?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
  }

  export type CitaUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<CitaCreateWithoutEstudianteInput, CitaUncheckedCreateWithoutEstudianteInput> | CitaCreateWithoutEstudianteInput[] | CitaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: CitaCreateOrConnectWithoutEstudianteInput | CitaCreateOrConnectWithoutEstudianteInput[]
    createMany?: CitaCreateManyEstudianteInputEnvelope
    connect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
  }

  export type ConversacionUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<ConversacionCreateWithoutEstudianteInput, ConversacionUncheckedCreateWithoutEstudianteInput> | ConversacionCreateWithoutEstudianteInput[] | ConversacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: ConversacionCreateOrConnectWithoutEstudianteInput | ConversacionCreateOrConnectWithoutEstudianteInput[]
    createMany?: ConversacionCreateManyEstudianteInputEnvelope
    connect?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
  }

  export type EncuestaSatisfaccionUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<EncuestaSatisfaccionCreateWithoutEstudianteInput, EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput> | EncuestaSatisfaccionCreateWithoutEstudianteInput[] | EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput | EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput[]
    createMany?: EncuestaSatisfaccionCreateManyEstudianteInputEnvelope
    connect?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
  }

  export type AsesoramientoUncheckedCreateNestedManyWithoutEstudianteInput = {
    create?: XOR<AsesoramientoCreateWithoutEstudianteInput, AsesoramientoUncheckedCreateWithoutEstudianteInput> | AsesoramientoCreateWithoutEstudianteInput[] | AsesoramientoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: AsesoramientoCreateOrConnectWithoutEstudianteInput | AsesoramientoCreateOrConnectWithoutEstudianteInput[]
    createMany?: AsesoramientoCreateManyEstudianteInputEnvelope
    connect?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumModalidadFieldUpdateOperationsInput = {
    set?: $Enums.Modalidad
  }

  export type EnumEstadoEstudianteFieldUpdateOperationsInput = {
    set?: $Enums.EstadoEstudiante
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CitaUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<CitaCreateWithoutEstudianteInput, CitaUncheckedCreateWithoutEstudianteInput> | CitaCreateWithoutEstudianteInput[] | CitaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: CitaCreateOrConnectWithoutEstudianteInput | CitaCreateOrConnectWithoutEstudianteInput[]
    upsert?: CitaUpsertWithWhereUniqueWithoutEstudianteInput | CitaUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: CitaCreateManyEstudianteInputEnvelope
    set?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    disconnect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    delete?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    connect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    update?: CitaUpdateWithWhereUniqueWithoutEstudianteInput | CitaUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: CitaUpdateManyWithWhereWithoutEstudianteInput | CitaUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: CitaScalarWhereInput | CitaScalarWhereInput[]
  }

  export type ConversacionUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<ConversacionCreateWithoutEstudianteInput, ConversacionUncheckedCreateWithoutEstudianteInput> | ConversacionCreateWithoutEstudianteInput[] | ConversacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: ConversacionCreateOrConnectWithoutEstudianteInput | ConversacionCreateOrConnectWithoutEstudianteInput[]
    upsert?: ConversacionUpsertWithWhereUniqueWithoutEstudianteInput | ConversacionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: ConversacionCreateManyEstudianteInputEnvelope
    set?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
    disconnect?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
    delete?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
    connect?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
    update?: ConversacionUpdateWithWhereUniqueWithoutEstudianteInput | ConversacionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: ConversacionUpdateManyWithWhereWithoutEstudianteInput | ConversacionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: ConversacionScalarWhereInput | ConversacionScalarWhereInput[]
  }

  export type EncuestaSatisfaccionUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<EncuestaSatisfaccionCreateWithoutEstudianteInput, EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput> | EncuestaSatisfaccionCreateWithoutEstudianteInput[] | EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput | EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput[]
    upsert?: EncuestaSatisfaccionUpsertWithWhereUniqueWithoutEstudianteInput | EncuestaSatisfaccionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: EncuestaSatisfaccionCreateManyEstudianteInputEnvelope
    set?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
    disconnect?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
    delete?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
    connect?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
    update?: EncuestaSatisfaccionUpdateWithWhereUniqueWithoutEstudianteInput | EncuestaSatisfaccionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: EncuestaSatisfaccionUpdateManyWithWhereWithoutEstudianteInput | EncuestaSatisfaccionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: EncuestaSatisfaccionScalarWhereInput | EncuestaSatisfaccionScalarWhereInput[]
  }

  export type AsesoramientoUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<AsesoramientoCreateWithoutEstudianteInput, AsesoramientoUncheckedCreateWithoutEstudianteInput> | AsesoramientoCreateWithoutEstudianteInput[] | AsesoramientoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: AsesoramientoCreateOrConnectWithoutEstudianteInput | AsesoramientoCreateOrConnectWithoutEstudianteInput[]
    upsert?: AsesoramientoUpsertWithWhereUniqueWithoutEstudianteInput | AsesoramientoUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: AsesoramientoCreateManyEstudianteInputEnvelope
    set?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
    disconnect?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
    delete?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
    connect?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
    update?: AsesoramientoUpdateWithWhereUniqueWithoutEstudianteInput | AsesoramientoUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: AsesoramientoUpdateManyWithWhereWithoutEstudianteInput | AsesoramientoUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: AsesoramientoScalarWhereInput | AsesoramientoScalarWhereInput[]
  }

  export type CitaUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<CitaCreateWithoutEstudianteInput, CitaUncheckedCreateWithoutEstudianteInput> | CitaCreateWithoutEstudianteInput[] | CitaUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: CitaCreateOrConnectWithoutEstudianteInput | CitaCreateOrConnectWithoutEstudianteInput[]
    upsert?: CitaUpsertWithWhereUniqueWithoutEstudianteInput | CitaUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: CitaCreateManyEstudianteInputEnvelope
    set?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    disconnect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    delete?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    connect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    update?: CitaUpdateWithWhereUniqueWithoutEstudianteInput | CitaUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: CitaUpdateManyWithWhereWithoutEstudianteInput | CitaUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: CitaScalarWhereInput | CitaScalarWhereInput[]
  }

  export type ConversacionUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<ConversacionCreateWithoutEstudianteInput, ConversacionUncheckedCreateWithoutEstudianteInput> | ConversacionCreateWithoutEstudianteInput[] | ConversacionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: ConversacionCreateOrConnectWithoutEstudianteInput | ConversacionCreateOrConnectWithoutEstudianteInput[]
    upsert?: ConversacionUpsertWithWhereUniqueWithoutEstudianteInput | ConversacionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: ConversacionCreateManyEstudianteInputEnvelope
    set?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
    disconnect?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
    delete?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
    connect?: ConversacionWhereUniqueInput | ConversacionWhereUniqueInput[]
    update?: ConversacionUpdateWithWhereUniqueWithoutEstudianteInput | ConversacionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: ConversacionUpdateManyWithWhereWithoutEstudianteInput | ConversacionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: ConversacionScalarWhereInput | ConversacionScalarWhereInput[]
  }

  export type EncuestaSatisfaccionUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<EncuestaSatisfaccionCreateWithoutEstudianteInput, EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput> | EncuestaSatisfaccionCreateWithoutEstudianteInput[] | EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput | EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput[]
    upsert?: EncuestaSatisfaccionUpsertWithWhereUniqueWithoutEstudianteInput | EncuestaSatisfaccionUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: EncuestaSatisfaccionCreateManyEstudianteInputEnvelope
    set?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
    disconnect?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
    delete?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
    connect?: EncuestaSatisfaccionWhereUniqueInput | EncuestaSatisfaccionWhereUniqueInput[]
    update?: EncuestaSatisfaccionUpdateWithWhereUniqueWithoutEstudianteInput | EncuestaSatisfaccionUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: EncuestaSatisfaccionUpdateManyWithWhereWithoutEstudianteInput | EncuestaSatisfaccionUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: EncuestaSatisfaccionScalarWhereInput | EncuestaSatisfaccionScalarWhereInput[]
  }

  export type AsesoramientoUncheckedUpdateManyWithoutEstudianteNestedInput = {
    create?: XOR<AsesoramientoCreateWithoutEstudianteInput, AsesoramientoUncheckedCreateWithoutEstudianteInput> | AsesoramientoCreateWithoutEstudianteInput[] | AsesoramientoUncheckedCreateWithoutEstudianteInput[]
    connectOrCreate?: AsesoramientoCreateOrConnectWithoutEstudianteInput | AsesoramientoCreateOrConnectWithoutEstudianteInput[]
    upsert?: AsesoramientoUpsertWithWhereUniqueWithoutEstudianteInput | AsesoramientoUpsertWithWhereUniqueWithoutEstudianteInput[]
    createMany?: AsesoramientoCreateManyEstudianteInputEnvelope
    set?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
    disconnect?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
    delete?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
    connect?: AsesoramientoWhereUniqueInput | AsesoramientoWhereUniqueInput[]
    update?: AsesoramientoUpdateWithWhereUniqueWithoutEstudianteInput | AsesoramientoUpdateWithWhereUniqueWithoutEstudianteInput[]
    updateMany?: AsesoramientoUpdateManyWithWhereWithoutEstudianteInput | AsesoramientoUpdateManyWithWhereWithoutEstudianteInput[]
    deleteMany?: AsesoramientoScalarWhereInput | AsesoramientoScalarWhereInput[]
  }

  export type EstudianteCreateNestedOneWithoutCitasInput = {
    create?: XOR<EstudianteCreateWithoutCitasInput, EstudianteUncheckedCreateWithoutCitasInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutCitasInput
    connect?: EstudianteWhereUniqueInput
  }

  export type ConversacionCreateNestedOneWithoutCitasInput = {
    create?: XOR<ConversacionCreateWithoutCitasInput, ConversacionUncheckedCreateWithoutCitasInput>
    connectOrCreate?: ConversacionCreateOrConnectWithoutCitasInput
    connect?: ConversacionWhereUniqueInput
  }

  export type EnumEstadoCitaFieldUpdateOperationsInput = {
    set?: $Enums.EstadoCita
  }

  export type EstudianteUpdateOneRequiredWithoutCitasNestedInput = {
    create?: XOR<EstudianteCreateWithoutCitasInput, EstudianteUncheckedCreateWithoutCitasInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutCitasInput
    upsert?: EstudianteUpsertWithoutCitasInput
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutCitasInput, EstudianteUpdateWithoutCitasInput>, EstudianteUncheckedUpdateWithoutCitasInput>
  }

  export type ConversacionUpdateOneWithoutCitasNestedInput = {
    create?: XOR<ConversacionCreateWithoutCitasInput, ConversacionUncheckedCreateWithoutCitasInput>
    connectOrCreate?: ConversacionCreateOrConnectWithoutCitasInput
    upsert?: ConversacionUpsertWithoutCitasInput
    disconnect?: ConversacionWhereInput | boolean
    delete?: ConversacionWhereInput | boolean
    connect?: ConversacionWhereUniqueInput
    update?: XOR<XOR<ConversacionUpdateToOneWithWhereWithoutCitasInput, ConversacionUpdateWithoutCitasInput>, ConversacionUncheckedUpdateWithoutCitasInput>
  }

  export type EnumTipoAuditoriaFieldUpdateOperationsInput = {
    set?: $Enums.TipoAuditoria
  }

  export type EstudianteCreateNestedOneWithoutConversacionesInput = {
    create?: XOR<EstudianteCreateWithoutConversacionesInput, EstudianteUncheckedCreateWithoutConversacionesInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutConversacionesInput
    connect?: EstudianteWhereUniqueInput
  }

  export type CitaCreateNestedManyWithoutConversacionInput = {
    create?: XOR<CitaCreateWithoutConversacionInput, CitaUncheckedCreateWithoutConversacionInput> | CitaCreateWithoutConversacionInput[] | CitaUncheckedCreateWithoutConversacionInput[]
    connectOrCreate?: CitaCreateOrConnectWithoutConversacionInput | CitaCreateOrConnectWithoutConversacionInput[]
    createMany?: CitaCreateManyConversacionInputEnvelope
    connect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
  }

  export type MensajeCreateNestedManyWithoutConversacionInput = {
    create?: XOR<MensajeCreateWithoutConversacionInput, MensajeUncheckedCreateWithoutConversacionInput> | MensajeCreateWithoutConversacionInput[] | MensajeUncheckedCreateWithoutConversacionInput[]
    connectOrCreate?: MensajeCreateOrConnectWithoutConversacionInput | MensajeCreateOrConnectWithoutConversacionInput[]
    createMany?: MensajeCreateManyConversacionInputEnvelope
    connect?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
  }

  export type AsesoramientoCreateNestedOneWithoutConversacionInput = {
    create?: XOR<AsesoramientoCreateWithoutConversacionInput, AsesoramientoUncheckedCreateWithoutConversacionInput>
    connectOrCreate?: AsesoramientoCreateOrConnectWithoutConversacionInput
    connect?: AsesoramientoWhereUniqueInput
  }

  export type EncuestaSatisfaccionCreateNestedOneWithoutConversacionInput = {
    create?: XOR<EncuestaSatisfaccionCreateWithoutConversacionInput, EncuestaSatisfaccionUncheckedCreateWithoutConversacionInput>
    connectOrCreate?: EncuestaSatisfaccionCreateOrConnectWithoutConversacionInput
    connect?: EncuestaSatisfaccionWhereUniqueInput
  }

  export type CitaUncheckedCreateNestedManyWithoutConversacionInput = {
    create?: XOR<CitaCreateWithoutConversacionInput, CitaUncheckedCreateWithoutConversacionInput> | CitaCreateWithoutConversacionInput[] | CitaUncheckedCreateWithoutConversacionInput[]
    connectOrCreate?: CitaCreateOrConnectWithoutConversacionInput | CitaCreateOrConnectWithoutConversacionInput[]
    createMany?: CitaCreateManyConversacionInputEnvelope
    connect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
  }

  export type MensajeUncheckedCreateNestedManyWithoutConversacionInput = {
    create?: XOR<MensajeCreateWithoutConversacionInput, MensajeUncheckedCreateWithoutConversacionInput> | MensajeCreateWithoutConversacionInput[] | MensajeUncheckedCreateWithoutConversacionInput[]
    connectOrCreate?: MensajeCreateOrConnectWithoutConversacionInput | MensajeCreateOrConnectWithoutConversacionInput[]
    createMany?: MensajeCreateManyConversacionInputEnvelope
    connect?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
  }

  export type AsesoramientoUncheckedCreateNestedOneWithoutConversacionInput = {
    create?: XOR<AsesoramientoCreateWithoutConversacionInput, AsesoramientoUncheckedCreateWithoutConversacionInput>
    connectOrCreate?: AsesoramientoCreateOrConnectWithoutConversacionInput
    connect?: AsesoramientoWhereUniqueInput
  }

  export type EncuestaSatisfaccionUncheckedCreateNestedOneWithoutConversacionInput = {
    create?: XOR<EncuestaSatisfaccionCreateWithoutConversacionInput, EncuestaSatisfaccionUncheckedCreateWithoutConversacionInput>
    connectOrCreate?: EncuestaSatisfaccionCreateOrConnectWithoutConversacionInput
    connect?: EncuestaSatisfaccionWhereUniqueInput
  }

  export type EstudianteUpdateOneWithoutConversacionesNestedInput = {
    create?: XOR<EstudianteCreateWithoutConversacionesInput, EstudianteUncheckedCreateWithoutConversacionesInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutConversacionesInput
    upsert?: EstudianteUpsertWithoutConversacionesInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutConversacionesInput, EstudianteUpdateWithoutConversacionesInput>, EstudianteUncheckedUpdateWithoutConversacionesInput>
  }

  export type CitaUpdateManyWithoutConversacionNestedInput = {
    create?: XOR<CitaCreateWithoutConversacionInput, CitaUncheckedCreateWithoutConversacionInput> | CitaCreateWithoutConversacionInput[] | CitaUncheckedCreateWithoutConversacionInput[]
    connectOrCreate?: CitaCreateOrConnectWithoutConversacionInput | CitaCreateOrConnectWithoutConversacionInput[]
    upsert?: CitaUpsertWithWhereUniqueWithoutConversacionInput | CitaUpsertWithWhereUniqueWithoutConversacionInput[]
    createMany?: CitaCreateManyConversacionInputEnvelope
    set?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    disconnect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    delete?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    connect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    update?: CitaUpdateWithWhereUniqueWithoutConversacionInput | CitaUpdateWithWhereUniqueWithoutConversacionInput[]
    updateMany?: CitaUpdateManyWithWhereWithoutConversacionInput | CitaUpdateManyWithWhereWithoutConversacionInput[]
    deleteMany?: CitaScalarWhereInput | CitaScalarWhereInput[]
  }

  export type MensajeUpdateManyWithoutConversacionNestedInput = {
    create?: XOR<MensajeCreateWithoutConversacionInput, MensajeUncheckedCreateWithoutConversacionInput> | MensajeCreateWithoutConversacionInput[] | MensajeUncheckedCreateWithoutConversacionInput[]
    connectOrCreate?: MensajeCreateOrConnectWithoutConversacionInput | MensajeCreateOrConnectWithoutConversacionInput[]
    upsert?: MensajeUpsertWithWhereUniqueWithoutConversacionInput | MensajeUpsertWithWhereUniqueWithoutConversacionInput[]
    createMany?: MensajeCreateManyConversacionInputEnvelope
    set?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
    disconnect?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
    delete?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
    connect?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
    update?: MensajeUpdateWithWhereUniqueWithoutConversacionInput | MensajeUpdateWithWhereUniqueWithoutConversacionInput[]
    updateMany?: MensajeUpdateManyWithWhereWithoutConversacionInput | MensajeUpdateManyWithWhereWithoutConversacionInput[]
    deleteMany?: MensajeScalarWhereInput | MensajeScalarWhereInput[]
  }

  export type AsesoramientoUpdateOneWithoutConversacionNestedInput = {
    create?: XOR<AsesoramientoCreateWithoutConversacionInput, AsesoramientoUncheckedCreateWithoutConversacionInput>
    connectOrCreate?: AsesoramientoCreateOrConnectWithoutConversacionInput
    upsert?: AsesoramientoUpsertWithoutConversacionInput
    disconnect?: AsesoramientoWhereInput | boolean
    delete?: AsesoramientoWhereInput | boolean
    connect?: AsesoramientoWhereUniqueInput
    update?: XOR<XOR<AsesoramientoUpdateToOneWithWhereWithoutConversacionInput, AsesoramientoUpdateWithoutConversacionInput>, AsesoramientoUncheckedUpdateWithoutConversacionInput>
  }

  export type EncuestaSatisfaccionUpdateOneWithoutConversacionNestedInput = {
    create?: XOR<EncuestaSatisfaccionCreateWithoutConversacionInput, EncuestaSatisfaccionUncheckedCreateWithoutConversacionInput>
    connectOrCreate?: EncuestaSatisfaccionCreateOrConnectWithoutConversacionInput
    upsert?: EncuestaSatisfaccionUpsertWithoutConversacionInput
    disconnect?: EncuestaSatisfaccionWhereInput | boolean
    delete?: EncuestaSatisfaccionWhereInput | boolean
    connect?: EncuestaSatisfaccionWhereUniqueInput
    update?: XOR<XOR<EncuestaSatisfaccionUpdateToOneWithWhereWithoutConversacionInput, EncuestaSatisfaccionUpdateWithoutConversacionInput>, EncuestaSatisfaccionUncheckedUpdateWithoutConversacionInput>
  }

  export type CitaUncheckedUpdateManyWithoutConversacionNestedInput = {
    create?: XOR<CitaCreateWithoutConversacionInput, CitaUncheckedCreateWithoutConversacionInput> | CitaCreateWithoutConversacionInput[] | CitaUncheckedCreateWithoutConversacionInput[]
    connectOrCreate?: CitaCreateOrConnectWithoutConversacionInput | CitaCreateOrConnectWithoutConversacionInput[]
    upsert?: CitaUpsertWithWhereUniqueWithoutConversacionInput | CitaUpsertWithWhereUniqueWithoutConversacionInput[]
    createMany?: CitaCreateManyConversacionInputEnvelope
    set?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    disconnect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    delete?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    connect?: CitaWhereUniqueInput | CitaWhereUniqueInput[]
    update?: CitaUpdateWithWhereUniqueWithoutConversacionInput | CitaUpdateWithWhereUniqueWithoutConversacionInput[]
    updateMany?: CitaUpdateManyWithWhereWithoutConversacionInput | CitaUpdateManyWithWhereWithoutConversacionInput[]
    deleteMany?: CitaScalarWhereInput | CitaScalarWhereInput[]
  }

  export type MensajeUncheckedUpdateManyWithoutConversacionNestedInput = {
    create?: XOR<MensajeCreateWithoutConversacionInput, MensajeUncheckedCreateWithoutConversacionInput> | MensajeCreateWithoutConversacionInput[] | MensajeUncheckedCreateWithoutConversacionInput[]
    connectOrCreate?: MensajeCreateOrConnectWithoutConversacionInput | MensajeCreateOrConnectWithoutConversacionInput[]
    upsert?: MensajeUpsertWithWhereUniqueWithoutConversacionInput | MensajeUpsertWithWhereUniqueWithoutConversacionInput[]
    createMany?: MensajeCreateManyConversacionInputEnvelope
    set?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
    disconnect?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
    delete?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
    connect?: MensajeWhereUniqueInput | MensajeWhereUniqueInput[]
    update?: MensajeUpdateWithWhereUniqueWithoutConversacionInput | MensajeUpdateWithWhereUniqueWithoutConversacionInput[]
    updateMany?: MensajeUpdateManyWithWhereWithoutConversacionInput | MensajeUpdateManyWithWhereWithoutConversacionInput[]
    deleteMany?: MensajeScalarWhereInput | MensajeScalarWhereInput[]
  }

  export type AsesoramientoUncheckedUpdateOneWithoutConversacionNestedInput = {
    create?: XOR<AsesoramientoCreateWithoutConversacionInput, AsesoramientoUncheckedCreateWithoutConversacionInput>
    connectOrCreate?: AsesoramientoCreateOrConnectWithoutConversacionInput
    upsert?: AsesoramientoUpsertWithoutConversacionInput
    disconnect?: AsesoramientoWhereInput | boolean
    delete?: AsesoramientoWhereInput | boolean
    connect?: AsesoramientoWhereUniqueInput
    update?: XOR<XOR<AsesoramientoUpdateToOneWithWhereWithoutConversacionInput, AsesoramientoUpdateWithoutConversacionInput>, AsesoramientoUncheckedUpdateWithoutConversacionInput>
  }

  export type EncuestaSatisfaccionUncheckedUpdateOneWithoutConversacionNestedInput = {
    create?: XOR<EncuestaSatisfaccionCreateWithoutConversacionInput, EncuestaSatisfaccionUncheckedCreateWithoutConversacionInput>
    connectOrCreate?: EncuestaSatisfaccionCreateOrConnectWithoutConversacionInput
    upsert?: EncuestaSatisfaccionUpsertWithoutConversacionInput
    disconnect?: EncuestaSatisfaccionWhereInput | boolean
    delete?: EncuestaSatisfaccionWhereInput | boolean
    connect?: EncuestaSatisfaccionWhereUniqueInput
    update?: XOR<XOR<EncuestaSatisfaccionUpdateToOneWithWhereWithoutConversacionInput, EncuestaSatisfaccionUpdateWithoutConversacionInput>, EncuestaSatisfaccionUncheckedUpdateWithoutConversacionInput>
  }

  export type ConversacionCreateNestedOneWithoutMensajesInput = {
    create?: XOR<ConversacionCreateWithoutMensajesInput, ConversacionUncheckedCreateWithoutMensajesInput>
    connectOrCreate?: ConversacionCreateOrConnectWithoutMensajesInput
    connect?: ConversacionWhereUniqueInput
  }

  export type ConversacionUpdateOneRequiredWithoutMensajesNestedInput = {
    create?: XOR<ConversacionCreateWithoutMensajesInput, ConversacionUncheckedCreateWithoutMensajesInput>
    connectOrCreate?: ConversacionCreateOrConnectWithoutMensajesInput
    upsert?: ConversacionUpsertWithoutMensajesInput
    connect?: ConversacionWhereUniqueInput
    update?: XOR<XOR<ConversacionUpdateToOneWithWhereWithoutMensajesInput, ConversacionUpdateWithoutMensajesInput>, ConversacionUncheckedUpdateWithoutMensajesInput>
  }

  export type ConversacionCreateNestedOneWithoutAsesoramientoInput = {
    create?: XOR<ConversacionCreateWithoutAsesoramientoInput, ConversacionUncheckedCreateWithoutAsesoramientoInput>
    connectOrCreate?: ConversacionCreateOrConnectWithoutAsesoramientoInput
    connect?: ConversacionWhereUniqueInput
  }

  export type EstudianteCreateNestedOneWithoutAsesoramientoInput = {
    create?: XOR<EstudianteCreateWithoutAsesoramientoInput, EstudianteUncheckedCreateWithoutAsesoramientoInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutAsesoramientoInput
    connect?: EstudianteWhereUniqueInput
  }

  export type ConversacionUpdateOneRequiredWithoutAsesoramientoNestedInput = {
    create?: XOR<ConversacionCreateWithoutAsesoramientoInput, ConversacionUncheckedCreateWithoutAsesoramientoInput>
    connectOrCreate?: ConversacionCreateOrConnectWithoutAsesoramientoInput
    upsert?: ConversacionUpsertWithoutAsesoramientoInput
    connect?: ConversacionWhereUniqueInput
    update?: XOR<XOR<ConversacionUpdateToOneWithWhereWithoutAsesoramientoInput, ConversacionUpdateWithoutAsesoramientoInput>, ConversacionUncheckedUpdateWithoutAsesoramientoInput>
  }

  export type EstudianteUpdateOneWithoutAsesoramientoNestedInput = {
    create?: XOR<EstudianteCreateWithoutAsesoramientoInput, EstudianteUncheckedCreateWithoutAsesoramientoInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutAsesoramientoInput
    upsert?: EstudianteUpsertWithoutAsesoramientoInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutAsesoramientoInput, EstudianteUpdateWithoutAsesoramientoInput>, EstudianteUncheckedUpdateWithoutAsesoramientoInput>
  }

  export type ConversacionCreateNestedOneWithoutEncuestaInput = {
    create?: XOR<ConversacionCreateWithoutEncuestaInput, ConversacionUncheckedCreateWithoutEncuestaInput>
    connectOrCreate?: ConversacionCreateOrConnectWithoutEncuestaInput
    connect?: ConversacionWhereUniqueInput
  }

  export type EstudianteCreateNestedOneWithoutEncuestasInput = {
    create?: XOR<EstudianteCreateWithoutEncuestasInput, EstudianteUncheckedCreateWithoutEncuestasInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutEncuestasInput
    connect?: EstudianteWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConversacionUpdateOneWithoutEncuestaNestedInput = {
    create?: XOR<ConversacionCreateWithoutEncuestaInput, ConversacionUncheckedCreateWithoutEncuestaInput>
    connectOrCreate?: ConversacionCreateOrConnectWithoutEncuestaInput
    upsert?: ConversacionUpsertWithoutEncuestaInput
    disconnect?: ConversacionWhereInput | boolean
    delete?: ConversacionWhereInput | boolean
    connect?: ConversacionWhereUniqueInput
    update?: XOR<XOR<ConversacionUpdateToOneWithWhereWithoutEncuestaInput, ConversacionUpdateWithoutEncuestaInput>, ConversacionUncheckedUpdateWithoutEncuestaInput>
  }

  export type EstudianteUpdateOneWithoutEncuestasNestedInput = {
    create?: XOR<EstudianteCreateWithoutEncuestasInput, EstudianteUncheckedCreateWithoutEncuestasInput>
    connectOrCreate?: EstudianteCreateOrConnectWithoutEncuestasInput
    upsert?: EstudianteUpsertWithoutEncuestasInput
    disconnect?: EstudianteWhereInput | boolean
    delete?: EstudianteWhereInput | boolean
    connect?: EstudianteWhereUniqueInput
    update?: XOR<XOR<EstudianteUpdateToOneWithWhereWithoutEncuestasInput, EstudianteUpdateWithoutEncuestasInput>, EstudianteUncheckedUpdateWithoutEncuestasInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConversationCreateNestedManyWithoutContactInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutContactInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumChannelFieldUpdateOperationsInput = {
    set?: $Enums.Channel
  }

  export type ConversationUpdateManyWithoutContactNestedInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutContactInput | ConversationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutContactInput | ConversationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutContactInput | ConversationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutContactNestedInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutContactInput | MessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutContactInput | MessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutContactInput | MessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput> | ConversationCreateWithoutContactInput[] | ConversationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutContactInput | ConversationCreateOrConnectWithoutContactInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutContactInput | ConversationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ConversationCreateManyContactInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutContactInput | ConversationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutContactInput | ConversationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput> | MessageCreateWithoutContactInput[] | MessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutContactInput | MessageCreateOrConnectWithoutContactInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutContactInput | MessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: MessageCreateManyContactInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutContactInput | MessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutContactInput | MessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutConversationsInput
    connect?: ContactWhereUniqueInput
  }

  export type ConversationContextCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationContextCreateWithoutConversationInput, ConversationContextUncheckedCreateWithoutConversationInput> | ConversationContextCreateWithoutConversationInput[] | ConversationContextUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationContextCreateOrConnectWithoutConversationInput | ConversationContextCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationContextCreateManyConversationInputEnvelope
    connect?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationContextUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationContextCreateWithoutConversationInput, ConversationContextUncheckedCreateWithoutConversationInput> | ConversationContextCreateWithoutConversationInput[] | ConversationContextUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationContextCreateOrConnectWithoutConversationInput | ConversationContextCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationContextCreateManyConversationInputEnvelope
    connect?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumConversationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConversationStatus
  }

  export type ContactUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutConversationsInput
    upsert?: ContactUpsertWithoutConversationsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutConversationsInput, ContactUpdateWithoutConversationsInput>, ContactUncheckedUpdateWithoutConversationsInput>
  }

  export type ConversationContextUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationContextCreateWithoutConversationInput, ConversationContextUncheckedCreateWithoutConversationInput> | ConversationContextCreateWithoutConversationInput[] | ConversationContextUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationContextCreateOrConnectWithoutConversationInput | ConversationContextCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationContextUpsertWithWhereUniqueWithoutConversationInput | ConversationContextUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationContextCreateManyConversationInputEnvelope
    set?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
    disconnect?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
    delete?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
    connect?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
    update?: ConversationContextUpdateWithWhereUniqueWithoutConversationInput | ConversationContextUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationContextUpdateManyWithWhereWithoutConversationInput | ConversationContextUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationContextScalarWhereInput | ConversationContextScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationContextUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationContextCreateWithoutConversationInput, ConversationContextUncheckedCreateWithoutConversationInput> | ConversationContextCreateWithoutConversationInput[] | ConversationContextUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationContextCreateOrConnectWithoutConversationInput | ConversationContextCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationContextUpsertWithWhereUniqueWithoutConversationInput | ConversationContextUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationContextCreateManyConversationInputEnvelope
    set?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
    disconnect?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
    delete?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
    connect?: ConversationContextWhereUniqueInput | ConversationContextWhereUniqueInput[]
    update?: ConversationContextUpdateWithWhereUniqueWithoutConversationInput | ConversationContextUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationContextUpdateManyWithWhereWithoutConversationInput | ConversationContextUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationContextScalarWhereInput | ConversationContextScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ContactCreateWithoutMessagesInput, ContactUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutMessagesInput
    connect?: ContactWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type EnumDirectionFieldUpdateOperationsInput = {
    set?: $Enums.Direction
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type ContactUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ContactCreateWithoutMessagesInput, ContactUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutMessagesInput
    upsert?: ContactUpsertWithoutMessagesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutMessagesInput, ContactUpdateWithoutMessagesInput>, ContactUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationCreateNestedOneWithoutContextsInput = {
    create?: XOR<ConversationCreateWithoutContextsInput, ConversationUncheckedCreateWithoutContextsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutContextsInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutContextsNestedInput = {
    create?: XOR<ConversationCreateWithoutContextsInput, ConversationUncheckedCreateWithoutContextsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutContextsInput
    upsert?: ConversationUpsertWithoutContextsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutContextsInput, ConversationUpdateWithoutContextsInput>, ConversationUncheckedUpdateWithoutContextsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedEnumEstadoUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoUsuario | EnumEstadoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoUsuarioFilter<$PrismaModel> | $Enums.EstadoUsuario
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedEnumEstadoUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoUsuario | EnumEstadoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoUsuarioFilter<$PrismaModel>
    _max?: NestedEnumEstadoUsuarioFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTipoIntentoLoginFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoIntentoLogin | EnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    in?: $Enums.TipoIntentoLogin[] | ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoIntentoLogin[] | ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoIntentoLoginFilter<$PrismaModel> | $Enums.TipoIntentoLogin
  }

  export type NestedEnumOrigenIntentoFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigenIntento | EnumOrigenIntentoFieldRefInput<$PrismaModel>
    in?: $Enums.OrigenIntento[] | ListEnumOrigenIntentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrigenIntento[] | ListEnumOrigenIntentoFieldRefInput<$PrismaModel>
    not?: NestedEnumOrigenIntentoFilter<$PrismaModel> | $Enums.OrigenIntento
  }

  export type NestedEnumTipoIntentoLoginWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoIntentoLogin | EnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    in?: $Enums.TipoIntentoLogin[] | ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoIntentoLogin[] | ListEnumTipoIntentoLoginFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoIntentoLoginWithAggregatesFilter<$PrismaModel> | $Enums.TipoIntentoLogin
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoIntentoLoginFilter<$PrismaModel>
    _max?: NestedEnumTipoIntentoLoginFilter<$PrismaModel>
  }

  export type NestedEnumOrigenIntentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigenIntento | EnumOrigenIntentoFieldRefInput<$PrismaModel>
    in?: $Enums.OrigenIntento[] | ListEnumOrigenIntentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrigenIntento[] | ListEnumOrigenIntentoFieldRefInput<$PrismaModel>
    not?: NestedEnumOrigenIntentoWithAggregatesFilter<$PrismaModel> | $Enums.OrigenIntento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrigenIntentoFilter<$PrismaModel>
    _max?: NestedEnumOrigenIntentoFilter<$PrismaModel>
  }

  export type NestedEnumModalidadFilter<$PrismaModel = never> = {
    equals?: $Enums.Modalidad | EnumModalidadFieldRefInput<$PrismaModel>
    in?: $Enums.Modalidad[] | ListEnumModalidadFieldRefInput<$PrismaModel>
    notIn?: $Enums.Modalidad[] | ListEnumModalidadFieldRefInput<$PrismaModel>
    not?: NestedEnumModalidadFilter<$PrismaModel> | $Enums.Modalidad
  }

  export type NestedEnumEstadoEstudianteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEstudiante | EnumEstadoEstudianteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEstudiante[] | ListEnumEstadoEstudianteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoEstudiante[] | ListEnumEstadoEstudianteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoEstudianteFilter<$PrismaModel> | $Enums.EstadoEstudiante
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumModalidadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Modalidad | EnumModalidadFieldRefInput<$PrismaModel>
    in?: $Enums.Modalidad[] | ListEnumModalidadFieldRefInput<$PrismaModel>
    notIn?: $Enums.Modalidad[] | ListEnumModalidadFieldRefInput<$PrismaModel>
    not?: NestedEnumModalidadWithAggregatesFilter<$PrismaModel> | $Enums.Modalidad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModalidadFilter<$PrismaModel>
    _max?: NestedEnumModalidadFilter<$PrismaModel>
  }

  export type NestedEnumEstadoEstudianteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEstudiante | EnumEstadoEstudianteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEstudiante[] | ListEnumEstadoEstudianteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoEstudiante[] | ListEnumEstadoEstudianteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoEstudianteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoEstudiante
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoEstudianteFilter<$PrismaModel>
    _max?: NestedEnumEstadoEstudianteFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEstadoCitaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoCita | EnumEstadoCitaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoCita[] | ListEnumEstadoCitaFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoCita[] | ListEnumEstadoCitaFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoCitaFilter<$PrismaModel> | $Enums.EstadoCita
  }

  export type NestedEnumEstadoCitaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoCita | EnumEstadoCitaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoCita[] | ListEnumEstadoCitaFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoCita[] | ListEnumEstadoCitaFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoCitaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoCita
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoCitaFilter<$PrismaModel>
    _max?: NestedEnumEstadoCitaFilter<$PrismaModel>
  }

  export type NestedEnumTipoAuditoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoAuditoria | EnumTipoAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoAuditoria[] | ListEnumTipoAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoAuditoria[] | ListEnumTipoAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoAuditoriaFilter<$PrismaModel> | $Enums.TipoAuditoria
  }

  export type NestedEnumTipoAuditoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoAuditoria | EnumTipoAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoAuditoria[] | ListEnumTipoAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoAuditoria[] | ListEnumTipoAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoAuditoriaWithAggregatesFilter<$PrismaModel> | $Enums.TipoAuditoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoAuditoriaFilter<$PrismaModel>
    _max?: NestedEnumTipoAuditoriaFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.Channel | EnumChannelFieldRefInput<$PrismaModel>
    in?: $Enums.Channel[] | ListEnumChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Channel[] | ListEnumChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelFilter<$PrismaModel> | $Enums.Channel
  }

  export type NestedEnumChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Channel | EnumChannelFieldRefInput<$PrismaModel>
    in?: $Enums.Channel[] | ListEnumChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.Channel[] | ListEnumChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelWithAggregatesFilter<$PrismaModel> | $Enums.Channel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChannelFilter<$PrismaModel>
    _max?: NestedEnumChannelFilter<$PrismaModel>
  }

  export type NestedEnumConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusFilter<$PrismaModel> | $Enums.ConversationStatus
  }

  export type NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumConversationStatusFilter<$PrismaModel>
  }

  export type NestedEnumDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionFilter<$PrismaModel> | $Enums.Direction
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Direction | EnumDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Direction[] | ListEnumDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectionWithAggregatesFilter<$PrismaModel> | $Enums.Direction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectionFilter<$PrismaModel>
    _max?: NestedEnumDirectionFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type IntentoLoginCreateWithoutUsuarioInput = {
    id?: string
    correo: string
    tipo?: $Enums.TipoIntentoLogin
    exitoso?: boolean
    origen?: $Enums.OrigenIntento
    ip?: string | null
    userAgent?: string | null
    motivoFallo?: string | null
    creadoEn?: Date | string
  }

  export type IntentoLoginUncheckedCreateWithoutUsuarioInput = {
    id?: string
    correo: string
    tipo?: $Enums.TipoIntentoLogin
    exitoso?: boolean
    origen?: $Enums.OrigenIntento
    ip?: string | null
    userAgent?: string | null
    motivoFallo?: string | null
    creadoEn?: Date | string
  }

  export type IntentoLoginCreateOrConnectWithoutUsuarioInput = {
    where: IntentoLoginWhereUniqueInput
    create: XOR<IntentoLoginCreateWithoutUsuarioInput, IntentoLoginUncheckedCreateWithoutUsuarioInput>
  }

  export type IntentoLoginCreateManyUsuarioInputEnvelope = {
    data: IntentoLoginCreateManyUsuarioInput | IntentoLoginCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type SesionCreateWithoutUsuarioInput = {
    id?: string
    token: string
    ip?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    ultimoAcceso?: Date | string
    activa?: boolean
    creadaEn?: Date | string
  }

  export type SesionUncheckedCreateWithoutUsuarioInput = {
    id?: string
    token: string
    ip?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    ultimoAcceso?: Date | string
    activa?: boolean
    creadaEn?: Date | string
  }

  export type SesionCreateOrConnectWithoutUsuarioInput = {
    where: SesionWhereUniqueInput
    create: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput>
  }

  export type SesionCreateManyUsuarioInputEnvelope = {
    data: SesionCreateManyUsuarioInput | SesionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type IntentoLoginUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: IntentoLoginWhereUniqueInput
    update: XOR<IntentoLoginUpdateWithoutUsuarioInput, IntentoLoginUncheckedUpdateWithoutUsuarioInput>
    create: XOR<IntentoLoginCreateWithoutUsuarioInput, IntentoLoginUncheckedCreateWithoutUsuarioInput>
  }

  export type IntentoLoginUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: IntentoLoginWhereUniqueInput
    data: XOR<IntentoLoginUpdateWithoutUsuarioInput, IntentoLoginUncheckedUpdateWithoutUsuarioInput>
  }

  export type IntentoLoginUpdateManyWithWhereWithoutUsuarioInput = {
    where: IntentoLoginScalarWhereInput
    data: XOR<IntentoLoginUpdateManyMutationInput, IntentoLoginUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type IntentoLoginScalarWhereInput = {
    AND?: IntentoLoginScalarWhereInput | IntentoLoginScalarWhereInput[]
    OR?: IntentoLoginScalarWhereInput[]
    NOT?: IntentoLoginScalarWhereInput | IntentoLoginScalarWhereInput[]
    id?: StringFilter<"IntentoLogin"> | string
    usuarioId?: StringNullableFilter<"IntentoLogin"> | string | null
    correo?: StringFilter<"IntentoLogin"> | string
    tipo?: EnumTipoIntentoLoginFilter<"IntentoLogin"> | $Enums.TipoIntentoLogin
    exitoso?: BoolFilter<"IntentoLogin"> | boolean
    origen?: EnumOrigenIntentoFilter<"IntentoLogin"> | $Enums.OrigenIntento
    ip?: StringNullableFilter<"IntentoLogin"> | string | null
    userAgent?: StringNullableFilter<"IntentoLogin"> | string | null
    motivoFallo?: StringNullableFilter<"IntentoLogin"> | string | null
    creadoEn?: DateTimeFilter<"IntentoLogin"> | Date | string
  }

  export type SesionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: SesionWhereUniqueInput
    update: XOR<SesionUpdateWithoutUsuarioInput, SesionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput>
  }

  export type SesionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: SesionWhereUniqueInput
    data: XOR<SesionUpdateWithoutUsuarioInput, SesionUncheckedUpdateWithoutUsuarioInput>
  }

  export type SesionUpdateManyWithWhereWithoutUsuarioInput = {
    where: SesionScalarWhereInput
    data: XOR<SesionUpdateManyMutationInput, SesionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type SesionScalarWhereInput = {
    AND?: SesionScalarWhereInput | SesionScalarWhereInput[]
    OR?: SesionScalarWhereInput[]
    NOT?: SesionScalarWhereInput | SesionScalarWhereInput[]
    id?: StringFilter<"Sesion"> | string
    usuarioId?: StringFilter<"Sesion"> | string
    token?: StringFilter<"Sesion"> | string
    ip?: StringNullableFilter<"Sesion"> | string | null
    userAgent?: StringNullableFilter<"Sesion"> | string | null
    expiresAt?: DateTimeFilter<"Sesion"> | Date | string
    ultimoAcceso?: DateTimeFilter<"Sesion"> | Date | string
    activa?: BoolFilter<"Sesion"> | boolean
    creadaEn?: DateTimeFilter<"Sesion"> | Date | string
  }

  export type UsuarioCreateWithoutIntentosLoginInput = {
    id?: string
    nombreCompleto: string
    correo: string
    telefono?: string | null
    passwordHash: string
    primerIngreso?: boolean
    rol?: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutIntentosLoginInput = {
    id?: string
    nombreCompleto: string
    correo: string
    telefono?: string | null
    passwordHash: string
    primerIngreso?: boolean
    rol?: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutIntentosLoginInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutIntentosLoginInput, UsuarioUncheckedCreateWithoutIntentosLoginInput>
  }

  export type UsuarioUpsertWithoutIntentosLoginInput = {
    update: XOR<UsuarioUpdateWithoutIntentosLoginInput, UsuarioUncheckedUpdateWithoutIntentosLoginInput>
    create: XOR<UsuarioCreateWithoutIntentosLoginInput, UsuarioUncheckedCreateWithoutIntentosLoginInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutIntentosLoginInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutIntentosLoginInput, UsuarioUncheckedUpdateWithoutIntentosLoginInput>
  }

  export type UsuarioUpdateWithoutIntentosLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    primerIngreso?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutIntentosLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    primerIngreso?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutSesionesInput = {
    id?: string
    nombreCompleto: string
    correo: string
    telefono?: string | null
    passwordHash: string
    primerIngreso?: boolean
    rol?: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    intentosLogin?: IntentoLoginCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutSesionesInput = {
    id?: string
    nombreCompleto: string
    correo: string
    telefono?: string | null
    passwordHash: string
    primerIngreso?: boolean
    rol?: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    intentosLogin?: IntentoLoginUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutSesionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutSesionesInput, UsuarioUncheckedCreateWithoutSesionesInput>
  }

  export type UsuarioUpsertWithoutSesionesInput = {
    update: XOR<UsuarioUpdateWithoutSesionesInput, UsuarioUncheckedUpdateWithoutSesionesInput>
    create: XOR<UsuarioCreateWithoutSesionesInput, UsuarioUncheckedCreateWithoutSesionesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutSesionesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutSesionesInput, UsuarioUncheckedUpdateWithoutSesionesInput>
  }

  export type UsuarioUpdateWithoutSesionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    primerIngreso?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentosLogin?: IntentoLoginUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutSesionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    primerIngreso?: BoolFieldUpdateOperationsInput | boolean
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentosLogin?: IntentoLoginUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CitaCreateWithoutEstudianteInput = {
    id?: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    conversacion?: ConversacionCreateNestedOneWithoutCitasInput
  }

  export type CitaUncheckedCreateWithoutEstudianteInput = {
    id?: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    conversacionId?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type CitaCreateOrConnectWithoutEstudianteInput = {
    where: CitaWhereUniqueInput
    create: XOR<CitaCreateWithoutEstudianteInput, CitaUncheckedCreateWithoutEstudianteInput>
  }

  export type CitaCreateManyEstudianteInputEnvelope = {
    data: CitaCreateManyEstudianteInput | CitaCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type ConversacionCreateWithoutEstudianteInput = {
    id?: string
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    citas?: CitaCreateNestedManyWithoutConversacionInput
    mensajes?: MensajeCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoCreateNestedOneWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionUncheckedCreateWithoutEstudianteInput = {
    id?: string
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutConversacionInput
    mensajes?: MensajeUncheckedCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedOneWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionUncheckedCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionCreateOrConnectWithoutEstudianteInput = {
    where: ConversacionWhereUniqueInput
    create: XOR<ConversacionCreateWithoutEstudianteInput, ConversacionUncheckedCreateWithoutEstudianteInput>
  }

  export type ConversacionCreateManyEstudianteInputEnvelope = {
    data: ConversacionCreateManyEstudianteInput | ConversacionCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type EncuestaSatisfaccionCreateWithoutEstudianteInput = {
    id?: string
    calificacion: number
    comentario?: string | null
    respondida?: boolean
    fuente?: string
    createdAt?: Date | string
    conversacion?: ConversacionCreateNestedOneWithoutEncuestaInput
  }

  export type EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput = {
    id?: string
    conversacionId?: string | null
    calificacion: number
    comentario?: string | null
    respondida?: boolean
    fuente?: string
    createdAt?: Date | string
  }

  export type EncuestaSatisfaccionCreateOrConnectWithoutEstudianteInput = {
    where: EncuestaSatisfaccionWhereUniqueInput
    create: XOR<EncuestaSatisfaccionCreateWithoutEstudianteInput, EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput>
  }

  export type EncuestaSatisfaccionCreateManyEstudianteInputEnvelope = {
    data: EncuestaSatisfaccionCreateManyEstudianteInput | EncuestaSatisfaccionCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type AsesoramientoCreateWithoutEstudianteInput = {
    id?: string
    temaLegal: string
    resumen?: string | null
    duracionMinutos?: number | null
    createdAt?: Date | string
    conversacion: ConversacionCreateNestedOneWithoutAsesoramientoInput
  }

  export type AsesoramientoUncheckedCreateWithoutEstudianteInput = {
    id?: string
    conversacionId: string
    temaLegal: string
    resumen?: string | null
    duracionMinutos?: number | null
    createdAt?: Date | string
  }

  export type AsesoramientoCreateOrConnectWithoutEstudianteInput = {
    where: AsesoramientoWhereUniqueInput
    create: XOR<AsesoramientoCreateWithoutEstudianteInput, AsesoramientoUncheckedCreateWithoutEstudianteInput>
  }

  export type AsesoramientoCreateManyEstudianteInputEnvelope = {
    data: AsesoramientoCreateManyEstudianteInput | AsesoramientoCreateManyEstudianteInput[]
    skipDuplicates?: boolean
  }

  export type CitaUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: CitaWhereUniqueInput
    update: XOR<CitaUpdateWithoutEstudianteInput, CitaUncheckedUpdateWithoutEstudianteInput>
    create: XOR<CitaCreateWithoutEstudianteInput, CitaUncheckedCreateWithoutEstudianteInput>
  }

  export type CitaUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: CitaWhereUniqueInput
    data: XOR<CitaUpdateWithoutEstudianteInput, CitaUncheckedUpdateWithoutEstudianteInput>
  }

  export type CitaUpdateManyWithWhereWithoutEstudianteInput = {
    where: CitaScalarWhereInput
    data: XOR<CitaUpdateManyMutationInput, CitaUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type CitaScalarWhereInput = {
    AND?: CitaScalarWhereInput | CitaScalarWhereInput[]
    OR?: CitaScalarWhereInput[]
    NOT?: CitaScalarWhereInput | CitaScalarWhereInput[]
    id?: StringFilter<"Cita"> | string
    estudianteId?: StringFilter<"Cita"> | string
    fecha?: DateTimeFilter<"Cita"> | Date | string
    hora?: StringFilter<"Cita"> | string
    modalidad?: EnumModalidadFilter<"Cita"> | $Enums.Modalidad
    motivo?: StringNullableFilter<"Cita"> | string | null
    estado?: EnumEstadoCitaFilter<"Cita"> | $Enums.EstadoCita
    usuarioNombre?: StringNullableFilter<"Cita"> | string | null
    usuarioTipoDocumento?: StringNullableFilter<"Cita"> | string | null
    usuarioNumeroDocumento?: StringNullableFilter<"Cita"> | string | null
    usuarioCorreo?: StringNullableFilter<"Cita"> | string | null
    usuarioTelefono?: StringNullableFilter<"Cita"> | string | null
    enlaceReunion?: StringNullableFilter<"Cita"> | string | null
    conversacionId?: StringNullableFilter<"Cita"> | string | null
    notifEnviada24h?: BoolFilter<"Cita"> | boolean
    notifEnviada15m?: BoolFilter<"Cita"> | boolean
    creadoEn?: DateTimeFilter<"Cita"> | Date | string
    actualizadoEn?: DateTimeFilter<"Cita"> | Date | string
  }

  export type ConversacionUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: ConversacionWhereUniqueInput
    update: XOR<ConversacionUpdateWithoutEstudianteInput, ConversacionUncheckedUpdateWithoutEstudianteInput>
    create: XOR<ConversacionCreateWithoutEstudianteInput, ConversacionUncheckedCreateWithoutEstudianteInput>
  }

  export type ConversacionUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: ConversacionWhereUniqueInput
    data: XOR<ConversacionUpdateWithoutEstudianteInput, ConversacionUncheckedUpdateWithoutEstudianteInput>
  }

  export type ConversacionUpdateManyWithWhereWithoutEstudianteInput = {
    where: ConversacionScalarWhereInput
    data: XOR<ConversacionUpdateManyMutationInput, ConversacionUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type ConversacionScalarWhereInput = {
    AND?: ConversacionScalarWhereInput | ConversacionScalarWhereInput[]
    OR?: ConversacionScalarWhereInput[]
    NOT?: ConversacionScalarWhereInput | ConversacionScalarWhereInput[]
    id?: StringFilter<"Conversacion"> | string
    estudianteId?: StringNullableFilter<"Conversacion"> | string | null
    temaLegal?: StringFilter<"Conversacion"> | string
    consultorio?: StringNullableFilter<"Conversacion"> | string | null
    estado?: StringFilter<"Conversacion"> | string
    canal?: StringFilter<"Conversacion"> | string
    primerMensaje?: StringNullableFilter<"Conversacion"> | string | null
    resumen?: StringNullableFilter<"Conversacion"> | string | null
    createdAt?: DateTimeFilter<"Conversacion"> | Date | string
  }

  export type EncuestaSatisfaccionUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: EncuestaSatisfaccionWhereUniqueInput
    update: XOR<EncuestaSatisfaccionUpdateWithoutEstudianteInput, EncuestaSatisfaccionUncheckedUpdateWithoutEstudianteInput>
    create: XOR<EncuestaSatisfaccionCreateWithoutEstudianteInput, EncuestaSatisfaccionUncheckedCreateWithoutEstudianteInput>
  }

  export type EncuestaSatisfaccionUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: EncuestaSatisfaccionWhereUniqueInput
    data: XOR<EncuestaSatisfaccionUpdateWithoutEstudianteInput, EncuestaSatisfaccionUncheckedUpdateWithoutEstudianteInput>
  }

  export type EncuestaSatisfaccionUpdateManyWithWhereWithoutEstudianteInput = {
    where: EncuestaSatisfaccionScalarWhereInput
    data: XOR<EncuestaSatisfaccionUpdateManyMutationInput, EncuestaSatisfaccionUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type EncuestaSatisfaccionScalarWhereInput = {
    AND?: EncuestaSatisfaccionScalarWhereInput | EncuestaSatisfaccionScalarWhereInput[]
    OR?: EncuestaSatisfaccionScalarWhereInput[]
    NOT?: EncuestaSatisfaccionScalarWhereInput | EncuestaSatisfaccionScalarWhereInput[]
    id?: StringFilter<"EncuestaSatisfaccion"> | string
    conversacionId?: StringNullableFilter<"EncuestaSatisfaccion"> | string | null
    estudianteId?: StringNullableFilter<"EncuestaSatisfaccion"> | string | null
    calificacion?: IntFilter<"EncuestaSatisfaccion"> | number
    comentario?: StringNullableFilter<"EncuestaSatisfaccion"> | string | null
    respondida?: BoolFilter<"EncuestaSatisfaccion"> | boolean
    fuente?: StringFilter<"EncuestaSatisfaccion"> | string
    createdAt?: DateTimeFilter<"EncuestaSatisfaccion"> | Date | string
  }

  export type AsesoramientoUpsertWithWhereUniqueWithoutEstudianteInput = {
    where: AsesoramientoWhereUniqueInput
    update: XOR<AsesoramientoUpdateWithoutEstudianteInput, AsesoramientoUncheckedUpdateWithoutEstudianteInput>
    create: XOR<AsesoramientoCreateWithoutEstudianteInput, AsesoramientoUncheckedCreateWithoutEstudianteInput>
  }

  export type AsesoramientoUpdateWithWhereUniqueWithoutEstudianteInput = {
    where: AsesoramientoWhereUniqueInput
    data: XOR<AsesoramientoUpdateWithoutEstudianteInput, AsesoramientoUncheckedUpdateWithoutEstudianteInput>
  }

  export type AsesoramientoUpdateManyWithWhereWithoutEstudianteInput = {
    where: AsesoramientoScalarWhereInput
    data: XOR<AsesoramientoUpdateManyMutationInput, AsesoramientoUncheckedUpdateManyWithoutEstudianteInput>
  }

  export type AsesoramientoScalarWhereInput = {
    AND?: AsesoramientoScalarWhereInput | AsesoramientoScalarWhereInput[]
    OR?: AsesoramientoScalarWhereInput[]
    NOT?: AsesoramientoScalarWhereInput | AsesoramientoScalarWhereInput[]
    id?: StringFilter<"Asesoramiento"> | string
    conversacionId?: StringFilter<"Asesoramiento"> | string
    estudianteId?: StringNullableFilter<"Asesoramiento"> | string | null
    temaLegal?: StringFilter<"Asesoramiento"> | string
    resumen?: StringNullableFilter<"Asesoramiento"> | string | null
    duracionMinutos?: IntNullableFilter<"Asesoramiento"> | number | null
    createdAt?: DateTimeFilter<"Asesoramiento"> | Date | string
  }

  export type EstudianteCreateWithoutCitasInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    conversaciones?: ConversacionCreateNestedManyWithoutEstudianteInput
    encuestas?: EncuestaSatisfaccionCreateNestedManyWithoutEstudianteInput
    asesoramiento?: AsesoramientoCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutCitasInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    conversaciones?: ConversacionUncheckedCreateNestedManyWithoutEstudianteInput
    encuestas?: EncuestaSatisfaccionUncheckedCreateNestedManyWithoutEstudianteInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutCitasInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutCitasInput, EstudianteUncheckedCreateWithoutCitasInput>
  }

  export type ConversacionCreateWithoutCitasInput = {
    id?: string
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutConversacionesInput
    mensajes?: MensajeCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoCreateNestedOneWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionUncheckedCreateWithoutCitasInput = {
    id?: string
    estudianteId?: string | null
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    mensajes?: MensajeUncheckedCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedOneWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionUncheckedCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionCreateOrConnectWithoutCitasInput = {
    where: ConversacionWhereUniqueInput
    create: XOR<ConversacionCreateWithoutCitasInput, ConversacionUncheckedCreateWithoutCitasInput>
  }

  export type EstudianteUpsertWithoutCitasInput = {
    update: XOR<EstudianteUpdateWithoutCitasInput, EstudianteUncheckedUpdateWithoutCitasInput>
    create: XOR<EstudianteCreateWithoutCitasInput, EstudianteUncheckedCreateWithoutCitasInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutCitasInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutCitasInput, EstudianteUncheckedUpdateWithoutCitasInput>
  }

  export type EstudianteUpdateWithoutCitasInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    conversaciones?: ConversacionUpdateManyWithoutEstudianteNestedInput
    encuestas?: EncuestaSatisfaccionUpdateManyWithoutEstudianteNestedInput
    asesoramiento?: AsesoramientoUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutCitasInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    conversaciones?: ConversacionUncheckedUpdateManyWithoutEstudianteNestedInput
    encuestas?: EncuestaSatisfaccionUncheckedUpdateManyWithoutEstudianteNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type ConversacionUpsertWithoutCitasInput = {
    update: XOR<ConversacionUpdateWithoutCitasInput, ConversacionUncheckedUpdateWithoutCitasInput>
    create: XOR<ConversacionCreateWithoutCitasInput, ConversacionUncheckedCreateWithoutCitasInput>
    where?: ConversacionWhereInput
  }

  export type ConversacionUpdateToOneWithWhereWithoutCitasInput = {
    where?: ConversacionWhereInput
    data: XOR<ConversacionUpdateWithoutCitasInput, ConversacionUncheckedUpdateWithoutCitasInput>
  }

  export type ConversacionUpdateWithoutCitasInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutConversacionesNestedInput
    mensajes?: MensajeUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUpdateOneWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionUncheckedUpdateWithoutCitasInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mensajes?: MensajeUncheckedUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateOneWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUncheckedUpdateOneWithoutConversacionNestedInput
  }

  export type EstudianteCreateWithoutConversacionesInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    citas?: CitaCreateNestedManyWithoutEstudianteInput
    encuestas?: EncuestaSatisfaccionCreateNestedManyWithoutEstudianteInput
    asesoramiento?: AsesoramientoCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutConversacionesInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutEstudianteInput
    encuestas?: EncuestaSatisfaccionUncheckedCreateNestedManyWithoutEstudianteInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutConversacionesInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutConversacionesInput, EstudianteUncheckedCreateWithoutConversacionesInput>
  }

  export type CitaCreateWithoutConversacionInput = {
    id?: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    estudiante: EstudianteCreateNestedOneWithoutCitasInput
  }

  export type CitaUncheckedCreateWithoutConversacionInput = {
    id?: string
    estudianteId: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type CitaCreateOrConnectWithoutConversacionInput = {
    where: CitaWhereUniqueInput
    create: XOR<CitaCreateWithoutConversacionInput, CitaUncheckedCreateWithoutConversacionInput>
  }

  export type CitaCreateManyConversacionInputEnvelope = {
    data: CitaCreateManyConversacionInput | CitaCreateManyConversacionInput[]
    skipDuplicates?: boolean
  }

  export type MensajeCreateWithoutConversacionInput = {
    id?: string
    tipo: string
    contenido: string
    createdAt?: Date | string
  }

  export type MensajeUncheckedCreateWithoutConversacionInput = {
    id?: string
    tipo: string
    contenido: string
    createdAt?: Date | string
  }

  export type MensajeCreateOrConnectWithoutConversacionInput = {
    where: MensajeWhereUniqueInput
    create: XOR<MensajeCreateWithoutConversacionInput, MensajeUncheckedCreateWithoutConversacionInput>
  }

  export type MensajeCreateManyConversacionInputEnvelope = {
    data: MensajeCreateManyConversacionInput | MensajeCreateManyConversacionInput[]
    skipDuplicates?: boolean
  }

  export type AsesoramientoCreateWithoutConversacionInput = {
    id?: string
    temaLegal: string
    resumen?: string | null
    duracionMinutos?: number | null
    createdAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutAsesoramientoInput
  }

  export type AsesoramientoUncheckedCreateWithoutConversacionInput = {
    id?: string
    estudianteId?: string | null
    temaLegal: string
    resumen?: string | null
    duracionMinutos?: number | null
    createdAt?: Date | string
  }

  export type AsesoramientoCreateOrConnectWithoutConversacionInput = {
    where: AsesoramientoWhereUniqueInput
    create: XOR<AsesoramientoCreateWithoutConversacionInput, AsesoramientoUncheckedCreateWithoutConversacionInput>
  }

  export type EncuestaSatisfaccionCreateWithoutConversacionInput = {
    id?: string
    calificacion: number
    comentario?: string | null
    respondida?: boolean
    fuente?: string
    createdAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutEncuestasInput
  }

  export type EncuestaSatisfaccionUncheckedCreateWithoutConversacionInput = {
    id?: string
    estudianteId?: string | null
    calificacion: number
    comentario?: string | null
    respondida?: boolean
    fuente?: string
    createdAt?: Date | string
  }

  export type EncuestaSatisfaccionCreateOrConnectWithoutConversacionInput = {
    where: EncuestaSatisfaccionWhereUniqueInput
    create: XOR<EncuestaSatisfaccionCreateWithoutConversacionInput, EncuestaSatisfaccionUncheckedCreateWithoutConversacionInput>
  }

  export type EstudianteUpsertWithoutConversacionesInput = {
    update: XOR<EstudianteUpdateWithoutConversacionesInput, EstudianteUncheckedUpdateWithoutConversacionesInput>
    create: XOR<EstudianteCreateWithoutConversacionesInput, EstudianteUncheckedCreateWithoutConversacionesInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutConversacionesInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutConversacionesInput, EstudianteUncheckedUpdateWithoutConversacionesInput>
  }

  export type EstudianteUpdateWithoutConversacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUpdateManyWithoutEstudianteNestedInput
    encuestas?: EncuestaSatisfaccionUpdateManyWithoutEstudianteNestedInput
    asesoramiento?: AsesoramientoUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutConversacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutEstudianteNestedInput
    encuestas?: EncuestaSatisfaccionUncheckedUpdateManyWithoutEstudianteNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type CitaUpsertWithWhereUniqueWithoutConversacionInput = {
    where: CitaWhereUniqueInput
    update: XOR<CitaUpdateWithoutConversacionInput, CitaUncheckedUpdateWithoutConversacionInput>
    create: XOR<CitaCreateWithoutConversacionInput, CitaUncheckedCreateWithoutConversacionInput>
  }

  export type CitaUpdateWithWhereUniqueWithoutConversacionInput = {
    where: CitaWhereUniqueInput
    data: XOR<CitaUpdateWithoutConversacionInput, CitaUncheckedUpdateWithoutConversacionInput>
  }

  export type CitaUpdateManyWithWhereWithoutConversacionInput = {
    where: CitaScalarWhereInput
    data: XOR<CitaUpdateManyMutationInput, CitaUncheckedUpdateManyWithoutConversacionInput>
  }

  export type MensajeUpsertWithWhereUniqueWithoutConversacionInput = {
    where: MensajeWhereUniqueInput
    update: XOR<MensajeUpdateWithoutConversacionInput, MensajeUncheckedUpdateWithoutConversacionInput>
    create: XOR<MensajeCreateWithoutConversacionInput, MensajeUncheckedCreateWithoutConversacionInput>
  }

  export type MensajeUpdateWithWhereUniqueWithoutConversacionInput = {
    where: MensajeWhereUniqueInput
    data: XOR<MensajeUpdateWithoutConversacionInput, MensajeUncheckedUpdateWithoutConversacionInput>
  }

  export type MensajeUpdateManyWithWhereWithoutConversacionInput = {
    where: MensajeScalarWhereInput
    data: XOR<MensajeUpdateManyMutationInput, MensajeUncheckedUpdateManyWithoutConversacionInput>
  }

  export type MensajeScalarWhereInput = {
    AND?: MensajeScalarWhereInput | MensajeScalarWhereInput[]
    OR?: MensajeScalarWhereInput[]
    NOT?: MensajeScalarWhereInput | MensajeScalarWhereInput[]
    id?: StringFilter<"Mensaje"> | string
    conversacionId?: StringFilter<"Mensaje"> | string
    tipo?: StringFilter<"Mensaje"> | string
    contenido?: StringFilter<"Mensaje"> | string
    createdAt?: DateTimeFilter<"Mensaje"> | Date | string
  }

  export type AsesoramientoUpsertWithoutConversacionInput = {
    update: XOR<AsesoramientoUpdateWithoutConversacionInput, AsesoramientoUncheckedUpdateWithoutConversacionInput>
    create: XOR<AsesoramientoCreateWithoutConversacionInput, AsesoramientoUncheckedCreateWithoutConversacionInput>
    where?: AsesoramientoWhereInput
  }

  export type AsesoramientoUpdateToOneWithWhereWithoutConversacionInput = {
    where?: AsesoramientoWhereInput
    data: XOR<AsesoramientoUpdateWithoutConversacionInput, AsesoramientoUncheckedUpdateWithoutConversacionInput>
  }

  export type AsesoramientoUpdateWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutAsesoramientoNestedInput
  }

  export type AsesoramientoUncheckedUpdateWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncuestaSatisfaccionUpsertWithoutConversacionInput = {
    update: XOR<EncuestaSatisfaccionUpdateWithoutConversacionInput, EncuestaSatisfaccionUncheckedUpdateWithoutConversacionInput>
    create: XOR<EncuestaSatisfaccionCreateWithoutConversacionInput, EncuestaSatisfaccionUncheckedCreateWithoutConversacionInput>
    where?: EncuestaSatisfaccionWhereInput
  }

  export type EncuestaSatisfaccionUpdateToOneWithWhereWithoutConversacionInput = {
    where?: EncuestaSatisfaccionWhereInput
    data: XOR<EncuestaSatisfaccionUpdateWithoutConversacionInput, EncuestaSatisfaccionUncheckedUpdateWithoutConversacionInput>
  }

  export type EncuestaSatisfaccionUpdateWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutEncuestasNestedInput
  }

  export type EncuestaSatisfaccionUncheckedUpdateWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversacionCreateWithoutMensajesInput = {
    id?: string
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutConversacionesInput
    citas?: CitaCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoCreateNestedOneWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionUncheckedCreateWithoutMensajesInput = {
    id?: string
    estudianteId?: string | null
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedOneWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionUncheckedCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionCreateOrConnectWithoutMensajesInput = {
    where: ConversacionWhereUniqueInput
    create: XOR<ConversacionCreateWithoutMensajesInput, ConversacionUncheckedCreateWithoutMensajesInput>
  }

  export type ConversacionUpsertWithoutMensajesInput = {
    update: XOR<ConversacionUpdateWithoutMensajesInput, ConversacionUncheckedUpdateWithoutMensajesInput>
    create: XOR<ConversacionCreateWithoutMensajesInput, ConversacionUncheckedCreateWithoutMensajesInput>
    where?: ConversacionWhereInput
  }

  export type ConversacionUpdateToOneWithWhereWithoutMensajesInput = {
    where?: ConversacionWhereInput
    data: XOR<ConversacionUpdateWithoutMensajesInput, ConversacionUncheckedUpdateWithoutMensajesInput>
  }

  export type ConversacionUpdateWithoutMensajesInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutConversacionesNestedInput
    citas?: CitaUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUpdateOneWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionUncheckedUpdateWithoutMensajesInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateOneWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUncheckedUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionCreateWithoutAsesoramientoInput = {
    id?: string
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutConversacionesInput
    citas?: CitaCreateNestedManyWithoutConversacionInput
    mensajes?: MensajeCreateNestedManyWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionUncheckedCreateWithoutAsesoramientoInput = {
    id?: string
    estudianteId?: string | null
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutConversacionInput
    mensajes?: MensajeUncheckedCreateNestedManyWithoutConversacionInput
    encuesta?: EncuestaSatisfaccionUncheckedCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionCreateOrConnectWithoutAsesoramientoInput = {
    where: ConversacionWhereUniqueInput
    create: XOR<ConversacionCreateWithoutAsesoramientoInput, ConversacionUncheckedCreateWithoutAsesoramientoInput>
  }

  export type EstudianteCreateWithoutAsesoramientoInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    citas?: CitaCreateNestedManyWithoutEstudianteInput
    conversaciones?: ConversacionCreateNestedManyWithoutEstudianteInput
    encuestas?: EncuestaSatisfaccionCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutAsesoramientoInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutEstudianteInput
    conversaciones?: ConversacionUncheckedCreateNestedManyWithoutEstudianteInput
    encuestas?: EncuestaSatisfaccionUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutAsesoramientoInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutAsesoramientoInput, EstudianteUncheckedCreateWithoutAsesoramientoInput>
  }

  export type ConversacionUpsertWithoutAsesoramientoInput = {
    update: XOR<ConversacionUpdateWithoutAsesoramientoInput, ConversacionUncheckedUpdateWithoutAsesoramientoInput>
    create: XOR<ConversacionCreateWithoutAsesoramientoInput, ConversacionUncheckedCreateWithoutAsesoramientoInput>
    where?: ConversacionWhereInput
  }

  export type ConversacionUpdateToOneWithWhereWithoutAsesoramientoInput = {
    where?: ConversacionWhereInput
    data: XOR<ConversacionUpdateWithoutAsesoramientoInput, ConversacionUncheckedUpdateWithoutAsesoramientoInput>
  }

  export type ConversacionUpdateWithoutAsesoramientoInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutConversacionesNestedInput
    citas?: CitaUpdateManyWithoutConversacionNestedInput
    mensajes?: MensajeUpdateManyWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionUncheckedUpdateWithoutAsesoramientoInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutConversacionNestedInput
    mensajes?: MensajeUncheckedUpdateManyWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUncheckedUpdateOneWithoutConversacionNestedInput
  }

  export type EstudianteUpsertWithoutAsesoramientoInput = {
    update: XOR<EstudianteUpdateWithoutAsesoramientoInput, EstudianteUncheckedUpdateWithoutAsesoramientoInput>
    create: XOR<EstudianteCreateWithoutAsesoramientoInput, EstudianteUncheckedCreateWithoutAsesoramientoInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutAsesoramientoInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutAsesoramientoInput, EstudianteUncheckedUpdateWithoutAsesoramientoInput>
  }

  export type EstudianteUpdateWithoutAsesoramientoInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUpdateManyWithoutEstudianteNestedInput
    conversaciones?: ConversacionUpdateManyWithoutEstudianteNestedInput
    encuestas?: EncuestaSatisfaccionUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutAsesoramientoInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutEstudianteNestedInput
    conversaciones?: ConversacionUncheckedUpdateManyWithoutEstudianteNestedInput
    encuestas?: EncuestaSatisfaccionUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type ConversacionCreateWithoutEncuestaInput = {
    id?: string
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    estudiante?: EstudianteCreateNestedOneWithoutConversacionesInput
    citas?: CitaCreateNestedManyWithoutConversacionInput
    mensajes?: MensajeCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionUncheckedCreateWithoutEncuestaInput = {
    id?: string
    estudianteId?: string | null
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutConversacionInput
    mensajes?: MensajeUncheckedCreateNestedManyWithoutConversacionInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedOneWithoutConversacionInput
  }

  export type ConversacionCreateOrConnectWithoutEncuestaInput = {
    where: ConversacionWhereUniqueInput
    create: XOR<ConversacionCreateWithoutEncuestaInput, ConversacionUncheckedCreateWithoutEncuestaInput>
  }

  export type EstudianteCreateWithoutEncuestasInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    citas?: CitaCreateNestedManyWithoutEstudianteInput
    conversaciones?: ConversacionCreateNestedManyWithoutEstudianteInput
    asesoramiento?: AsesoramientoCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteUncheckedCreateWithoutEncuestasInput = {
    id?: string
    documento: string
    nombre: string
    correo?: string | null
    telefono?: string | null
    programa?: string | null
    semestre?: number | null
    modalidad?: $Enums.Modalidad
    estado?: $Enums.EstadoEstudiante
    estadoCuenta?: string
    accesoCitas?: boolean
    acudimientos?: boolean
    fechaInicio?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    citas?: CitaUncheckedCreateNestedManyWithoutEstudianteInput
    conversaciones?: ConversacionUncheckedCreateNestedManyWithoutEstudianteInput
    asesoramiento?: AsesoramientoUncheckedCreateNestedManyWithoutEstudianteInput
  }

  export type EstudianteCreateOrConnectWithoutEncuestasInput = {
    where: EstudianteWhereUniqueInput
    create: XOR<EstudianteCreateWithoutEncuestasInput, EstudianteUncheckedCreateWithoutEncuestasInput>
  }

  export type ConversacionUpsertWithoutEncuestaInput = {
    update: XOR<ConversacionUpdateWithoutEncuestaInput, ConversacionUncheckedUpdateWithoutEncuestaInput>
    create: XOR<ConversacionCreateWithoutEncuestaInput, ConversacionUncheckedCreateWithoutEncuestaInput>
    where?: ConversacionWhereInput
  }

  export type ConversacionUpdateToOneWithWhereWithoutEncuestaInput = {
    where?: ConversacionWhereInput
    data: XOR<ConversacionUpdateWithoutEncuestaInput, ConversacionUncheckedUpdateWithoutEncuestaInput>
  }

  export type ConversacionUpdateWithoutEncuestaInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneWithoutConversacionesNestedInput
    citas?: CitaUpdateManyWithoutConversacionNestedInput
    mensajes?: MensajeUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionUncheckedUpdateWithoutEncuestaInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutConversacionNestedInput
    mensajes?: MensajeUncheckedUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateOneWithoutConversacionNestedInput
  }

  export type EstudianteUpsertWithoutEncuestasInput = {
    update: XOR<EstudianteUpdateWithoutEncuestasInput, EstudianteUncheckedUpdateWithoutEncuestasInput>
    create: XOR<EstudianteCreateWithoutEncuestasInput, EstudianteUncheckedCreateWithoutEncuestasInput>
    where?: EstudianteWhereInput
  }

  export type EstudianteUpdateToOneWithWhereWithoutEncuestasInput = {
    where?: EstudianteWhereInput
    data: XOR<EstudianteUpdateWithoutEncuestasInput, EstudianteUncheckedUpdateWithoutEncuestasInput>
  }

  export type EstudianteUpdateWithoutEncuestasInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUpdateManyWithoutEstudianteNestedInput
    conversaciones?: ConversacionUpdateManyWithoutEstudianteNestedInput
    asesoramiento?: AsesoramientoUpdateManyWithoutEstudianteNestedInput
  }

  export type EstudianteUncheckedUpdateWithoutEncuestasInput = {
    id?: StringFieldUpdateOperationsInput | string
    documento?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    programa?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: NullableIntFieldUpdateOperationsInput | number | null
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    estado?: EnumEstadoEstudianteFieldUpdateOperationsInput | $Enums.EstadoEstudiante
    estadoCuenta?: StringFieldUpdateOperationsInput | string
    accesoCitas?: BoolFieldUpdateOperationsInput | boolean
    acudimientos?: BoolFieldUpdateOperationsInput | boolean
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutEstudianteNestedInput
    conversaciones?: ConversacionUncheckedUpdateManyWithoutEstudianteNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateManyWithoutEstudianteNestedInput
  }

  export type ConversationCreateWithoutContactInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contexts?: ConversationContextCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutContactInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contexts?: ConversationContextUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutContactInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput>
  }

  export type ConversationCreateManyContactInputEnvelope = {
    data: ConversationCreateManyContactInput | ConversationCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutContactInput = {
    id?: string
    tenantId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutContactInput = {
    id?: string
    tenantId: string
    conversationId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutContactInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput>
  }

  export type MessageCreateManyContactInputEnvelope = {
    data: MessageCreateManyContactInput | MessageCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithWhereUniqueWithoutContactInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutContactInput, ConversationUncheckedUpdateWithoutContactInput>
    create: XOR<ConversationCreateWithoutContactInput, ConversationUncheckedCreateWithoutContactInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutContactInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutContactInput, ConversationUncheckedUpdateWithoutContactInput>
  }

  export type ConversationUpdateManyWithWhereWithoutContactInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutContactInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    tenantId?: StringFilter<"Conversation"> | string
    contactId?: StringFilter<"Conversation"> | string
    channel?: EnumChannelFilter<"Conversation"> | $Enums.Channel
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    currentFlowVersionId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutContactInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutContactInput, MessageUncheckedUpdateWithoutContactInput>
    create: XOR<MessageCreateWithoutContactInput, MessageUncheckedCreateWithoutContactInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutContactInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutContactInput, MessageUncheckedUpdateWithoutContactInput>
  }

  export type MessageUpdateManyWithWhereWithoutContactInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutContactInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    tenantId?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    contactId?: StringFilter<"Message"> | string
    direction?: EnumDirectionFilter<"Message"> | $Enums.Direction
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    text?: StringNullableFilter<"Message"> | string | null
    payload?: JsonFilter<"Message">
    providerMessageId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ContactCreateWithoutConversationsInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    externalId: string
    displayName?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutConversationsInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    externalId: string
    displayName?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutConversationsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
  }

  export type ConversationContextCreateWithoutConversationInput = {
    id?: string
    tenantId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationContextUncheckedCreateWithoutConversationInput = {
    id?: string
    tenantId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationContextCreateOrConnectWithoutConversationInput = {
    where: ConversationContextWhereUniqueInput
    create: XOR<ConversationContextCreateWithoutConversationInput, ConversationContextUncheckedCreateWithoutConversationInput>
  }

  export type ConversationContextCreateManyConversationInputEnvelope = {
    data: ConversationContextCreateManyConversationInput | ConversationContextCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    tenantId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
    contact: ContactCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    tenantId: string
    contactId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ContactUpsertWithoutConversationsInput = {
    update: XOR<ContactUpdateWithoutConversationsInput, ContactUncheckedUpdateWithoutConversationsInput>
    create: XOR<ContactCreateWithoutConversationsInput, ContactUncheckedCreateWithoutConversationsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutConversationsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutConversationsInput, ContactUncheckedUpdateWithoutConversationsInput>
  }

  export type ContactUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    externalId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    externalId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ConversationContextUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationContextWhereUniqueInput
    update: XOR<ConversationContextUpdateWithoutConversationInput, ConversationContextUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationContextCreateWithoutConversationInput, ConversationContextUncheckedCreateWithoutConversationInput>
  }

  export type ConversationContextUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationContextWhereUniqueInput
    data: XOR<ConversationContextUpdateWithoutConversationInput, ConversationContextUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationContextUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationContextScalarWhereInput
    data: XOR<ConversationContextUpdateManyMutationInput, ConversationContextUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationContextScalarWhereInput = {
    AND?: ConversationContextScalarWhereInput | ConversationContextScalarWhereInput[]
    OR?: ConversationContextScalarWhereInput[]
    NOT?: ConversationContextScalarWhereInput | ConversationContextScalarWhereInput[]
    id?: StringFilter<"ConversationContext"> | string
    tenantId?: StringFilter<"ConversationContext"> | string
    conversationId?: StringFilter<"ConversationContext"> | string
    version?: IntFilter<"ConversationContext"> | number
    data?: JsonFilter<"ConversationContext">
    createdAt?: DateTimeFilter<"ConversationContext"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ContactCreateWithoutMessagesInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    externalId: string
    displayName?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutMessagesInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    externalId: string
    displayName?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutMessagesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutMessagesInput, ContactUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutConversationsInput
    contexts?: ConversationContextCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    tenantId: string
    contactId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contexts?: ConversationContextUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ContactUpsertWithoutMessagesInput = {
    update: XOR<ContactUpdateWithoutMessagesInput, ContactUncheckedUpdateWithoutMessagesInput>
    create: XOR<ContactCreateWithoutMessagesInput, ContactUncheckedCreateWithoutMessagesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutMessagesInput, ContactUncheckedUpdateWithoutMessagesInput>
  }

  export type ContactUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    externalId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    externalId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutConversationsNestedInput
    contexts?: ConversationContextUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contexts?: ConversationContextUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateWithoutContextsInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutContextsInput = {
    id?: string
    tenantId: string
    contactId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutContextsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutContextsInput, ConversationUncheckedCreateWithoutContextsInput>
  }

  export type ConversationUpsertWithoutContextsInput = {
    update: XOR<ConversationUpdateWithoutContextsInput, ConversationUncheckedUpdateWithoutContextsInput>
    create: XOR<ConversationCreateWithoutContextsInput, ConversationUncheckedCreateWithoutContextsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutContextsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutContextsInput, ConversationUncheckedUpdateWithoutContextsInput>
  }

  export type ConversationUpdateWithoutContextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutContextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type IntentoLoginCreateManyUsuarioInput = {
    id?: string
    correo: string
    tipo?: $Enums.TipoIntentoLogin
    exitoso?: boolean
    origen?: $Enums.OrigenIntento
    ip?: string | null
    userAgent?: string | null
    motivoFallo?: string | null
    creadoEn?: Date | string
  }

  export type SesionCreateManyUsuarioInput = {
    id?: string
    token: string
    ip?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    ultimoAcceso?: Date | string
    activa?: boolean
    creadaEn?: Date | string
  }

  export type IntentoLoginUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoIntentoLoginFieldUpdateOperationsInput | $Enums.TipoIntentoLogin
    exitoso?: BoolFieldUpdateOperationsInput | boolean
    origen?: EnumOrigenIntentoFieldUpdateOperationsInput | $Enums.OrigenIntento
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    motivoFallo?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentoLoginUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoIntentoLoginFieldUpdateOperationsInput | $Enums.TipoIntentoLogin
    exitoso?: BoolFieldUpdateOperationsInput | boolean
    origen?: EnumOrigenIntentoFieldUpdateOperationsInput | $Enums.OrigenIntento
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    motivoFallo?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntentoLoginUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoIntentoLoginFieldUpdateOperationsInput | $Enums.TipoIntentoLogin
    exitoso?: BoolFieldUpdateOperationsInput | boolean
    origen?: EnumOrigenIntentoFieldUpdateOperationsInput | $Enums.OrigenIntento
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    motivoFallo?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimoAcceso?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimoAcceso?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimoAcceso?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitaCreateManyEstudianteInput = {
    id?: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    conversacionId?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ConversacionCreateManyEstudianteInput = {
    id?: string
    temaLegal: string
    consultorio?: string | null
    estado?: string
    canal?: string
    primerMensaje?: string | null
    resumen?: string | null
    createdAt?: Date | string
  }

  export type EncuestaSatisfaccionCreateManyEstudianteInput = {
    id?: string
    conversacionId?: string | null
    calificacion: number
    comentario?: string | null
    respondida?: boolean
    fuente?: string
    createdAt?: Date | string
  }

  export type AsesoramientoCreateManyEstudianteInput = {
    id?: string
    conversacionId: string
    temaLegal: string
    resumen?: string | null
    duracionMinutos?: number | null
    createdAt?: Date | string
  }

  export type CitaUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    conversacion?: ConversacionUpdateOneWithoutCitasNestedInput
  }

  export type CitaUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    conversacionId?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitaUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    conversacionId?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversacionUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUpdateManyWithoutConversacionNestedInput
    mensajes?: MensajeUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUpdateOneWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    citas?: CitaUncheckedUpdateManyWithoutConversacionNestedInput
    mensajes?: MensajeUncheckedUpdateManyWithoutConversacionNestedInput
    asesoramiento?: AsesoramientoUncheckedUpdateOneWithoutConversacionNestedInput
    encuesta?: EncuestaSatisfaccionUncheckedUpdateOneWithoutConversacionNestedInput
  }

  export type ConversacionUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    consultorio?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    canal?: StringFieldUpdateOperationsInput | string
    primerMensaje?: NullableStringFieldUpdateOperationsInput | string | null
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncuestaSatisfaccionUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversacion?: ConversacionUpdateOneWithoutEncuestaNestedInput
  }

  export type EncuestaSatisfaccionUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: NullableStringFieldUpdateOperationsInput | string | null
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncuestaSatisfaccionUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: NullableStringFieldUpdateOperationsInput | string | null
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    fuente?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsesoramientoUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversacion?: ConversacionUpdateOneRequiredWithoutAsesoramientoNestedInput
  }

  export type AsesoramientoUncheckedUpdateWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsesoramientoUncheckedUpdateManyWithoutEstudianteInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversacionId?: StringFieldUpdateOperationsInput | string
    temaLegal?: StringFieldUpdateOperationsInput | string
    resumen?: NullableStringFieldUpdateOperationsInput | string | null
    duracionMinutos?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitaCreateManyConversacionInput = {
    id?: string
    estudianteId: string
    fecha: Date | string
    hora: string
    modalidad: $Enums.Modalidad
    motivo?: string | null
    estado?: $Enums.EstadoCita
    usuarioNombre?: string | null
    usuarioTipoDocumento?: string | null
    usuarioNumeroDocumento?: string | null
    usuarioCorreo?: string | null
    usuarioTelefono?: string | null
    enlaceReunion?: string | null
    notifEnviada24h?: boolean
    notifEnviada15m?: boolean
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type MensajeCreateManyConversacionInput = {
    id?: string
    tipo: string
    contenido: string
    createdAt?: Date | string
  }

  export type CitaUpdateWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiante?: EstudianteUpdateOneRequiredWithoutCitasNestedInput
  }

  export type CitaUncheckedUpdateWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CitaUncheckedUpdateManyWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: StringFieldUpdateOperationsInput | string
    modalidad?: EnumModalidadFieldUpdateOperationsInput | $Enums.Modalidad
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoCitaFieldUpdateOperationsInput | $Enums.EstadoCita
    usuarioNombre?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTipoDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioNumeroDocumento?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioCorreo?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    enlaceReunion?: NullableStringFieldUpdateOperationsInput | string | null
    notifEnviada24h?: BoolFieldUpdateOperationsInput | boolean
    notifEnviada15m?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeUpdateWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeUncheckedUpdateWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensajeUncheckedUpdateManyWithoutConversacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateManyContactInput = {
    id?: string
    tenantId: string
    channel: $Enums.Channel
    status?: $Enums.ConversationStatus
    lastMessageAt?: Date | string
    currentFlowVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyContactInput = {
    id?: string
    tenantId: string
    conversationId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
  }

  export type ConversationUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contexts?: ConversationContextUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contexts?: ConversationContextUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    channel?: EnumChannelFieldUpdateOperationsInput | $Enums.Channel
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentFlowVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationContextCreateManyConversationInput = {
    id?: string
    tenantId: string
    version: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    tenantId: string
    contactId: string
    direction: $Enums.Direction
    type: $Enums.MessageType
    text?: string | null
    payload: JsonNullValueInput | InputJsonValue
    providerMessageId?: string | null
    createdAt?: Date | string
  }

  export type ConversationContextUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationContextUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationContextUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    direction?: EnumDirectionFieldUpdateOperationsInput | $Enums.Direction
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    text?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    providerMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}